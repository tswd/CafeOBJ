\part{仕様検証システム検査仕様・結果}
\label{sec:spec-test}

仕様検証システムは, 表\ref{tab:system-functions}の
機能第1項(仕様間の射の自動構成機能)と, 
第3項(詳細化検証機能)に対応するサブシステムである.
以降では, これら2つの機能に付いて検査仕様と検査結果を示す.
本システムは反駁システムの提供する機能をフルに使用しているため,
ここで行われる定理証明にかかわる検査は, 反駁システムに対する
総合的な検査の意味もある.

\section{仕様間の射の自動構成機能}
\label{sec:sigmatch}
本章では, 仕様間の射の自動構成機能に関する検査項目とその結果, 
ならびに各検査項目の具体的な内容に付いて述べる.

\subsection{検査項目}
\label{sec:sigmatch-test-item}
検査項目は次の通りである：
\begin{enumerate}
\item 単純な射の生成\\
  可能な射が一つに限られる場合について, 正しく射が構成されることを検査する.

\Item 複数の射の生成 \\
  可能な射が一つに限られない場合について, 可能な射が全て生成
  される事を検査する.

\item 射が構成できない場合\\
  可能な射が一つもない場合について, 射が構成されないことを
  検査する.

\end{enumerate}

\subsection{検査結果一覧}
\label{sec:sigmatch-test-res-all}
第\ref{sec:sigmatch-test-item}節で示した各検査項目に対する
検査結果を表\ref{tab:sigmatch-test-res}に示す. 

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}[h]{|l|c|c|}\hline
      検査項目 & 結果 & 該当章番号 \\\hline
      単純な射の生成 & ○ & \ref{sec:mono-view} \\
      複数の射の生成 & ○ & \ref{sec:multi-view} \\
      射が構成できない場合 & ○ & \ref{sec:null-view} \\\hline
    \end{tabular}
    \caption{仕様間の射の自動構成機能検査結果}
    \label{tab:sigmatch-test-res}
  \end{center}
\end{table}

\subsection{単純な射の生成}
\label{sec:mono-view}
\subsubsection{検査内容}

\begin{enumerate}
\item 仕様射構成のベースとするモジュールに対して
  単一の射のみが構成できるモジュールとの間で,
  仕様射の自動構成機能(コマンド \verb:sigmatch:)を
  起動し, 単一の射が構成される事かどうかを検査する.
\item 生成された射が, 予想したものと同等の物であるかどうかを,
  コマンド \verb:show view: を用いて生成された射を
  印字し, 内容を調べることによって行う.
\end{enumerate}

具体的なテスト内容と予想結果については, 次節を参照されたい.

\subsubsection{テストデータと手順}
\label{sec:sigmatch-mono-data}

\begin{enumerate}
\item 下に示すような, モジュール群の定義と
  sigmatch コマンドの起動スクリプトを,
  ファイル ``sigmatch-mono.mod'' に書き込んでおく.

{\small
\begin{verbatim}
**>
**> 単一の射の自動構成テストのためのモジュール宣言と
**> sigmatch コマンドの起動
**>

-->
--> ベースとなるモジュール ： CONTAINER
-->

mod* CONTAINER(X :: TRIV) 
{
  *[ Container ]*

  op empty : -> Container
  bop store : Elt Container -> Container
  bop val : Container -> Elt
}

-->
--> テスト対象のモジュール : BUF
--> 
mod* BUF(X :: TRIV)
{
  *[ Buf ]*
  op init :  -> Buf 
  bop in : Elt Buf -> Buf
  bop val : Buf -> Elt
  bop out : Buf -> Buf
  bop empty? : Buf -> Bool
}

**> sigmatch を起動
--> sigmatch (CONTAINER) to (BUF)
-->
sigmatch (CONTAINER) to (BUF)

-->
--> テスト対象のモジュール : CELL
--> 
mod* CELL(X :: TRIV) 
{
  *[ Cell ]*

  op init-cell : -> Cell
  bop put : Elt Cell -> Cell
  bop get : Cell -> Elt
}

**> sigmatch を起動
--> sigmatch (CONTAINER) to (CELL)
-->
sigmatch (CONTAINER) to (CELL)

-->
--> テスト対象のモジュール : LIST
--> 
mod* LIST(X :: TRIV)  
{

  *[ List ]*

  op nil : -> List   
  op cons : Elt List -> List {coherent}
  bop car : List -> Elt
  bop cdr : List -> List
}

**> sigmatch を起動
--> sigmatch (CONTAINER) to (LIST)
-->
sigmatch (CONTAINER) to (LIST)

-->
--> テスト対象のモジュール : QUEUE
--> 

mod* QUEUE(X :: TRIV) 
{
  *[ Queue ]*
  op empty : -> Queue 
  bop front : Queue -> Elt
  bop enq : Elt Queue -> Queue
  bop deq : Queue -> Queue
}

**> sigmatch を起動
--> sigmatch (CONTAINER) to (QUEUE)
-->
sigmatch (CONTAINER) to (QUEUE)

-->
--> テスト対象のモジュール : STACK
--> 

mod* STACK(X :: TRIV) 
{
  *[ Stack ]*
  op empty : -> Stack
  bop top : Stack -> Elt
  bop push : Elt Stack -> Stack
  bop pop : Stack -> Stack
}

**> sigmatch を起動
--> sigmatch (CONTAINER) to (STACK)
-->
sigmatch (CONTAINER) to (STACK)

**
eof
\end{verbatim}
}
\item これらは極く単純なシグニチャであり, 可能な仕様射はただ一つしか
  無い事は容易に分かる. 可能な射は次のとおりである：
  まず, 全ての場合について, CONTAINER の隠れソート Container は,
  それぞれ対象とされるモジュールで宣言されている唯一の隠れソート
  (例えばモジュール BUF の場合は, Buf)に写像されるはずである.
  また, オペレータの対応関係は下に示すようになるはずである.
  \begin{enumerate}
  \item モジュール BUF の場合：
  \begin{verbatim}
    empty ---> init
    val   ---> val
    store ---> in
  \end{verbatim}
  \item モジュール CELL の場合：
  \begin{verbatim}
    empty ---> init-cell
    val   ---> get
    store ---> put
  \end{verbatim}  
  \item モジュール LIST の場合：
  \begin{verbatim}
    empty ---> nil
    val   ---> car
    store ---> cons
  \end{verbatim}
  \item モジュール QUEUE の場合:
  \begin{verbatim}
    empty ---> empty
    val   ---> front
    store ---> enq
  \end{verbatim}
  \item モジュール STACK の場合：
  \begin{verbatim}
    empty ---> empty
    val   ---> top
    store ---> push
  \end{verbatim}
  \end{enumerate}

\item 生成された仕様射の内容は, 各 \verb:sigmatch: の起動によって
  システムが印字する射の名前を見て, これを \verb:show view: コマンドの
  引数として与える事によって表示する.
  これが, 上で述べた可能な射と同じかどうかを調べる.
\end{enumerate}

\subsubsection{実行結果}
\begin{enumerate}
\item 前節(第\ref{sec:sigmatch-mono-data}節)で述べたテストデータを
  書き込んだファイル ``sigmatch-mono.mod'' をインタプリタに読み込んだ.
  結果のログは以下の通りである.
{\small
  \begin{verbatim}
CafeOBJ> in sigmatch-mono
processing input : ./sigmatch-mono.mod
**> 
**> 単一の射の自動構成テストのためのモジュール宣言と
**> sigmatch コマンドの起動
**> 
--> 
--> ベースとなるモジュール ： CONTAINER
--> 
-- defining module* CONTAINER_*_*....._*
** system failed to prove =*= is a congruence of CONTAINER done.
--> 
--> テスト対象のモジュール : BUF
--> 
-- defining module* BUF_*_*......._*
** system failed to prove =*= is a congruence of BUF done.
**> sigmatch を起動
--> sigmatch (CONTAINER) to (BUF)
--> 
(V#1)
--> 
--> テスト対象のモジュール : CELL
--> 
-- defining module* CELL_*_*....._*
** system failed to prove =*= is a congruence of CELL done.
**> sigmatch を起動
--> sigmatch (CONTAINER) to (CELL)
--> 
(V#2)
--> 
--> テスト対象のモジュール : LIST
--> 
-- defining module* LIST_*_*......_*
** system failed to prove =*= is a congruence of LIST done.
**> sigmatch を起動
--> sigmatch (CONTAINER) to (LIST)
--> 
(V#3)
--> 
--> テスト対象のモジュール : QUEUE
--> 
-- defining module* QUEUE_*_*......_*
** system failed to prove =*= is a congruence of QUEUE done.
**> sigmatch を起動
--> sigmatch (CONTAINER) to (QUEUE)
--> 
(V#4)
--> 
--> テスト対象のモジュール : STACK
--> 
-- defining module* STACK_*_*......_*
** system failed to prove =*= is a congruence of STACK done.
**> sigmatch を起動
--> sigmatch (CONTAINER) to (STACK)
--> 
(V#5)
  \end{verbatim}
}
  これを見ると, それぞれについてただ一つの射が構成されている.
  これは予想通りである.

\item 次に, 上記の結果システムが印字した射を表示し, 内容を
  確認するために, show view コマンドを用いてそれぞれの
  射を印字した. 結果は下の通りである：
{\small
  \begin{verbatim}
CafeOBJ> show view V#1
view V#1 from CONTAINER(X) to BUF(X) {sort Elt -> Elt
    hsort Container -> Buf
    hsort ?Container -> ?Buf
    op (Container : -> SortId) -> (Buf : -> SortId)
    op (Elt : -> SortId) -> (Elt : -> SortId)
    op (_=*=_ : Container Container -> Bool) -> (_=*=_ : _ HUniversal _
                                                         _ HUniversal _
                                                         -> 
                                                        Bool)
    op (empty : -> Container) -> (init : -> Buf)
    bop (val : Container -> Elt) -> (val : Buf -> Elt)
    bop (store : Elt Container -> Container) -> (in : Elt Buf
                                                      -> Buf)
 }
CafeOBJ> show view V#2
view V#2 from CONTAINER(X) to CELL(X) {sort Elt -> Elt
    hsort Container -> Cell
    hsort ?Container -> ?Cell
    op (Container : -> SortId) -> (Cell : -> SortId)
    op (Elt : -> SortId) -> (Elt : -> SortId)
    op (_=*=_ : Container Container -> Bool) -> (_=*=_ : _ HUniversal _
                                                         _ HUniversal _
                                                         -> 
                                                        Bool)
    op (empty : -> Container) -> (init-cell : -> Cell)
    bop (val : Container -> Elt) -> (get : Cell -> Elt)
    bop (store : Elt Container -> Container) -> (put : Elt Cell
                                                       -> Cell)
 }
CafeOBJ> show view V#3
view V#3 from CONTAINER(X) to LIST(X) {sort Elt -> Elt
    hsort Container -> List
    hsort ?Container -> ?List
    op (Container : -> SortId) -> (List : -> SortId)
    op (Elt : -> SortId) -> (Elt : -> SortId)
    op (_=*=_ : Container Container -> Bool) -> (_=*=_ : _ HUniversal _
                                                         _ HUniversal _
                                                         -> 
                                                        Bool)
    op (empty : -> Container) -> (nil : -> List)
    bop (val : Container -> Elt) -> (car : List -> Elt)
    bop (store : Elt Container -> Container) -> (cons : Elt List
                                                        -> List)
 }
CafeOBJ> show view V#4
view V#4 from CONTAINER(X) to QUEUE(X) {sort Elt -> Elt
    hsort Container -> Queue
    hsort ?Container -> ?Queue
    op (Container : -> SortId) -> (Queue : -> SortId)
    op (Elt : -> SortId) -> (Elt : -> SortId)
    op (_=*=_ : Container Container -> Bool) -> (_=*=_ : _ HUniversal _
                                                         _ HUniversal _
                                                         -> 
                                                        Bool)
    op (empty : -> Container) -> (empty : -> Queue)
    bop (val : Container -> Elt) -> (front : Queue -> Elt)
    bop (store : Elt Container -> Container) -> (enq : Elt Queue
                                                       -> Queue)
 }
CafeOBJ> show view V#5
view V#5 from CONTAINER(X) to STACK(X) {sort Elt -> Elt
    hsort Container -> Stack
    hsort ?Container -> ?Stack
    op (Container : -> SortId) -> (Stack : -> SortId)
    op (Elt : -> SortId) -> (Elt : -> SortId)
    op (_=*=_ : Container Container -> Bool) -> (_=*=_ : _ HUniversal _
                                                         _ HUniversal _
                                                         -> 
                                                        Bool)
    op (empty : -> Container) -> (empty : -> Stack)
    bop (val : Container -> Elt) -> (top : Stack -> Elt)
    bop (store : Elt Container -> Container) -> (push : Elt Stack
                                                        -> Stack)
 }
  \end{verbatim}
}

  結果は予想通りであり, 正しい.
\end{enumerate}

\subsection{複数の射の生成}
\label{sec:multi-view}
\subsubsection{検査内容}
\begin{enumerate}
\item 複数の仕様射があり得るモジュールの組合せに対して
  sigmatch コマンドを起動し, 結果として複数の射が
  実際に構成されることを確認する.
\item 生成されたそれぞれの射が, あらかじめ想定されていた
  射と一致するものかどうかを確認する. 
  これは上の sigmatch コマンドの実行の結果得られた
  射の名前を参照し, show view コマンドによって射の内容を
  印字する事によって行う.
\end{enumerate}

具体的なテスト内容と予想結果については, 次節で述べる.

\subsubsection{テストデータと手順}
\label{sec:multi-view-test-data}

\begin{enumerate}
\item 下に示すような, モジュール定義および sigmatch コマンドの
  起動スクリプトを, ファイル ``sigmatch-mult.mod'' に書き込んでおく.
\begin{verbatim}
**>
**> 複数の射の自動構成テストのためのモジュール宣言と
**> sigmatch コマンドの起動
**>

-->
--> ベースとなるモジュール ： CONTAINER
-->

mod* CONTAINER(X :: TRIV) 
{
  *[ Container ]*

  op empty : -> Container
  bop store : Elt Container -> Container
  bop val : Container -> Elt
}

-->
--> テスト対象のモジュール : MTEST
--> 
mod* MTEST(X :: TRIV)
{
  *[ H ]*

  op init : -> H
  bop m1   : H Elt -> H
  bop m2   : Elt H -> H
  bop a1   : H -> Elt
  bop a2   : H -> Elt
}

**> sigmatch コマンドの起動
--> sigmatch (CONTAINER) to (MTEST)
-->
sigmatch (CONTAINER) to (MTEST)
\end{verbatim}
\item これをインタプリタに読み込み複数の view が生成されていることを
  検査する. 
  
  上の場合, 隠れソートの対応は CONTAINER の Container に対して,
  MTEST の H が対応することになるが, オペレータの対応関係は
  複数の組み合わせがあり, 下に示す4通りの組み合わせが可能である：
  \begin{enumerate}
  \item[1]
    \begin{verbatim}
    empty   ---> init
    store   ---> m1
    val     ---> a1
    \end{verbatim}
  \item[2]
    \begin{verbatim}
    empty   ---> init
    store   ---> m1
    val     ---> a2
    \end{verbatim}
  \item[3]
    \begin{verbatim}
    empty   ---> init
    store   ---> m2
    val     ---> a1
    \end{verbatim}
  \item[4]
    \begin{verbatim}
    empty   ---> init
    store   ---> m2
    val     ---> a2
    \end{verbatim}
  \end{enumerate}
  従って, sigmatch コマンドの実行結果として, 互いに異なる4つの射が生成され,
  それらは上のどれかと対応するものでなければならない.

\item 生成された射の内容を見るのには, sigmatch コマンドの結果得られた
  射の名前を, show view コマンドの引数として与える事によって行う.
\end{enumerate}

\subsubsection{実行結果}

\begin{enumerate}
\item 第\ref{sec:multi-view-test-data} で示されたテストデータを
  ファイル ``sigmatch-mult.mod'' に書き込み, これをインタプリタに
  ロードした. 結果は下のようになった.
{\small
\begin{verbatim}
CafeOBJ> in sigmatch-mult
processing input : ./sigmatch-mult.mod
**> 
**> 複数の射の自動構成テストのためのモジュール宣言と
**> sigmatch コマンドの起動
**> 
--> 
--> ベースとなるモジュール ： CONTAINER
--> 
-- defining module* CONTAINER_*_*....._*
** system failed to prove =*= is a congruence of CONTAINER done.
--> 
--> テスト対象のモジュール : MTEST
--> 
-- defining module* MTEST_*_*......._*
** system failed to prove =*= is a congruence of MTEST done.
**> sigmatch コマンドの起動
--> sigmatch (CONTAINER) to (MTEST)
--> 
(V#4 V#3 V#2 V#1)
\end{verbatim}
}
  予想通り4個の射が生成されている.

\item これらの射が正しく構成されていることを確かめるため,
  それぞれの射を show view コマンドによって表示した.
  結果は次の通りである：
{\small
\begin{verbatim}
CafeOBJ> show view V#1
view V#1 from CONTAINER(X) to MTEST(X) {sort Elt -> Elt
    hsort Container -> H
    hsort ?Container -> ?H
    op (Container : -> SortId) -> (H : -> SortId)
    op (Elt : -> SortId) -> (Elt : -> SortId)
    op (_=*=_ : Container Container -> Bool) -> (_=*=_ : _ HUniversal _
                                                         _ HUniversal _
                                                         -> 
                                                        Bool)
    op (empty : -> Container) -> (init : -> H)
    bop (val : Container -> Elt) -> (a2 : H -> Elt)
    bop (store : Elt Container -> Container) -> (m1 : H Elt -> 
                                                     H)
 }
CafeOBJ> show view V#2
view V#1 from CONTAINER(X) to MTEST(X) {sort Elt -> Elt
    hsort Container -> H
    hsort ?Container -> ?H
    op (Container : -> SortId) -> (H : -> SortId)
    op (Elt : -> SortId) -> (Elt : -> SortId)
    op (_=*=_ : Container Container -> Bool) -> (_=*=_ : _ HUniversal _
                                                         _ HUniversal _
                                                         -> 
                                                        Bool)
    op (empty : -> Container) -> (init : -> H)
    bop (val : Container -> Elt) -> (a1 : H -> Elt)
    bop (store : Elt Container -> Container) -> (m1 : H Elt -> 
                                                     H)
 }
CafeOBJ> show view V#3
view V#1 from CONTAINER(X) to MTEST(X) {sort Elt -> Elt
    hsort Container -> H
    hsort ?Container -> ?H
    op (Container : -> SortId) -> (H : -> SortId)
    op (Elt : -> SortId) -> (Elt : -> SortId)
    op (_=*=_ : Container Container -> Bool) -> (_=*=_ : _ HUniversal _
                                                         _ HUniversal _
                                                         -> 
                                                        Bool)
    op (empty : -> Container) -> (init : -> H)
    bop (val : Container -> Elt) -> (a2 : H -> Elt)
    bop (store : Elt Container -> Container) -> (m2 : H Elt -> 
                                                     H)
 }
CafeOBJ> show view V#4
view V#1 from CONTAINER(X) to MTEST(X) {sort Elt -> Elt
    hsort Container -> H
    hsort ?Container -> ?H
    op (Container : -> SortId) -> (H : -> SortId)
    op (Elt : -> SortId) -> (Elt : -> SortId)
    op (_=*=_ : Container Container -> Bool) -> (_=*=_ : _ HUniversal _
                                                         _ HUniversal _
                                                         -> 
                                                        Bool)
    op (empty : -> Container) -> (init : -> H)
    bop (val : Container -> Elt) -> (a1 : H -> Elt)
    bop (store : Elt Container -> Container) -> (m2 : H Elt -> 
                                                     H)
 }
\end{verbatim}
}
\item 上で印字された各々の射は互いに異なった内容であり,
  また, 先に予想された写像(第 \ref{sec:multi-view-test-data} 節)
の一つと同等である. 従って結果は正しい.
\end{enumerate}

\subsection{射が構成できない場合}
\label{sec:null-view}
\subsubsection{検査内容}
\begin{enumerate}
\item どのような射も構成できない事が分かっているモジュール
  間で sigmatch コマンドを起動し, 結果としてどのような射も
  構成されない事を確認する.
\end{enumerate}

\subsubsection{テストデータと手順}
\label{sec:null-view-data}
\begin{enumerate}
\item 下に示すような, モジュール群の定義と sigmatch コマンドの
  起動スクリプトを, ファイル ``sigmatch-null.mod'' に書き込んでおく.
{\small
\begin{verbatim}
**>
**> 射が無い場合のテストのためのモジュール宣言と
**> sigmatch コマンドの起動
**>

-->
--> ベースとなるモジュール ： CONTAINER
-->

mod* CONTAINER(X :: TRIV) 
{
  *[ Container ]*

  op empty : -> Container
  bop store : Elt Container -> Container
  bop val : Container -> Elt
}

--> 
--> テスト対象のモジュール : ARR
--> 
mod* ARR(X :: TRIV) 
{
  protecting(NAT)
  *[ Arr ]*
  op nil : -> Arr
  bop put : Elt Nat Arr -> Arr
  bop  _[_] : Arr Nat -> Elt
}

**> sigmatch を起動
--> sigmatch (CONTAINER) to (ARR)
-->
sigmatch (CONTAINER) to (ARR)

-->
--> テスト対象のモジュール : BAG
--> 
mod* BAG(X :: TRIV) 
{

  protecting(NAT)
  *[ Bag ]*
  op empty :  -> Bag 
  bop put : Elt Bag -> Bag
  bop take : Elt Bag -> Bag
  bop get : Bag Elt -> Nat
}

**> sigmatch を起動
--> sigmatch (CONTAINER) to (BAG)
-->
sigmatch (CONTAINER) to (BAG)

-->
--> テスト対象のモジュール : COUNTER
--> 
mod* COUNTER {
  protecting(INT)

  *[ Counter ]*

  op init : -> Counter
  bop add : Int Counter -> Counter
  bop read_ : Counter -> Int
}

**> sigmatch を起動
--> sigmatch (CONTAINER) to (COUNTER)
-->
sigmatch (CONTAINER) to (COUNTER)

-->
--> テスト対象のモジュール : BASICSETS
--> 

mod* BASICSETS(X :: TRIV) 
{

  *[ Set ]*

  op empty : -> Set 
  op add   : Elt Set -> Set {coherent}
  bop _in_  : Elt Set -> Bool
}

**> sigmatch を起動
--> sigmatch (CONTAINER) to (BASICSETS)
-->
sigmatch (CONTAINER) to (BASICSETS)
\end{verbatim}
}
  上のどの sigmatch においても, 可能な射は一つもない.
\item このファイルをシステムにロードし, 各 sigmatch コマンドの
  起動結果として, 何も射が構成されないことを確認する.
\end{enumerate}

\subsubsection{実行結果}

\begin{enumerate}
\item 第\ref{sec:null-view-data}節で示されたようにテストデータが
  書き込まれたファイル ``sigmatch-null.mod'' をシステムにロードした.
  結果は次の通りである：
{\small
\begin{verbatim}
CafeOBJ> in sigmatch-null
processing input : ./sigmatch-null.mod
**> 
**> 射が無い場合のテストのためのモジュール宣言と
**> sigmatch コマンドの起動
**> 
--> 
--> ベースとなるモジュール ： CONTAINER
--> 
-- defining module* CONTAINER_*_*....._*
** system failed to prove =*= is a congruence of CONTAINER done.
--> 
--> テスト対象のモジュール : ARR
--> 
-- defining module* ARR_*_*......_*
** system failed to prove =*= is a congruence of ARR done.
**> sigmatch を起動
--> sigmatch (CONTAINER) to (ARR)
--> 
( )
--> 
--> テスト対象のモジュール : BAG
--> 
-- defining module* BAG_*_*......._*
** system failed to prove =*= is a congruence of BAG done.
**> sigmatch を起動
--> sigmatch (CONTAINER) to (BAG)
--> 
( )
--> 
--> テスト対象のモジュール : COUNTER
--> 
-- defining module* COUNTER....._*
** system failed to prove =*= is a congruence of COUNTER done.
**> sigmatch を起動
--> sigmatch (CONTAINER) to (COUNTER)
--> 
( )
--> 
--> テスト対象のモジュール : BASICSETS
--> 
-- defining module* BASICSETS_*_*....._*
** system already proved =*= is a congruence of BASICSETS done.
**> sigmatch を起動
--> sigmatch (CONTAINER) to (BASICSETS)
--> 
( )
\end{verbatim}
}
\item いずれの sigmatch の結果も射は構成されていない.
  これは予想通りの結果である.
\end{enumerate}
%%%%
\section{詳細化検証機能}
\label{sec:refine-check}
本章では, 詳細化検証機能に関する検査項目とその結果,
ならびに各検査項目の具体的な内容について述べる.

\subsection{検査項目}
仕様の詳細化機能に関して行わなければならない検査項目は
以下の通りである：

\begin{enumerate}
\item 詳細化である場合. \\
  仕様 $M'$ が仕様射 $V$ を通して, 仕様 $M$ の詳細化と
  なっている場合, 仕様詳細化検証機能による検査結果は,
  `yes' とならなければならない.

\item 詳細化でない場合.\\
  この場合は, 結果が `no' であると同時に, 満足されなかった
  等式の一覧が表示されなければならない.

\end{enumerate}

\subsection{検査結果一覧}
表 \ref{tab:refine-check-res-all} に, 各検査項目の試験結果を示す.

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}[h]{|l|c|c|} \hline
      検査項目 & 結果 & 該当章番号 \\\hline
      詳細化である場合 & ○ & \ref{sec:refine-case} \\
      詳細化でない場合 & ○ & \ref{sec:non-refine-case} \\\hline
    \end{tabular}
    \caption{詳細化検証機能検査結果一覧}
    \label{tab:refine-check-res-all}
  \end{center}
\end{table}

\subsection{詳細化である場合}
\label{sec:refine-case}
\subsubsection{検査内容}

\begin{enumerate}
\item 仕様 $M_1$ と仕様 $M_2$, および $M_1$ から $M_2$ への
  仕様射 $V$ を用意する. この $V$ によって, $M_1$ を $M_2$ 
  へ写像した場合, $M_1$ のもつ公理は全て満足されるものである.
  すなわち, 仕様 $M_2$ は, $M_1$ の詳細化となっている.
\item 上の $V$ に関して, 仕様詳細化検査(コマンド check refinement)
  によって検査し, 結果が `yes' となることを確認する.
\item 試験は, 手動(自分で仕様射を定義)の場合と,
  自動構成機能を用いた射を用いた場合, それぞれについて行う.
\item いずれの場合も, 写像される側の仕様の公理が,
  射によって, 正しく写像先の仕様に移されて検査されることを
  確かめる.
\end{enumerate}

具体的なテストデータ, およびテスト手順については次節を参照されたい.

\subsubsection{テストデータならびに手順}
\label{sec:ref-check-ok-data}
\begin{enumerate}
\item 手動で定義した射による場合
  \begin{enumerate}
  \item 下に示すモジュール定義, と射, さらに
    この射に関する仕様詳細化検査コマンド(check refinement)
    を, ファイル ``ref-check-ok-1.mod'' に書き込んでおく.
    \begin{verbatim}
**>
**> 詳細化検証機能
**> view が詳細化となっている場合-1
**> 手動で view を定義する．

**> 自然数上のかけ算と足し算の定義されたモジュール TIMES-NAT
mod! TIMES-NAT {
  [ NzNat Zero < Nat ]

  op 0 : -> Zero
  op s_ : Nat -> NzNat
  op _+_ : Nat Nat -> Nat
  op _*_ : Nat Nat -> Nat

  vars M N : Nat 
    
  eq N + s(M) = s(N + M) .
  eq N + 0 = N . 
  eq 0 + N = N .
  eq 0 * N = 0 .
  eq N * 0 = 0 .
  eq N * s(M) = (N * M) + N .
}

**> モノイド
mod* MON {
  [ Elt ]

  op null :  ->  Elt
  op _;_ : Elt Elt -> Elt {assoc idr: null} 
}

**> view の定義
--> モノイドの2項演算を足し算に，
--> 単位元を 0 に写像する．
**>
view plus from MON to TIMES-NAT {
  sort Elt -> Nat, 
  op _;_ -> _+_,  
  op null -> 0 
}

**> 自然数上の足し算はモノイドと解釈できる
**> つまり, 仕様射 plus は，TIMES-NAT が,
**> MON の詳細化を定義するものであることを示す．
--> 検査される公理を印字するために, フラグを設定する.
--> flag(debug-refine,on)
flag(debug-refine,on)
--> check refinement plus
check refinement plus
    \end{verbatim}
  \item 上のファイルをインタプリタにロードし, 最後の
    check コマンドの結果として, `yes' が返ること確認する.
  \end{enumerate}
  この場合, モジュール MONOID は, モノイドを定義したものである．
  また, TIMES-NAT は単純な自然数とその上に足し算(\verb:_+_:)と
  かけ算(\verb:_*_:)を定義したものである．
  常識的に, 自然数上の足し算は, モノイドを構成する事は明らかで
  ある. 上で定義されている(CafeOBJ 言語の view 宣言による)射
  は, この通常の解釈をおこなうものであり, 2項演算を足し算と解釈し, 
  単位元を 0 に写像するものを定義した物である．

  検査によって, MONOID の以下の公理(これらは, オペレータ 
  \verb:_;_: の属性宣言 idr: null によって, CafeOBJ インタプリタ
  が自動的に宣言するものである)
  \begin{verbatim}
  null ; ID:Elt = ID .
  ID:Elt ; null = ID .
  \end{verbatim} 
  が，この view によって,
  \begin{verbatim}
  0 ; ID:Nat = ID .
  ID:Nat ; 0 = ID .
  \end{verbatim}
  と写像されて，検査することを確認する.
  また, 推論の様子や，結果の証明を見て,
  正しさを確認する.
  これは, フラグ debug-refine を on にすることによって,
  表示されるようになる.

  上の, TIMES-NAT で解釈された MONOID の公理が
  TIMES-NAT で成立することは明らかである.
  従って, 最後の check refinement コマンドの実行
  結果は yes とならなければならない.

\item 自動生成された射による場合
  \begin{enumerate}
  \item 下に示すモジュール定義および sigmatch コマンド列を
    ファイル ``ref-check-ok-2.mod'' に書き込んでおく.
{\small
\begin{verbatim}
**>
**> 仕様詳細化検査の試験 - 2
**> 自動生成された射により，全て詳細化検査が成功する場合.

**> もとになる仕様：CONTAINER
**> 一般的な「入れ物」を定義したモジュール
**>
mod* CONTAINER(X :: TRIV) 
{
  *[ Container ]*

  -- 空の入れ物
  op empty : -> Container
  -- 要素を入れる
  bop store : Elt Container -> Container
  -- 入れ物の中を見る
  bop val : Container -> Elt

  var E : Elt
  var C : Container
  -- 要素Eを格納した直後に中を見るとEが見える
  eq val(store(E,C)) = E .
}

**>
**> CELL : CONTAINER と同じく一般的な入れ物
**>
mod* CELL(X :: TRIV) 
{
  *[ Cell ]*

  op init-cell : -> Cell
  bop put : Elt Cell -> Cell
  bop get : Cell -> Elt

  var E : Elt
  var C : Cell

  eq get(put(E,C)) = E .
}

**>
**> STACK : 先入れ先だし方式の入れ物
**>
mod* STACK(X :: TRIV) 
{
  *[ Stack ]*
  op empty : -> Stack
  bop top : Stack -> Elt
  bop push : Elt Stack -> Stack
  bop pop : Stack -> Stack
  vars D : Elt   var S : Stack
  eq pop(empty) = empty .
  eq top(push(D,S)) = D .
  beq pop(push(D,S)) = S .
}

**>
**> LIST : リスト構造
**>
mod* LIST(X :: TRIV)  {

  *[ List ]*

  op nil : -> List   
  op cons : Elt List -> List {coherent}
  bop car : List -> Elt
  bop cdr : List -> List
    
  vars E E' : Elt
  var L : List

  eq car(cons(E, L)) = E .
  beq cdr(nil) = nil .
  beq cdr(cons(E, L)) = L .
}

**> それぞれのモジュールについて，CONTAINER との sigmatch を
**> 実行して，射を自動生成する．

--> sigmatch (CONTAINER) to (CELL)
-->
sigmatch (CONTAIER) to (CELL)

--> sigmatch (CONTAINER) to (STACK)
-->
sigmatch (CONTAINER) to (STACK)

--> sigmatch (CONTAINER) to (LIST)
-->
sigmatch (COTAINER) to (LIST)
\end{verbatim}
}
  \item 上のファイルをシステムにロードし, sigmatch によって
    自動生成された射の名前を得る.
  \item それぞれの射に対して, check refinement コマンドを実行し,
    結果を確認する.

    この際に, COTAINER の公理が, 射によって正しくそれぞれの
    モジュールに写像され証明される様子を見るために,
    フラグ debug-refine を on としておく事.

    全ての場合で, 結果は yes とならなければならない.
  \end{enumerate}
\end{enumerate}


\subsubsection{実行結果}

\begin{enumerate}
\item 手動で定義した射による場合\\
  第\ref{sec:ref-check-ok-data}節の第1項で述べられているように,
  ファイル ``ref-check-ok-1.mod'' をシステムにロードした.
  結果は次の通りである.
{\small
\begin{verbatim}
CafeOBJ> in ref-check-ok-1
processing input : ./ref-check-ok-1.mod
**> 
**> 詳細化検証機能
**> view が詳細化となっている場合-1
**> 手動で view を定義する．
**> 自然数上のかけ算と足し算の定義されたモジュール TIMES-NAT
-- defining module! TIMES-NAT......_......* done.
**> モノイド
-- defining module* MON.._._* done.
**> view の定義
--> モノイドの2項演算を足し算に，
--> 単位元を 0 に写像する．
**> 
-- defining view plus 
[Warning]: operator mapping is not strict wrt sort map:
    * sort map
    - Elt --> Nat
    * operator map
    - source: null : -> Elt
    - target: 0 : -> Zero done.
**> 自然数上の足し算はモノイドと解釈できる
**> つまり, 仕様射 plus は，TIMES-NAT が,
**> MON の詳細化を定義するものであることを示す．
--> check refinement plus
** starting refinement check with view plus_*
-- check axiom : 
   eq [ident12] : 0 + X-ID:Nat = X-ID:Nat_
   dependent: flag(auto, on)
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
   dependent: flag(universal-symmetry, on)
[Properties of input clauses]:
   propositional  = no
   horn           = yes
   equality       = yes
   symmetry       = no
   max literals   = 1
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
 
** start input processing.

 
** USABLE _______________________________
 
  7:[] ~(0 + #c-1.Nat = #c-1.Nat)
 
 process usable:
* kept in usable : weight=5
  7:[] ~(0 + #c-1.Nat = #c-1.Nat)
 
** SOS __________________________________
 
  8:[] Univ324 = Univ324
  1:[] _v3:Nat + s _v4:Nat = s (_v3 + _v4)
  2:[] _v6:Nat + 0 = _v6
  3:[] 0 + _v8:Nat = _v8
  4:[] 0 * _v10:Nat = 0
  5:[] _v12:Nat * 0 = 0
  6:[] _v16:Nat * s _v15:Nat = (_v16 * _v15) + _v16
 
 process sos:
* kept in sos : weight=3
  8:[] _v18 = _v18
* kept in sos : weight=9
  1:[] _v21:Nat + s _v22:Nat = s (_v21 + _v22)
* kept in sos : weight=5
  2:[] _v24:Nat + 0 = _v24
* kept in sos : weight=5
  3:[] 0 + _v26:Nat = _v26
 
** UNIT CONFLICT_________________________
 
  14:[binary:3,7] 
 
** PROOF ________________________________
 
  3:[] 0 + _v26:Nat = _v26
  7:[] ~(0 + #c-1.Nat = #c-1.Nat)
  14:[binary:3,7] 
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........0  |
|  clauses kept             .........5  |
|  clauses forward subsumed .........0  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.020 sec)_*
-- check axiom : 
   eq [ident13] : Y-ID:Nat + 0 = Y-ID:Nat_
   dependent: flag(auto, on)
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
   dependent: flag(universal-symmetry, on)
[Properties of input clauses]:
   propositional  = no
   horn           = yes
   equality       = yes
   symmetry       = no
   max literals   = 1
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
 
** start input processing.

 
** USABLE _______________________________
 
  7:[] ~(#c-1.Nat + 0 = #c-1.Nat)
 
 process usable:
* kept in usable : weight=5
  7:[] ~(#c-1.Nat + 0 = #c-1.Nat)
 
** SOS __________________________________
 
  8:[] Univ326 = Univ326
  1:[] _v3:Nat + s _v4:Nat = s (_v3 + _v4)
  2:[] _v6:Nat + 0 = _v6
  3:[] 0 + _v8:Nat = _v8
  4:[] 0 * _v10:Nat = 0
  5:[] _v12:Nat * 0 = 0
  6:[] _v16:Nat * s _v15:Nat = (_v16 * _v15) + _v16
 
 process sos:
* kept in sos : weight=3
  8:[] _v18 = _v18
* kept in sos : weight=9
  1:[] _v21:Nat + s _v22:Nat = s (_v21 + _v22)
* kept in sos : weight=5
  2:[] _v24:Nat + 0 = _v24
 
** UNIT CONFLICT_________________________
 
  13:[binary:2,7] 
 
** PROOF ________________________________
 
  2:[] _v24:Nat + 0 = _v24
  7:[] ~(#c-1.Nat + 0 = #c-1.Nat)
  13:[binary:2,7] 
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........0  |
|  clauses kept             .........4  |
|  clauses forward subsumed .........0  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.010 sec)
yes
\end{verbatim}
}
  上の結果を見て分かる通り, 正しく MONOID の公理が
  TIMES-NAT に写像されて, 検査が実行されている．
  2つの公理のいずれもの証明に成功し,
  最終結果が `yes' となった．これは予想通りである.

\item 自動生成した射による場合\\
第\ref{sec:ref-check-ok-data}節の第2項で述べられているように,
  ファイル ``ref-check-ok-2.mod'' をシステムにロードした.
  結果は次の通りである.
{\small
\begin{verbatim}
CafeOBJ> in ref-check-ok-2
processing input : ./ref-check-ok-2.mod
**> 
**> 仕様詳細化検査の試験 - 2
**> 自動生成された射による場合．
**> 
**> もとになる仕様：CONTAINER
**> 一般的な「入れ物」を定義したモジュール
**> 
-- defining module* CONTAINER_*_*......._.*
** system already proved =*= is a congruence of CONTAINER done.
**> 
**> CELL : CONTAINER と同じく一般的な入れ物
**> 
-- defining module* CELL_*_*......._.*
** system already proved =*= is a congruence of CELL done.
**> 
**> STACK : 先入れ先だし方式の入れ物
**> 
-- defining module* STACK_*_*........_...*
** system failed to prove =*= is a congruence of STACK done.
**> 
**> LIST : リスト構造
**> 
-- defining module* LIST_*_*........_...*
** system failed to prove =*= is a congruence of LIST done.
**> それぞれのモジュールについて，CONTAINER との sigmatch を
**> 実行して，射を自動生成する．
--> sigmatch (CONTAINER) to (CELL)
--> 
(V#1)
--> sigmatch (CONTAINER) to (STACK)
--> 
(V#2)
--> sigmatch (CONTAINER) to (LIST)
--> 
(V#3)
\end{verbatim}
}
  この結果, それぞれ自動生成された射(V\#1, V\#2, および V\#3)が得られた
  ので, それぞれについて check refinement コマンドを実行した．
  その際, 検査仕様で述べられている通り, 公理が正しく写像されていることと
  証明の様子を見るために, 最初にフラグ debug-refine を on として実行を
  行った．結果は以下の通りである.
{\small
\begin{verbatim}
CafeOBJ> flag(debug-refine,on)

-- setting flag "debug-refine" to "on"
CafeOBJ> check refinement V#1
** starting refinement check with view V#1_*
-- check axiom : 
   eq get(put(E:Elt,C:Cell)) = E:Elt_
   dependent: flag(auto, on)
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
   dependent: flag(universal-symmetry, on)
[Properties of input clauses]:
   propositional  = no
   horn           = yes
   equality       = yes
   symmetry       = no
   max literals   = 1
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
 
** start input processing.

 
** USABLE _______________________________
 
  2:[] ~(get(put(#c-1.Elt,#c-1.Cell)) = #c-1.Elt)
 
 process usable:
* kept in usable : weight=6
  2:[] ~(get(put(#c-1.Elt,#c-1.Cell)) = #c-1.Elt)
 
** SOS __________________________________
 
  3:[] Univ328 = Univ328
  1:[] get(put(_v4:Elt,_v3:Cell)) = _v4
 
 process sos:
* kept in sos : weight=3
  3:[] _v6 = _v6
* kept in sos : weight=6
  1:[] get(put(_v10:Elt,_v9:Cell)) = _v10
 
** UNIT CONFLICT_________________________
 
  7:[binary:1,2] 
 
** PROOF ________________________________
 
  1:[] get(put(_v10:Elt,_v9:Cell)) = _v10
  2:[] ~(get(put(#c-1.Elt,#c-1.Cell)) = #c-1.Elt)
  7:[binary:1,2] 
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........0  |
|  clauses kept             .........3  |
|  clauses forward subsumed .........0  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.000 sec)
yes
CafeOBJ> check refinement V#2
** starting refinement check with view V#2_*
-- check axiom : 
   eq top(push(E:Elt,C:Stack)) = E:Elt_
   dependent: flag(auto, on)
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
   dependent: flag(universal-symmetry, on)
[Properties of input clauses]:
   propositional  = no
   horn           = yes
   equality       = yes
   symmetry       = no
   max literals   = 1
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
 
** start input processing.

 
** USABLE _______________________________
 
  4:[] ~(top(push(#c-1.Elt,#c-1.Stack)) = #c-1.Elt)
 
 process usable:
* kept in usable : weight=6
  4:[] ~(top(push(#c-1.Elt,#c-1.Stack)) = #c-1.Elt)
 
** SOS __________________________________
 
  5:[] Univ330 = Univ330
  1:[] pop(empty) = empty
  2:[] top(push(_v4:Elt,_v3:Stack)) = _v4
  3:[] pop(push(_v7:Elt,_v8:Stack)) = _v8
 
 process sos:
* kept in sos : weight=3
  5:[] _v10 = _v10
* kept in sos : weight=4
  1:[] pop(empty) = empty
* kept in sos : weight=6
  2:[] top(push(_v14:Elt,_v13:Stack)) = _v14
 
** UNIT CONFLICT_________________________
 
  10:[binary:2,4] 
 
** PROOF ________________________________
 
  2:[] top(push(_v14:Elt,_v13:Stack)) = _v14
  4:[] ~(top(push(#c-1.Elt,#c-1.Stack)) = #c-1.Elt)
  10:[binary:2,4] 
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........0  |
|  clauses kept             .........4  |
|  clauses forward subsumed .........0  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.010 sec)
yes
CafeOBJ> check refinement V#3
** starting refinement check with view V#3_*
-- check axiom : 
   eq car(cons(E:Elt,C:List)) = E:Elt_
   dependent: flag(auto, on)
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
   dependent: flag(universal-symmetry, on)
[Properties of input clauses]:
   propositional  = no
   horn           = yes
   equality       = yes
   symmetry       = no
   max literals   = 1
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
 
** start input processing.

 
** USABLE _______________________________
 
  4:[] ~(car(cons(#c-1.Elt,#c-1.List)) = #c-1.Elt)
 
 process usable:
* kept in usable : weight=6
  4:[] ~(car(cons(#c-1.Elt,#c-1.List)) = #c-1.Elt)
 
** SOS __________________________________
 
  5:[] Univ332 = Univ332
  1:[] car(cons(_v4:Elt,_v3:List)) = _v4
  2:[] cdr(nil) = nil
  3:[] cdr(cons(_v7:Elt,_v8:List)) = _v8
 
 process sos:
* kept in sos : weight=3
  5:[] _v10 = _v10
* kept in sos : weight=6
  1:[] car(cons(_v14:Elt,_v13:List)) = _v14
 
** UNIT CONFLICT_________________________
 
  9:[binary:1,4] 
 
** PROOF ________________________________
 
  1:[] car(cons(_v14:Elt,_v13:List)) = _v14
  4:[] ~(car(cons(#c-1.Elt,#c-1.List)) = #c-1.Elt)
  9:[binary:1,4] 
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........0  |
|  clauses kept             .........3  |
|  clauses forward subsumed .........0  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.000 sec)
yes
CafeOBJ> 
\end{verbatim}
}
  この結果から明らかなように, いずれのケースの場合も, 全ての CONTAINER 
  の公理が, 検査対象とするモジュールへ正しく写像され, 成立する事が
  証明されている. これは予想通りの結果である.
\end{enumerate}

%%
\subsection{詳細化でない場合}
\label{sec:non-refine-case}
\subsubsection{検査内容}

\begin{enumerate}
\item 仕様(モジュール)間の射が詳細化とはならないようなケースを
  用意し, この射を check refinement コマンドの引数として与える.
  結果として, `no' が返り, かつ満足されなかった等式の一覧が
  表示されなければならない. 
\item 手動で作成した射の場合, および sigmatch コマンドによる
  自動生成の射の両方について検査を行う.
\item いずれの場合においても, 証明の様子をみるため
  フラグ debug-refine を on とし, 詳細なログを取る事.
\end{enumerate}

具体的なテストデータと, その手順については次節を参照されたい.

\subsubsection{テストデータと手順}
\label{sec:non-refine-data}

\begin{enumerate}
\item 手動で構成した射を用いたケース.
  \begin{enumerate}
  \item 下に示すようなモジュール定義と射の定義を, ファイル
    ``non-refine-1.mod'' に書き込んでおく.
    また, 同時に check refinement 起動コマンドを含む
    スクリプトも書き込んでおく.
    ここで示されているモジュールは, 第\ref{sec:ref-check-ok-data}節
    の, 手動定義の射による検査のものと同じである. ただし, 射の定義
    が異なっている. 一般に詳細化となっていない場合(証明ができない
    場合)のログは非常に長大となるので, 反駁エンジンの出力する
    given clause の印字は抑制している. ただし, 結果の統計情報等は
    出力されるので, 検査のためのデータとしては十分である.
{\small
\begin{verbatim}
**>
**> 詳細化検証機能
**> view が詳細化とならない場合-1
**> 手動で view を定義する．

**> 自然数上のかけ算と足し算の定義されたモジュール TIMES-NAT
mod! TIMES-NAT {
  [ NzNat Zero < Nat ]

  op 0 : -> Zero
  op s_ : Nat -> NzNat
  op _+_ : Nat Nat -> Nat
  op _*_ : Nat Nat -> Nat

  vars M N : Nat 
    
  eq N + s(M) = s(N + M) .
  eq N + 0 = N . 
  eq 0 + N = N .
  eq 0 * N = 0 .
  eq N * 0 = 0 .
  eq N * s(M) = (N * M) + N .
}

**> モノイド
mod* MON {
  [ Elt ]

  op null :  ->  Elt
  op _;_ : Elt Elt -> Elt {assoc idr: null} 
}

**> view の定義
--> モノイドの2項演算をかけ算に
--> 単位元を 1(s(0)) に写像する．
**>
view times from MON to TIMES-NAT {
  sort Elt -> Nat, 
  op _;_ -> _*_,  
  op null -> s(0)
}

**> TIME-NAT で定義されている自然数上のかけ算は，
**> 単位元を 1 としたモノイドを構成するかどうかを見る．
**> つまり, 仕様射 times は，TIMES-NAT が,
**> MON の詳細化を定義するものであるかを調べる．

--> 詳細な情報が欲しいのでフラグを設定する
--> flag(debug-refine,on)
flag(debug-refine,on)
--> ただし，長大なログは望ましくないので，given clause
--> の印字は抑制する
flag(print-given,off)

--> check コマンドの起動
--> check refinement times
check refinement times
\end{verbatim}
}
  \item 上で示したファイルをシステムにロードし, 結果を見る.
  \item このケースの場合, MONOID の公理
    \begin{verbatim}
    eq null ; ID:Elt = ID .
    \end{verbatim}
    の形の公理の証明に失敗するはずである. 
    TIMES-NAT のかけ算(\verb:_*_:)の公理には, これを証明できない.
    これを証明するには TIMES-NAT において
    \begin{verbatim}
    eq s(N) * M:Nat = N + (N * M) .
    \end{verbatim}
    のような形をした等式が必要である.
    従って, 結果は 'no' であり, さらに上記の等式が証明に失敗した
    ものとして表示されなければならない.
  \end{enumerate}
\item sigmatch による自動生成の射を用いたケース.
  \begin{enumerate}
  \item 下に示す内容のモジュール定義, および sigmatch コマンドの
    起動スクリプトを, ファイル ``non-refine-2.mod'' に書き込んでおく.

    {\small
\begin{verbatim}
**>
**> 仕様詳細化検査：詳細化となっていない場合
**> sigmatch による自動構成射による検査：
**>

**>
**> CONTAINER : ベースとする仕様
**> 一般的な「入れ物」を定義したモジュール
**>
mod* CONTAINER(X :: TRIV) 
{
  *[ Container ]*

  op empty : -> Container
  bop store : Elt Container -> Container
  bop val : Container -> Elt

  var E : Elt
  var C : Container

  eq val(store(E,C)) = E .
}

**>
**> Buufer 構造
**>
mod* BUF(X :: TRIV)
{
  *[ Buf ]*
  op init :  -> Buf 
  bop in : Elt Buf -> Buf
  bop val : Buf -> Elt
  bop out : Buf -> Buf
  bop empty? : Buf -> Bool
  var N : Elt   var B : Buf 
  eq empty?(init) = true .
  ceq empty?(out(B)) = true if not empty?(B) .
  eq empty?(in(N,B)) = false .
  ceq val(out(in(N,B))) = N if empty?(B) .
  bceq in(N,B) = B if not empty?(B) .
  bceq out(B) = B if empty?(B) .
}

**>
**> QUEUE 構造
**>
mod* QUEUE(X :: TRIV) 
{
  *[ Queue ]*
  op empty : -> Queue 
  bop front : Queue -> Elt
  bop enq : Elt Queue -> Queue
  bop deq : Queue -> Queue
  vars D E : Elt   var Q : Queue
  beq deq(enq(E,empty)) = empty .
  beq deq(enq(E,enq(D,Q))) = enq(E,deq(enq(D,Q))) .
  eq front(enq(E,empty)) = E .
  eq front(enq(E,enq(D,Q))) = front(enq(D,Q)) .
}

**> 各々のモジュールについて、CONTAINER からの
**> 射を生成する：

--> sigmatch (CONTAINER) to (BUF)
-->
sigmatch (CONTAINER) to (BUF)

--> sigmatch (CONTAINER) to (QUEUE)
-->
sigmatch (CONTAINER) to (QUEUE)
\end{verbatim}
      }
  \item このファイルをシステムにロードし, sigmatch コマンドの返す
    射の名前を得る.
  \item 上で得た各射を check refinement コマンドの引数として実行し,
    結果を見る.
  \item これらのいずれの場合も, 詳細化であることを示すことはできず,
    結果は 'no' となるはずである. 
    また, それぞれの場合について, 最初に見付けた証明に失敗した公理が
    印字されなければならない.
  \end{enumerate}
\end{enumerate}

\subsubsection{実行結果}

\begin{enumerate}
\item 手動で構成した射を用いたケース.
  \begin{enumerate}
  \item 第\ref{sec:non-refine-data}節の第1項で示されたファイル
    ``non-refine-1.mod'' をシステムにロードした.
  \item 結果のログは以下の通りである：
{\small
\begin{verbatim}
CafeOBJ> in non-refine-1
processing input : ./non-refine-1.mod
**> 
**> 詳細化検証機能
**> view が詳細化とならない場合-1
**> 手動で view を定義する．
**> 自然数上のかけ算と足し算の定義されたモジュール TIMES-NAT
-- defining module! TIMES-NAT
[Warning]: redefining module TIMES-NAT ......_......* done.
**> モノイド
-- defining module* MON
[Warning]: redefining module MON .._._* done.
**> view の定義
--> モノイドの2項演算をかけ算に
--> 単位元を 1(s(0)) に写像する．
**> 
-- defining view times 
[Warning]: redefining view times 
[Warning]: operator mapping is not strict wrt sort map:
    * sort map
    - Elt --> Nat
    * operator map
    - source: null : -> Elt
    - target: s_ : Nat -> NzNat done.
**> TIME-NAT で定義されている自然数上のかけ算は，
**> 単位元を 1 としたモノイドを構成するかどうかを見る．
**> つまり, 仕様射 times は，TIMES-NAT が,
**> MON の詳細化を定義するものであるかを調べる．
--> 詳細な情報が欲しいのでフラグを設定する
--> flag(debug-refine,on)
-- setting flag "debug-refine" to "on"
--> ただし，長大なログは望ましくないので，given clause
--> の印字は抑制する
-- setting flag "print-given" to "off"
--> check コマンドの起動
--> check refinement times
** starting refinement check with view times_*
-- check axiom : 
   eq [ident14] : s 0 * X-ID:Nat = X-ID:Nat_
[Properties of input clauses]:
   propositional  = no
   horn           = yes
   equality       = yes
   symmetry       = no
   max literals   = 1
[selected strategy]:
 
** start input processing.

 
** USABLE _______________________________
 
  7:[] ~(s 0 * #c-1.Nat = #c-1.Nat)
 
 process usable:
* kept in usable : weight=6
  7:[] ~(s 0 * #c-1.Nat = #c-1.Nat)
 
** SOS __________________________________
 
  8:[] Univ321 = Univ321
  1:[] _v3:Nat + s _v4:Nat = s (_v3 + _v4)
  2:[] _v6:Nat + 0 = _v6
  3:[] 0 + _v8:Nat = _v8
  4:[] 0 * _v10:Nat = 0
  5:[] _v12:Nat * 0 = 0
  6:[] _v16:Nat * s _v15:Nat = (_v16 * _v15) + _v16
 
 process sos:
* kept in sos : weight=3
  8:[] _v18 = _v18
* kept in sos : weight=9
  1:[] _v21:Nat + s _v22:Nat = s (_v21 + _v22)
* kept in sos : weight=5
  2:[] _v24:Nat + 0 = _v24
* kept in sos : weight=5
  3:[] 0 + _v26:Nat = _v26
* kept in sos : weight=5
  4:[] 0 * _v28:Nat = 0
* kept in sos : weight=5
  5:[] _v30:Nat * 0 = 0
* kept in sos : weight=10
  6:[flip] (_v34:Nat * _v33:Nat) + _v34 = _v34 * s _v33
-- following clause subsumed by 8 during input processing:
  17:[copy:8,flip] _v36 = _v36
* starting back demodulation with 1.
* starting back demodulation with 2.
* starting back demodulation with 3.
* starting back demodulation with 4.
* starting back demodulation with 5.
* starting back demodulation with 6.
 
** DEMODULATORS _________________________
 
  (1) _v21:Nat + s _v22:Nat --> s (_v21:Nat + _v22:Nat)
  (2) _v24:Nat + 0 --> _v24:Nat
  (3) 0 + _v26:Nat --> _v26:Nat
  (4) 0 * _v28:Nat --> 0
  (5) _v30:Nat * 0 --> 0
  (6) (_v34:Nat * _v33:Nat) + _v34 --> _v34:Nat * s _v33:Nat
 

** end process input.

 
** Starting PigNose _____________________
 
-- resetting weight limit to 499
   sos size = 0
** Search stopped because SOS is empty.
 
** PigNose statistics ------------------+
|  clauses given            .......173  |
|  clauses generated        .......838  |
|  clauses kept             .......174  |
|  clauses forward subsumed .......604  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 25.510 sec)_*
-- check axiom : 
   eq [ident15] : Y-ID:Nat * s 0 = Y-ID:Nat_
[Properties of input clauses]:
   propositional  = no
   horn           = yes
   equality       = yes
   symmetry       = no
   max literals   = 1
[selected strategy]:
 
** start input processing.

 
** USABLE _______________________________
 
  7:[] ~(#c-1.Nat * s 0 = #c-1.Nat)
 
 process usable:
* kept in usable : weight=6
  7:[] ~(#c-1.Nat * s 0 = #c-1.Nat)
 
** SOS __________________________________
 
  8:[] Univ323 = Univ323
  1:[] _v3:Nat + s _v4:Nat = s (_v3 + _v4)
  2:[] _v6:Nat + 0 = _v6
  3:[] 0 + _v8:Nat = _v8
  4:[] 0 * _v10:Nat = 0
  5:[] _v12:Nat * 0 = 0
  6:[] _v16:Nat * s _v15:Nat = (_v16 * _v15) + _v16
 
 process sos:
* kept in sos : weight=3
  8:[] _v18 = _v18
* kept in sos : weight=9
  1:[] _v21:Nat + s _v22:Nat = s (_v21 + _v22)
* kept in sos : weight=5
  2:[] _v24:Nat + 0 = _v24
* kept in sos : weight=5
  3:[] 0 + _v26:Nat = _v26
* kept in sos : weight=5
  4:[] 0 * _v28:Nat = 0
* kept in sos : weight=5
  5:[] _v30:Nat * 0 = 0
* kept in sos : weight=10
  6:[flip] (_v34:Nat * _v33:Nat) + _v34 = _v34 * s _v33
-- following clause subsumed by 8 during input processing:
  17:[copy:8,flip] _v36 = _v36
* starting back demodulation with 1.
* starting back demodulation with 2.
* starting back demodulation with 3.
* starting back demodulation with 4.
* starting back demodulation with 5.
* starting back demodulation with 6.
 
** DEMODULATORS _________________________
 
  (1) _v21:Nat + s _v22:Nat --> s (_v21:Nat + _v22:Nat)
  (2) _v24:Nat + 0 --> _v24:Nat
  (3) 0 + _v26:Nat --> _v26:Nat
  (4) 0 * _v28:Nat --> 0
  (5) _v30:Nat * 0 --> 0
  (6) (_v34:Nat * _v33:Nat) + _v34 --> _v34:Nat * s _v33:Nat
 

** end process input.

 
** Starting PigNose _____________________
 

 
** UNIT CONFLICT_________________________
 
  25:[binary:24,7] 
 
** PROOF ________________________________
 
  3:[] 0 + _v26:Nat = _v26
  5:[] _v30:Nat * 0 = 0
  6:[flip] (_v34:Nat * _v33:Nat) + _v34 = _v34 * s _v33
  7:[] ~(#c-1.Nat * s 0 = #c-1.Nat)
  24:[para-into:6,5,demod:3,flip] 
    _v39:Nat * s 0 = _v39
  25:[binary:24,7] 
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........7  |
|  clauses generated        .........7  |
|  clauses kept             .........9  |
|  clauses forward subsumed .........7  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.030 sec)
no
  eq [ident14] : null ; X-ID:Elt = X-ID:Elt
\end{verbatim}
}
  \item 結果を見ると, 詳細化検査の結論は `no' であり, MONOID の等式
\begin{verbatim}
    eq [ident14] : null ; X-ID:Elt = X-ID:Elt
\end{verbatim}
    の証明に失敗している事が分かる. これは予想通りの結果である.
  \end{enumerate}
  
\item 自動生成の射を用いたケース.
  \begin{enumerate}
  \item 第\ref{sec:non-refine-data}節の第2項で示されたファイル 
    ``no-refine-2.mod''
    をシステムにロードし, 自動生成された射の名前を得た.
    実行ログを以下に示す：
{\small
\begin{verbatim}
\end{verbatim}
}
  \item 得られた各射について, check refinement コマンドを起動した.
    この際, システムの実行の様子を見るために, フラグ debug-refine
    を on に設定し, また膨大なログを避けるために, フラグ
    print-given を off に設定している.
    
    まず最初に CONTAINER から BUF への射 \verb:V#1: についての
    実行ログは下の通りである.
    {\small
\begin{verbatim}
CafeOBJ> option reset
CafeOBJ> flag(debug-refine,on)

-- setting flag "debug-refine" to "on"
CafeOBJ> flag(print-given,off)

-- setting flag "print-given" to "off"
CafeOBJ> check refinement V#1
** starting refinement check with view V#1_*
-- check axiom : 
   eq val(in(E:Elt,C:Buf)) = E:Elt_
[Properties of input clauses]:
   propositional  = no
   horn           = no
   equality       = yes
   symmetry       = no
   max literals   = 2
[selected strategy]:
 
** start input processing.

 
** USABLE _______________________________
 
  7:[] ~(val(in(#c-1.Elt,#c-1.Buf)) = #c-1.Elt)
  3:[] ~(empty?(in(_v5:Elt,_v6:Buf)))
  4:[] ~(empty?(_v9:Buf)) | val(out(in(_v10:Elt,_v9:Buf))) = 
                            _v10
  6:[] ~(empty?(_v16:Buf)) | out(_v16:Buf) = _v16
 
 process usable:
* kept in usable : weight=6
  7:[] ~(val(in(#c-1.Elt,#c-1.Buf)) = #c-1.Elt)
* kept in usable : weight=4
  3:[] ~(empty?(in(_v19:Elt,_v20:Buf)))
* kept in usable : weight=9
  4:[] ~(empty?(_v23:Buf)) | val(out(in(_v24:Elt,_v23:Buf))) 
                             = _v24
* kept in usable : weight=6
  6:[] ~(empty?(_v26:Buf)) | out(_v26:Buf) = _v26
 
** SOS __________________________________
 
  8:[] Univ333 = Univ333
  1:[] empty?(init)
  2:[] empty?(_v2:Buf) | empty?(out(_v2:Buf))
  5:[] empty?(_v14:Buf) | in(_v13:Elt,_v14:Buf) = _v14
 
 process sos:
* kept in sos : weight=3
  8:[] _v28 = _v28
* kept in sos : weight=2
  1:[] empty?(init)
* kept in sos : weight=5
  2:[] empty?(_v30:Buf) | empty?(out(_v30:Buf))
* kept in sos : weight=7
  5:[] empty?(_v34:Buf) | in(_v33:Elt,_v34:Buf) = _v34
-- following clause subsumed by 8 during input processing:
  17:[copy:8,flip] _v36 = _v36
 

** end process input.

 
** Starting PigNose _____________________
 
-- resetting weight limit to 21
   sos size = 98
-- resetting weight limit to 18
   sos size = 76
** Search stopped because SOS is empty.
 
** PigNose statistics ------------------+
|  clauses given            .......218  |
|  clauses generated        ...332,217  |
|  clauses kept             .......260  |
|  clauses forward subsumed ....18,952  |
|  clauses back subsumed    ........68  |
+---------------------------------------+
(total run time 880.440 sec)
no
  eq val(store(E,C)) = E

\end{verbatim}
      }
    
    次に, CONTAINER から QUEUE への射 \verb:V#2: についての
    実行ログは下の通りである.
    {\small
\begin{verbatim}
CafeOBJ> option reset
CafeOBJ> flag(debug-refine,on)

-- setting flag "debug-refine" to "on"
CafeOBJ> flag(print-given,off)

-- setting flag "print-given" to "off"
CafeOBJ> check refinement V#2
** starting refinement check with view V#2_*
-- check axiom : 
   eq front(enq(E:Elt,C:Queue)) = E:Elt_
[Properties of input clauses]:
   propositional  = no
   horn           = yes
   equality       = yes
   symmetry       = no
   max literals   = 1
[selected strategy]:
 
** start input processing.

 
** USABLE _______________________________
 
  5:[] ~(front(enq(#c-1.Elt,#c-1.Queue)) = #c-1.Elt)
 
 process usable:
* kept in usable : weight=6
  5:[] ~(front(enq(#c-1.Elt,#c-1.Queue)) = #c-1.Elt)
 
** SOS __________________________________
 
  6:[] Univ335 = Univ335
  1:[] deq(enq(_v2:Elt,empty)) = empty
  2:[] deq(enq(_v6:Elt,enq(_v7:Elt,_v8:Queue))) = enq(_v6,deq(enq(_v7,
                                                                  _v8)))
  3:[] front(enq(_v10:Elt,empty)) = _v10
  4:[] front(enq(_v14:Elt,enq(_v15:Elt,_v16:Queue))) = front(enq(_v15,
                                                                 _v16))
 
 process sos:
* kept in sos : weight=3
  6:[] _v18 = _v18
* kept in sos : weight=6
  1:[] deq(enq(_v20:Elt,empty)) = empty
* kept in sos : weight=13
  2:[] deq(enq(_v24:Elt,enq(_v25:Elt,_v26:Queue))) = enq(_v24,
                                                         deq(enq(_v25,
                                                                 _v26)))
* kept in sos : weight=6
  3:[] front(enq(_v28:Elt,empty)) = _v28
* kept in sos : weight=11
  4:[] front(enq(_v32:Elt,enq(_v33:Elt,_v34:Queue))) = front(enq(_v33,
                                                                 _v34))
-- following clause subsumed by 6 during input processing:
  13:[copy:6,flip] _v36 = _v36
* starting back demodulation with 1.
* starting back demodulation with 2.
* starting back demodulation with 3.
* starting back demodulation with 4.
 
** DEMODULATORS _________________________
 
  (1) deq(enq(_v20:Elt,empty)) --> empty
  (2) deq(enq(_v24:Elt,enq(_v25:Elt,_v26:Queue))) 
      --> enq(_v24:Elt, deq(enq(_v25:Elt,_v26:Queue)))
  (3) front(enq(_v28:Elt,empty)) --> _v28:Elt
  (4) front(enq(_v32:Elt,enq(_v33:Elt,_v34:Queue))) 
      --> front(enq(_v33:Elt, _v34:Queue))
 

** end process input.

 
** Starting PigNose _____________________
 

** Search stopped because SOS is empty.
 
** PigNose statistics ------------------+
|  clauses given            .........5  |
|  clauses generated        .........0  |
|  clauses kept             .........6  |
|  clauses forward subsumed .........1  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.030 sec)
no
  eq val(store(E,C)) = E
\end{verbatim}
      }
  \item 上記いずれの場合も, 予想通り `no' という結果となり,
    証明のできなかった公理が表示されている.
  \end{enumerate}
\end{enumerate}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
