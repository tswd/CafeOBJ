\part{モデル検査システム検査仕様・結果}
\label{sec:model-check}

モデル検査システムは, 表\ref{tab:system-functions}の
機能第4項(抽象モデル検査アルゴリズム)と, 
機能第6項(安全/活性等の各性質のためのモデル検査機能)
に対応するサブシステムである.
これらの機能は具体的には, 以下のように実現されている：
\begin{description}
\item[抽象モデル検査アルゴリズム]
  モデル検査機能を実現する, モデル検査コマンド
  check invariant によって実装されている.
\item[安全/活性等の各性質のためのモデル検査機能]
  同じく, check invariant コマンドによって実現されている.
  システムの持つさまざまな性質は, 状態遷移によって
  保証されるある性質(invariance)を記述することで
  可能である. モデル検査システムでは, (多ソート)一階述語
  論理文を用い, 隠れソートに関する述語によって, システム
  状態を記述する. その上で, 保証したい性質を, 同じく
  論理式で表現し, あり得るシステム状態の遷移によって,
  この性質が保存されるかどうかを, 反駁エンジンを用いて
  検査するものである.

  この検査は, check invariant コマンドに組み込まれた,
  モデル検査アルゴリズムを用いて実行される.
\end{description}

上記の事から, システムの検査はこの check invariance コマンドが
正しく動作するものかどうかを検査する事によって行う.
従って, 検査対象とする機能は, 「モデル検査機能」として
一つにまとめる事とする. 
モデル検査では, 反駁システムの能力をフルに使用する事となり,
従って, モデル検査機能の試験は, 反駁システムに対する総合的な
試験として見る事ができる.


\section{モデル検査機能}
\label{sec:model-check-func}

\subsection{検査項目}

モデル検査の基本機能は, システムの初期状態と, 検査すべき性質が
与えられた時に, 初期状態から遷移可能な全ての状態に付いて,.
与えられた性質が満足されるかどうかを検査することである.
この場合, 結果として3通りが考えられ, これを大きく検査項目
として採用する:
\begin{enumerate}
\item 正常終了の場合：\\
  モデル検査が正常に終了する場合であり, システムが与えられた性質を
  満たす事が保証される場合.
  
\item 反例発見終了の場合： \\
  システムの実行系列の中に, 与えられた性質が成立しないような
  反例が存在する事が証明される. モデル検査システムは, その
  初期状態からの実行系列と反駁証明から, 反例として結果を示す.

\item 不定終了の場合： \\
  モデル検査は一般に決定不能であるので, 事前に定められた計算資源の
  し容量を超過した場合には, モデル検査システムは結果不定のまま
  終了する. この場合でも, 探索が終了した実行系列に付いての情報を
  提示する.
\end{enumerate}

したがって, 検査は想定される上の3つのケースが正しく得られる事を
テストデータを用意して実行することで行うものであり,
上記の3項の結果が全て正しく得られるかどうかを検査する.

\subsection{検査結果一覧}

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}[h]{|l|c|c|}\hline
      検査項目 & 結果 & 該当章番号 \\\hline
      正常終了の場合 & ○ & \ref{sec:model-normal-end} \\
      反例発見終了の場合 & ○ & \ref{sec:model-counter-end} \\
      不定終了の場合 & ○ & \ref{sec:model-unknown-end} \\\hline
    \end{tabular}
    \caption{モデル検査機能結果一覧}
    \label{tab:normal-end-res}
  \end{center}
\end{table}


\subsection{正常終了の場合}
\label{sec:model-normal-end}

\subsubsection{検査内容}
\begin{enumerate}
\item 隠れソートを用いた仕様を用意し, 
  満足される事の分かっている性質を述語論理の文で
  表現する.
\item 上記の性質がシステムの状態変化によらず, 常に
  保証されることをモデル検査機能を用いて確かめる.
  
  この時以下の点についても動作の確認を行う.
  \begin{enumerate}
  \item 全ての可能な遷移を網羅的に調べていること.\\
    これは抽象モデル検査アルゴリズムが正しく実現されて
    いることを見るためである.
  \item 1ステップの遷移で収束しない場合に, 遷移ステップを
    進め, fix point で収束するまで網羅的な検査を進めている
    こと. \\ これも抽象モデル検査アルゴリズムが正しく実現
    されていることを見るためである.
  \item システムがどの状態に対して, どのような検査を実行しているか
    等の情報を適切に表示すること.
  \item 一般に抽象モデル検査は非常に難しい部類の問題であり,
    反駁システムの auto モードによる推論では, 力が不足する場合が
    多々ある. 従って, 反駁システムの動作を制御するフラグや,
    パラメータを独自に設定してモデル検査を実行できなければ
    ならない. これらオプションの設定が可能となっている事を
    確かめる.
  \end{enumerate}
\end{enumerate}

具体的なテストデータと実行手順に付いては, 次節を参照されたい.

\subsubsection{テストデータと手順}
\label{sec:model-normal-end-data}
\begin{enumerate}
\item ケース-1: 
  \begin{enumerate}
  \item 下に示すモジュール宣言ならびに, モデル検査のための
    スクリプトを, ファイル ``model-normal-1.mod'' に書き込んでおく.
{\small
\begin{verbatim}
**>
**> モデル検査正常終了のケース-1
**> 

set include FOPL-CLAUSE on

**> 整数：
mod! INT*
{
  [ Int ]
  op 0 : -> Int
  op _+_ : Int Int -> Int
  op _-_ : Int Int -> Int
  pred _<=_ : Int Int

  vars M N : Int
  ax M <= M .
  ax 0 <= M & 0 <= N -> 0 <= M + N .
  ax M <= N -> 0 <= N - M .
}

**> 口座の仕様
mod* ACCOUNT
{
  protecting(INT*)
  *[ Account ]*
  -- 初期状態
  op new-account : -> Account
  -- 残高照合
  bop balance : Account -> Int
  -- 預け入れ
  bop deposit : Int Account -> Account
  -- 引き出し
  bop withdraw : Int Account -> Account

  var A : Account    
  vars M N : Int

  eq balance(new-account) = 0 .
  ax 0 <= N -> balance(deposit(N,A)) = balance(A) + N .
  ax ~(0 <= N) -> balance(deposit(N,A)) = balance(A) .
  ax N <= balance(A) -> balance(withdraw(N,A)) = balance(A) - N .
  ax ~(N <= balance(A)) -> balance(withdraw(N,A)) = balance(A) .

}

**> ACCOUNT に関するモデル検査のためのモジュール
**> 保証したい性質は, 述語 P で表現.

mod* PROOF
{
  protecting(ACCOUNT)

  pred P : Account .
  #define P(A:Account) ::= 0 <= balance(A) .
}

**> 反駁エンジンオプションの設定
--> auto モードで行う.
option reset
flag(auto,on)

**> PROOF モジュールのオープン
open PROOF

**> モデル検査の実行
--> 述語 P は, 残高(balance) が正であることを述べたもの.
--> これが常に保証されることを検査する.
--> check safety P from new-account
check safety P from new-account
**
close
\end{verbatim}  
}
  \item 上の ``model-normal-1.mod'' をシステムに読み込み,
    実行ログを調べる. このとき以下の事項が確認されなければならない：
    \begin{itemize}
    \item 1ステップの遷移を調べる事によって, 検査が完了している事.
    \item 結果が正常終了となっていること.
    \item 推論は, 指定した通り反駁システムの自動モード(auto)で
      実行されている事.
    \item 対象とするシステム状態, および, そこで証明対象とする
      文が, その都度表示されている事.
    \item 証明対象とした文の推論結果が, その都度表示されている事.
    \item 最終的な検査結果が正しく表示されている事.
    \end{itemize}
  \end{enumerate}

\item ケース-2:
  \begin{enumerate}
  \item 下に示すモジュール定義とモデル検査のためのスクリプトを
    ファイル ``model-normal-2.mod'' に書き込んでおく.
{\small
\begin{verbatim}
**>
**> モデル検査正常終了のケース-2
**> 

**> 自然数
mod! NATNUM
{
  protecting(FOPL-CLAUSE)
  [ NatNum ]
  op 0 : -> NatNum
  op s : NatNum -> NatNum
  pred _<_ : NatNum NatNum
  vars M N : NatNum
  ax ~(s(M) < M) .
  ax ~(s(M) = 0) .
  ax [SOS]: M < s(M) .
  ax [SOS]: 0 < s(M) .
  ax ~(s(M) = M) .
  ax [SOS]: M = 0 | 0 < M .
  ax ~(0 < M)| ~(M = 0) . 
  ax ~(M = N & M < N) .
  ax ~(M < N & N < M) .
  ax ~(M < 0) .
  ax M = M .
}

**> モジュール STATUS
**> システムの取り得る状態の表現
mod! STATUS
{
  protecting(FOPL-CLAUSE)
  [ Status ]
  -- non-CS : クリティカルセクションにいない
  -- wait   : 待ち
  -- CS     : クリティカルセクション外
  -- error  : エラー状態
  ops non-CS wait CS error : -> Status
  var S : Status
  ax (S = S) = true .
}

**> CUSTOMER1
**> お客-1
mod* CUSTOMER1
{
  protecting(NATNUM + STATUS)
  *[ Customer1 ]*
  op init1 : -> Customer1
  -- attributes
  bop ticket1 : Customer1 -> NatNum
  bop stat1 : Customer1 -> Status
  -- methods
  bop run1 : Customer1 NatNum -> Customer1
  vars C C1 : Customer1  vars M N : NatNum
  -- 初期状態は non-CS
  eq stat1(init1) = non-CS .
  -- 初期のチケットは 0
  eq ticket1(init1) = 0 .
  -- non-CS 状態なら, 列に並んで wait 状態になる
  ax stat1(C) = non-CS -> stat1(run1(C,M))= wait .
  -- 列に並んだ wait 状態ならば以前は non-CS であった.
  ax stat1(run1(C,M))= wait -> stat1(C) = non-CS .
  -- non-CS 状態なら, 列に並ぶとチケットが1増える
  ax stat1(C) = non-CS -> ticket1(run1(C,M)) = s(M) .
  ax stat1(C) = wait & (M = 0 | ~(M < ticket1(C))) 
     -> stat1(run1(C,M)) = CS .
  ax stat1(run1(C,M)) = CS -> stat1(C) = wait .
  ax stat1(C) = wait & ~(M = 0) & M < ticket1(C) 
     -> stat1(run1(C,M)) = error .
  ax stat1(run1(C,M)) = error -> stat1(C) = wait .
  ax stat1(C) = wait -> ticket1(run1(C,M)) = ticket1(C) .
  ax (stat1(C) = CS) = (stat1(run1(C,M)) = non-CS) .
  ax stat1(C) = CS -> ticket1(run1(C,M)) = 0 .
}

**> CUSTOMER2
**> お客2 
mod* CUSTOMER2
{
  protecting(NATNUM + STATUS)
  *[ Customer2 ]*
  op init2 : -> Customer2
  -- attributes
  bop ticket2 : Customer2 -> NatNum
  bop stat2 : Customer2 -> Status
  -- methods
  bop run2 : Customer2 NatNum -> Customer2
  vars C C1 : Customer2  var M : NatNum
  eq stat2(init2) = non-CS .
  eq ticket2(init2) = 0 .
  ax stat2(C) = non-CS -> stat2(run2(C,M))= wait .
  ax stat2(run2(C,M))= wait -> stat2(C) = non-CS .
  ax stat2(C) = non-CS -> ticket2(run2(C,M)) = s(M) .
  ax stat2(C) = wait & (M = 0 | ticket2(C) < M) 
     -> stat2(run2(C,M)) = CS .
  ax stat2(run2(C,M)) = CS -> stat2(C) = wait .
  ax stat2(C) = wait & ~(M = 0) & ~(ticket2(C) < M) 
     -> stat2(run2(C,M)) = error .
  ax stat2(run2(C,M)) = error -> stat2(C) = wait .
  ax stat2(C) = wait -> ticket2(run2(C,M)) = ticket2(C) .
  ax (stat2(C) = CS) = (stat2(run2(C,M)) = non-CS) .
  ax stat2(C) = CS -> ticket2(run2(C,M)) = 0 .
}

**> SHOP : お店
**> bakery algorithm
**>
mod* SHOP
{
  protecting(CUSTOMER1 + CUSTOMER2)
  *[ Shop ]*
  op shop : Customer1 Customer2 -> Shop { coherent }
  bop Run1 : Shop -> Shop
  bop Run2 : Shop -> Shop
  bop Stat1 : Shop -> Status
  bop Stat2 : Shop -> Status
  bop Ticket1 : Shop -> NatNum
  bop Ticket2 : Shop -> NatNum
  op Init : -> Shop
  vars C1 D1 : Customer1   vars C2 D2 : Customer2
  var S : Shop   var B : Bool
  ax B = B .
  eq Init = shop(init1,init2) .
  beq Run1(shop(C1,C2)) = shop(run1(C1,ticket2(C2)),C2) .
  beq Run2(shop(C1,C2)) = shop(C1,run2(C2,ticket1(C1))) .
  eq Stat1(shop(C1,C2)) = stat1(C1) .
  eq Stat2(shop(C1,C2)) = stat2(C2) .
  eq Ticket1(shop(C1,C2)) = ticket1(C1) .
  eq Ticket2(shop(C1,C2)) = ticket2(C2) .
}

**> 証明のためのモジュール PROOF
mod* PROOF
{
  protecting(SHOP)

  op c1 : -> Customer1 .
  op c2 : -> Customer2 .
  -- P は, 客-1 と客-2 が, 同時にクリティカルセクションの
  -- 状態に入る事は無い, つまりデッドロックするようなことは
  -- ない, ということを表現したもの.
  pred P : Shop .
  #define P(S:Shop) ::= ~(Stat1(S) = CS & Stat2(S) = CS) .

}

**> 反駁エンジンのオプションを設定する：
option reset
flag(process-input, on)
flag(control-memory, on)
flag(kb2, on)
flag(back-unit-deletion, on)
flag(hyper-res, on)
flag(unit-deletion, on)
flag(factor, on)
flag(universal-symmetry,off)
flag(dist-const,on)
flag(input-sos-first,on)
--> 長大なログを抑制する.
flag(quiet,on)
--> しかし統計情報や証明は印字する
flag(print-stats,on)
flag(print-proofs, on)
param(max-sos, 500)
param(pick-given-ratio, 4)
param(stats-level, 1)
param(max-proofs,1)
param(max-given,51)
param(max-seconds,1)

**> 証明対象モジュールの OPEN
open PROOF

**> 反駁エンジン初期化
db reset

**> sos の設定
sos = { SOS }

**> モデル検査コマンドの起動
--> check inv P of shop(c1,c2) from Init
check inv P of shop(c1,c2) from Init

close
\end{verbatim}
}
  \item 上で示したファイル ``model-normal-2.mod'' をシステムに
    ロードし, 結果のログを見る. この時, 以下の項目が満足され
    なければならない：
    \begin{itemize}
    \item 1ステップの遷移では証明できず, 
      多段ステップの検査となっている事(4段).
    \item 推論は, 指定した通りのフラグパラメータで実行されている事.
    \item 対象とするシステム状態, および, そこで証明対象とする
      文が, その都度表示されている事.
    \item 証明対象とした文の推論結果が, その都度表示されている事.
    \item その時点での証明対象の証明ができなかった場合に,
      同じ文脈で初期状態に関する検査が行われている事.
      この例の場合は, 初期状態からの遷移が安全であるという結果に
      ならねばならず, 反例は発見されてはならない.
    \item 最終的な検査結果が正しく表示されている事.
    \end{itemize}
  \end{enumerate}
\end{enumerate}

\subsubsection{実行結果}
\begin{enumerate}
\item ケース-1:
  \begin{enumerate}
  \item 第\ref{sec:model-normal-end-data}節の第1項で示された
    ファイル ``model-normal-1.mod'' をシステムにロードした.
    結果のログは下の通りである.
{\small
\begin{verbatim}
CafeOBJ> in model-normal-1
processing input : ./model-normal-1.mod
**> 
**> モデル検査正常終了のケース-1
**> 
**> 整数：
-- defining module! INT*......_...* done.
**> 口座の仕様
-- defining module* ACCOUNT........_.....*
** system failed to prove =*= is a congruence of ACCOUNT done.
**> ACCOUNT に関するモデル検査のためのモジュール
**> 保証したい性質は, 述語 P で表現.
-- defining module* PROOF.._._* done.
**> 反駁エンジンオプションの設定
--> auto モードで行う.
-- setting flag "auto" to "on"
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
**> PROOF モジュールのオープン
-- opening module PROOF.. done.
**> モデル検査の実行
--> 述語 P は, 残高(balance) が正であることを述べたもの.
--> これが常に保証されることを検査する.
--> check safety P from new-account
==========
case #0-1: new-account
----------_
goal: P(new-account)*
[Properties of input clauses]:
   propositional  = no
   horn           = no
   equality       = yes
   symmetry       = no
   max literals   = 3
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
   dependent: flag(hyper-res, on)
   dependent: flag(unit-deletion, on)
   dependent: flag(factor, on)
 
** start input processing.

 
** USABLE _______________________________
 
  1:[] ~(0 <= balance(new-account))
  3:[] ~(0 <= _v4:Int) | balance(deposit(_v4:Int,
                                         _v3:Account)) 
                         = balance(_v3) 
                           + _v4
  5:[] ~(_v12:Int <= balance(_v11:Account)) | 
       balance(withdraw(_v12:Int,_v11:Account)) 
       = balance(_v11) - _v12
  8:[] ~(0 <= _v21:Int) | ~(0 <= _v22:Int) | 
       0 <= (_v21:Int + _v22:Int)
  9:[] ~(_v26:Int <= _v25:Int) | 0 <= (_v25:Int 
                                       - 
                                       _v26:Int)
 
 process usable:
* kept in usable : weight=4
  1:[] ~(0 <= balance(new-account))
* kept in usable : weight=12
  3:[] ~(0 <= _v30:Int) | balance(deposit(_v30:Int,
                                          _v29:Account)) 
                          = balance(_v29) 
                            + _v30
* kept in usable : weight=13
  5:[] ~(_v34:Int <= balance(_v33:Account)) | 
       balance(withdraw(_v34:Int,_v33:Account)) 
       = balance(_v33) - _v34
* kept in usable : weight=11
  8:[] ~(0 <= _v37:Int) | ~(0 <= _v38:Int) | 
       0 <= (_v37:Int + _v38:Int)
* kept in usable : weight=8
  9:[] ~(_v45:Int <= _v44:Int) | 0 <= (_v44:Int 
                                       - 
                                       _v45:Int)
 
** SOS __________________________________
 
  2:[] balance(new-account) = 0
  4:[] 0 <= _v7:Int | balance(deposit(_v7:Int,
                                      _v8:Account)) 
                      = balance(_v8)
  6:[] _v15:Int <= balance(_v16:Account) | 
       balance(withdraw(_v15:Int,_v16:Account)) 
       = balance(_v16)
  7:[] _v18:Int <= _v18
 
 process sos:
* kept in sos : weight=4
  2:[] balance(new-account) = 0
* kept in sos : weight=10
  4:[] 0 <= _v52:Int | balance(deposit(_v52:Int,
                                       _v53:Account)) 
                       = balance(_v53)
* kept in sos : weight=11
  6:[] _v56:Int <= balance(_v57:Account) | 
       balance(withdraw(_v56:Int,_v57:Account)) 
       = balance(_v57)
* kept in sos : weight=3
  7:[] _v59:Int <= _v59
* starting back demodulation with 2.
* back demodulating 1 with 2
* kept in sos : weight=3
  21:[back-demod:2,1] 
    ~(0 <= 0)
 
** UNIT CONFLICT_________________________
 
  22:[binary:21,7] 
 
** PROOF ________________________________
 
  1:[back-demod:2] ~(0 <= 0)
  2:[] balance(new-account) = 0
  7:[] _v59:Int <= _v59
  21:[back-demod:2,1] 
    ~(0 <= 0)
  22:[binary:21,7] 
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........11  |
|  clauses forward subsumed .........0  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.100 sec)
** success
==========
case #1-1: deposit(_V327:Int,_hole319:Account)
----------
hypo: \A [ _V325:Int ] (\A [ _hole319:Account 
                        ] P(withdraw(_V325,
                                     _hole319)))_
goal: \A [ _V327:Int ] (\A [ _hole319:Account 
                        ] P(_hole319) -> 
                          P(deposit(_V327,
                                    _hole319)))*_*
[Properties of input clauses]:
   propositional  = no
   horn           = no
   equality       = yes
   symmetry       = no
   max literals   = 3
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
   dependent: flag(hyper-res, on)
   dependent: flag(unit-deletion, on)
   dependent: flag(factor, on)
 
** start input processing.

 
** USABLE _______________________________
 
  2:[] ~(0 <= balance(deposit(#c-1.Int,#c-1.Account)))
  5:[] ~(0 <= _v8:Int) | balance(deposit(_v8:Int,
                                         _v7:Account)) 
                         = balance(_v7) 
                           + _v8
  7:[] ~(_v16:Int <= balance(_v15:Account)) | 
       balance(withdraw(_v16:Int,_v15:Account)) 
       = balance(_v15) - _v16
  10:[] ~(0 <= _v25:Int) | ~(0 <= _v26:Int) | 
        0 <= (_v25:Int + _v26:Int)
  11:[] ~(_v30:Int <= _v29:Int) | 0 <= (_v29:Int 
                                        - 
                                        _v30:Int)
 
 process usable:
* kept in usable : weight=6
  2:[] ~(0 <= balance(deposit(#c-1.Int,#c-1.Account)))
* kept in usable : weight=12
  5:[] ~(0 <= _v34:Int) | balance(deposit(_v34:Int,
                                          _v33:Account)) 
                          = balance(_v33) 
                            + _v34
* kept in usable : weight=13
  7:[] ~(_v38:Int <= balance(_v37:Account)) | 
       balance(withdraw(_v38:Int,_v37:Account)) 
       = balance(_v37) - _v38
* kept in usable : weight=11
  10:[] ~(0 <= _v41:Int) | ~(0 <= _v42:Int) | 
        0 <= (_v41:Int + _v42:Int)
* kept in usable : weight=8
  11:[] ~(_v49:Int <= _v48:Int) | 0 <= (_v48:Int 
                                        - 
                                        _v49:Int)
 
** SOS __________________________________
 
  1:[] 0 <= balance(#c-1.Account)
  3:[] 0 <= balance(withdraw(_v3:Int,_v4:Account))
  4:[] balance(new-account) = 0
  6:[] 0 <= _v11:Int | balance(deposit(_v11:Int,
                                       _v12:Account)) 
                       = balance(_v12)
  8:[] _v19:Int <= balance(_v20:Account) | 
       balance(withdraw(_v19:Int,_v20:Account)) 
       = balance(_v20)
  9:[] _v22:Int <= _v22
 
 process sos:
* kept in sos : weight=4
  1:[] 0 <= balance(#c-1.Account)
* kept in sos : weight=6
  3:[] 0 <= balance(withdraw(_v56:Int,_v57:Account))
* kept in sos : weight=4
  4:[] balance(new-account) = 0
* kept in sos : weight=10
  6:[] 0 <= _v60:Int | balance(deposit(_v60:Int,
                                       _v61:Account)) 
                       = balance(_v61)
* kept in sos : weight=11
  8:[] _v64:Int <= balance(_v65:Account) | 
       balance(withdraw(_v64:Int,_v65:Account)) 
       = balance(_v65)
* kept in sos : weight=3
  9:[] _v67:Int <= _v67
* starting back demodulation with 4.
 
** DEMODULATORS _________________________
 
  (4) balance(new-account) --> 0
 

** end process input.

 
** Starting PigNose _____________________
 
#1(weight=4):
  1:[] 0 <= balance(#c-1.Account)
#2(weight=3):
  9:[] _v67:Int <= _v67
#3(weight=4):
  4:[] balance(new-account) = 0
#4(weight=5):
  31:[hyper:9,18] 0 <= (0 + 0)
#5(weight=5):
  32:[hyper:9,11] 0 <= (_v69:Int - _v69)
#6(weight=6):
  3:[] 0 <= balance(withdraw(_v56:Int,_v57:Account))
#7(weight=6):
  26:[hyper:1,11] 0 <= (balance(#c-1.Account) 
                        - 0)
#8(weight=6):
  35:[hyper:9,10,1] 0 <= (balance(#c-1.Account) 
                          + 0)
#9(weight=6):
  38:[hyper:9,10,1] 0 <= (0 + balance(#c-1.Account))
#10(weight=7):
  25:[hyper:1,18] 0 <= (balance(#c-1.Account) 
                        + balance(#c-1.Account))
#11(weight=10):
  6:[] 0 <= _v60:Int | balance(deposit(_v60:Int,
                                       _v61:Account)) 
                       = balance(_v61)
#12(weight=3):
  154:[para-from:6,2,unit-del:1] 
    0 <= #c-1.Int
 
** UNIT CONFLICT_________________________
 
  183:[binary:182,170] 
    
 
** PROOF ________________________________
 
  1:[] 0 <= balance(#c-1.Account)
  2:[back-demod:181] 
    ~(0 <= (balance(#c-1.Account) + #c-1.Int))
  5:[] ~(0 <= _v34:Int) | balance(deposit(_v34:Int,
                                          _v33:Account)) 
                          = balance(_v33) 
                            + _v34
  6:[] 0 <= _v60:Int | balance(deposit(_v60:Int,
                                       _v61:Account)) 
                       = balance(_v61)
  10:[] ~(0 <= _v41:Int) | ~(0 <= _v42:Int) | 
        0 <= (_v41:Int + _v42:Int)
  154:[para-from:6,2,unit-del:1] 
    0 <= #c-1.Int
  170:[hyper:154,10,1] 
    0 <= (balance(#c-1.Account) + #c-1.Int)
  181:[hyper:154,5] balance(deposit(#c-1.Int,
                                    _v178:Account)) 
                    = balance(_v178) + #c-1.Int
  182:[back-demod:181,2] 
    ~(0 <= (balance(#c-1.Account) + #c-1.Int))
  183:[binary:182,170] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........12  |
|  clauses generated        .......150  |
|  clauses kept             .......141  |
|  clauses forward subsumed ........19  |
|  clauses back subsumed    .........2  |
+---------------------------------------+
(total run time 0.340 sec)
** success
==========
case #1-2: withdraw(_V325:Int,_hole319:Account)
----------_
goal: \A [ _V325:Int ] (\A [ _hole319:Account 
                        ] P(_hole319) -> 
                          P(withdraw(_V325,
                                     _hole319)))*_*
[Properties of input clauses]:
   propositional  = no
   horn           = no
   equality       = yes
   symmetry       = no
   max literals   = 3
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
   dependent: flag(hyper-res, on)
   dependent: flag(unit-deletion, on)
   dependent: flag(factor, on)
 
** start input processing.

 
** USABLE _______________________________
 
  2:[] ~(0 <= balance(withdraw(#c-1.Int,
                               #c-1.Account)))
  4:[] ~(0 <= _v4:Int) | balance(deposit(_v4:Int,
                                         _v3:Account)) 
                         = balance(_v3) 
                           + _v4
  6:[] ~(_v12:Int <= balance(_v11:Account)) | 
       balance(withdraw(_v12:Int,_v11:Account)) 
       = balance(_v11) - _v12
  9:[] ~(0 <= _v21:Int) | ~(0 <= _v22:Int) | 
       0 <= (_v21:Int + _v22:Int)
  10:[] ~(_v26:Int <= _v25:Int) | 0 <= (_v25:Int 
                                        - 
                                        _v26:Int)
 
 process usable:
* kept in usable : weight=6
  2:[] ~(0 <= balance(withdraw(#c-1.Int,
                               #c-1.Account)))
* kept in usable : weight=12
  4:[] ~(0 <= _v30:Int) | balance(deposit(_v30:Int,
                                          _v29:Account)) 
                          = balance(_v29) 
                            + _v30
* kept in usable : weight=13
  6:[] ~(_v34:Int <= balance(_v33:Account)) | 
       balance(withdraw(_v34:Int,_v33:Account)) 
       = balance(_v33) - _v34
* kept in usable : weight=11
  9:[] ~(0 <= _v37:Int) | ~(0 <= _v38:Int) | 
       0 <= (_v37:Int + _v38:Int)
* kept in usable : weight=8
  10:[] ~(_v45:Int <= _v44:Int) | 0 <= (_v44:Int 
                                        - 
                                        _v45:Int)
 
** SOS __________________________________
 
  1:[] 0 <= balance(#c-1.Account)
  3:[] balance(new-account) = 0
  5:[] 0 <= _v7:Int | balance(deposit(_v7:Int,
                                      _v8:Account)) 
                      = balance(_v8)
  7:[] _v15:Int <= balance(_v16:Account) | 
       balance(withdraw(_v15:Int,_v16:Account)) 
       = balance(_v16)
  8:[] _v18:Int <= _v18
 
 process sos:
* kept in sos : weight=4
  1:[] 0 <= balance(#c-1.Account)
* kept in sos : weight=4
  3:[] balance(new-account) = 0
* kept in sos : weight=10
  5:[] 0 <= _v52:Int | balance(deposit(_v52:Int,
                                       _v53:Account)) 
                       = balance(_v53)
* kept in sos : weight=11
  7:[] _v56:Int <= balance(_v57:Account) | 
       balance(withdraw(_v56:Int,_v57:Account)) 
       = balance(_v57)
* kept in sos : weight=3
  8:[] _v59:Int <= _v59
* starting back demodulation with 3.
 
** DEMODULATORS _________________________
 
  (3) balance(new-account) --> 0
 

** end process input.

 
** Starting PigNose _____________________
 
#1(weight=4):
  1:[] 0 <= balance(#c-1.Account)
#2(weight=3):
  8:[] _v59:Int <= _v59
#3(weight=4):
  3:[] balance(new-account) = 0
#4(weight=5):
  29:[hyper:8,17] 0 <= (0 + 0)
#5(weight=5):
  30:[hyper:8,10] 0 <= (_v61:Int - _v61)
#6(weight=10):
  5:[] 0 <= _v52:Int | balance(deposit(_v52:Int,
                                       _v53:Account)) 
                       = balance(_v53)
#7(weight=6):
  24:[hyper:1,10] 0 <= (balance(#c-1.Account) 
                        - 0)
#8(weight=6):
  33:[hyper:8,9,1] 0 <= (balance(#c-1.Account) 
                         + 0)
#9(weight=6):
  36:[hyper:8,9,1] 0 <= (0 + balance(#c-1.Account))
#10(weight=7):
  23:[hyper:1,17] 0 <= (balance(#c-1.Account) 
                        + balance(#c-1.Account))
#11(weight=11):
  7:[] _v56:Int <= balance(_v57:Account) | 
       balance(withdraw(_v56:Int,_v57:Account)) 
       = balance(_v57)
#12(weight=4):
  142:[para-from:7,2,unit-del:1] 
    #c-1.Int <= balance(#c-1.Account)
 
** UNIT CONFLICT_________________________
 
  152:[binary:151,149] 
    
 
** PROOF ________________________________
 
  1:[] 0 <= balance(#c-1.Account)
  2:[back-demod:150] 
    ~(0 <= (balance(#c-1.Account) - #c-1.Int))
  6:[] ~(_v34:Int <= balance(_v33:Account)) | 
       balance(withdraw(_v34:Int,_v33:Account)) 
       = balance(_v33) - _v34
  7:[] _v56:Int <= balance(_v57:Account) | 
       balance(withdraw(_v56:Int,_v57:Account)) 
       = balance(_v57)
  10:[] ~(_v45:Int <= _v44:Int) | 0 <= (_v44:Int 
                                        - 
                                        _v45:Int)
  142:[para-from:7,2,unit-del:1] 
    #c-1.Int <= balance(#c-1.Account)
  149:[hyper:142,10] 
    0 <= (balance(#c-1.Account) - #c-1.Int)
  150:[hyper:142,6] balance(withdraw(#c-1.Int,
                                     #c-1.Account)) 
                    = balance(#c-1.Account) 
                      - #c-1.Int
  151:[back-demod:150,2] 
    ~(0 <= (balance(#c-1.Account) - #c-1.Int))
  152:[binary:151,149] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........12  |
|  clauses generated        .......117  |
|  clauses kept             .......108  |
|  clauses forward subsumed ........16  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.250 sec)
** success
** Predicate P is safe!!
 
(grand total time 1.671 sec)
\end{verbatim}
}
  \item 結果は検査仕様で示された予想通りとなった：
    \begin{itemize}
    \item ケースが\verb:#1-2: で終っており, 
      1 ステップの遷移の検査で終了している. 
      これは予想通りである.
    \item 全てのケースで, 成功(\verb:success: と表示)に終っており,
      全体として検査が正常に終了した旨が表示されている.
    \item 反駁システムの出力から, 指定通りに auto モードで推論が
      行われている事が分かる. 
    \item 各ステップの検査対象, 結果が適切に表示されている.
    \item また, 推論結果についても, 統計情報と併せて, 証明木の
      表示がある.
    \item 前述のように, 最終結果は「成功」に終っている.
    \end{itemize}
  \end{enumerate}
\item ケース-2:
  \begin{enumerate}
  \item 第\ref{sec:model-normal-end-data}節の第2項で示された
    ファイル ``model-normal-2.mod'' をシステムにロードした.
    結果のログは下の通りである.
    {\small
\begin{verbatim}
CafeOBJ> in model-normal-2
processing input : ./model-normal-2.mod
**> 
**> モデル検査正常終了のケース-2
**> 
**> 自然数
-- defining module! NATNUM......_...........* done.
**> モジュール STATUS
**> システムの取り得る状態の表現
-- defining module! STATUS......._.* done.
**> CUSTOMER1
**> お客-1
-- defining module* CUSTOMER1_*........_............*
** system failed to prove =*= is a congruence of CUSTOMER1 done.
**> CUSTOMER2
**> お客2 
-- defining module* CUSTOMER2_*........_............*
** system failed to prove =*= is a congruence of CUSTOMER2 done.
**> SHOP : お店
**> bakery algorithm
**> 
-- defining module* SHOP_*.............._........*
** system failed to prove =*= is a congruence of SHOP done.
**> 証明のためのモジュール PROOF
-- defining module* PROOF...._._* done.
**> 反駁エンジンのオプションを設定する：
-- setting flag "process-input" to "on"
-- setting flag "control-memory" to "on"
-- setting flag "kb2" to "on"
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
-- setting flag "back-unit-deletion" to "on"
   dependent: flag(unit-deletion, on)
-- setting flag "hyper-res" to "on"
-- setting flag "unit-deletion" to "on"
-- setting flag "factor" to "on"
-- setting flag "universal-symmetry" to "off"
-- setting flag "dist-const" to "on"
-- setting flag "input-sos-first" to "on"
--> 長大なログを抑制する.
-- setting flag "quiet" to "on"
   dependent: flag(print-message, off)
--> しかし統計情報や証明は印字する
**> 証明対象モジュールの OPEN
-- opening module PROOF.. done.
**> 反駁エンジン初期化
**> sos の設定
**> モデル検査コマンドの起動
--> check inv P of shop(c1,c2) from Init
==========
case #0-1: shop(c1,c2)
----------_
goal: P(shop(c1,c2))*
** Search stopped because SOS is empty.
 
** PigNose statistics ------------------+
|  clauses given            ........17  |
|  clauses generated        .......119  |
|  clauses kept             ........61  |
|  clauses forward subsumed ........22  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.110 sec)
** fail
** check with the initial state : Init_
goal: P(Init)*
 
** PROOF ________________________________
 
  2:[] Init = shop(init1,init2)
  5:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
       = stat1(_v152)
  34:[] stat1(init1) = non-CS
  47:[demod:2,5,34,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........44  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.030 sec)
** ok, it's safe.
adding axiom: P(shop(c1,c2))
==========
case #1-1: Run1(shop(c1,c2))
----------
hypo: P(Run2(shop(c1,c2)))_
goal: P(Run1(shop(c1,c2)))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......684  |
|  clauses kept             .......108  |
|  clauses forward subsumed .......137  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.330 sec)
** fail
** check with the initial state : Run1(Init)_
goal: P(Run1(Init))*
 
** PROOF ________________________________
 
  4:[] Init = shop(init1,init2)
  5:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
       = shop(run1(_v143,ticket2(_v144)),
              _v144)
  8:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
       = stat2(_v156)
  11:[] stat2(init2) = non-CS
  12:[] ticket2(init2) = 0
  50:[demod:4,5,12,8,11,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........49  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.030 sec)
** ok, it's safe.
==========
case #1-2: Run2(shop(c1,c2))
----------
hypo: P(Run1(shop(c1,c2)))_
goal: P(Run2(shop(c1,c2)))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......725  |
|  clauses kept             .......111  |
|  clauses forward subsumed .......153  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.310 sec)
** fail
** check with the initial state : Run2(Init)_
goal: P(Run2(Init))*
 
** PROOF ________________________________
 
  4:[] Init = shop(init1,init2)
  6:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
       = shop(_v148,run2(_v147,ticket1(_v148)))
  7:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
       = stat1(_v152)
  36:[] stat1(init1) = non-CS
  37:[] ticket1(init1) = 0
  49:[demod:4,6,37,7,36,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........48  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.040 sec)
** ok, it's safe.
adding axiom: P(Run2(shop(c1,c2)))
adding axiom: P(Run1(shop(c1,c2)))
==========
case #2-1: Run1(Run1(shop(c1,c2)))
----------
hypo: P(Run1(Run2(shop(c1,c2))))
hypo: P(Run2(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))_
goal: P(Run1(Run1(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......808  |
|  clauses kept             .......139  |
|  clauses forward subsumed .......154  |
|  clauses back subsumed    .........5  |
+---------------------------------------+
(total run time 0.350 sec)
** fail
** check with the initial state : Run1(Run1(Init))_
goal: P(Run1(Run1(Init)))*
 
** PROOF ________________________________
 
  8:[] Init = shop(init1,init2)
  9:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
       = shop(run1(_v143,ticket2(_v144)),
              _v144)
  12:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  15:[] stat2(init2) = non-CS
  16:[] ticket2(init2) = 0
  54:[demod:8,9,16,12,15,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........57  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.060 sec)
** ok, it's safe.
==========
case #2-2: Run1(Run2(shop(c1,c2)))
----------
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run2(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))_
goal: P(Run1(Run2(shop(c1,c2))))*
 
** PROOF ________________________________
 
  5:[back-demod:9] ~(Stat1(Run2(shop(run1(c1,
                                          ticket2(c2)),
                                     c2))) 
                     = CS) | ~(Stat2(Run2(shop(run1(c1,
                                                    ticket2(c2)),
                                               c2))) 
                               = CS)
  9:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
       = shop(run1(_v143,ticket2(_v144)),
              _v144)
  10:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  11:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  12:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  22:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  25:[] ~(stat2(_v200:Customer2) = wait) | 
        ticket2(run2(_v200:Customer2,_v199:NatNum)) 
        = ticket2(_v200)
  28:[] (_v210:Status = _v210) = true
  47:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  50:[] ~(stat1(_v269:Customer1) = wait) | 
        ticket1(run1(_v269:Customer1,_v268:NatNum)) 
        = ticket1(_v269)
  53:[demod:10,9,11] 
    stat1(run1(c1,ticket2(run2(c2,ticket1(c1))))) 
    = CS
  54:[demod:10,9,12] 
    stat2(run2(c2,ticket1(c1))) = CS
  108:[back-demod:9,5,demod:10,11,12,back-demod:209] 
    ~(stat1(run1(c1,ticket2(c2))) = CS) | 
    ~(stat2(run2(c2,ticket1(c1))) = CS)
  121:[hyper:53,47] stat1(c1) = wait
  126:[para-into:53,25,back-demod:154] 
    stat1(run1(c1,ticket2(c2))) = CS | ~(wait 
                                         = 
                                         wait)
  154:[hyper:54,22] stat2(c2) = wait
  158:[back-demod:154,126,demod:28] 
    stat1(run1(c1,ticket2(c2))) = CS
  209:[hyper:121,50] 
    ticket1(run1(c1,_v340:NatNum)) = ticket1(c1)
  216:[back-demod:209,108,demod:158,28,54] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........7  |
|  clauses generated        ........80  |
|  clauses kept             ........83  |
|  clauses forward subsumed ........16  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.110 sec)
** success
==========
case #2-3: Run2(Run1(shop(c1,c2)))
----------
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))_
goal: P(Run2(Run1(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......809  |
|  clauses kept             .......148  |
|  clauses forward subsumed .......170  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.350 sec)
** fail
** check with the initial state : Run2(Run1(Init))_
goal: P(Run2(Run1(Init)))*
 
** PROOF ________________________________
 
  7:[] Init = shop(init1,init2)
  8:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
       = shop(run1(_v143,ticket2(_v144)),
              _v144)
  9:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
       = shop(_v148,run2(_v147,ticket1(_v148)))
  10:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  15:[] ticket2(init2) = 0
  39:[] stat1(init1) = non-CS
  46:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  52:[demod:7,8,15,9,10] 
    stat1(run1(init1,0)) = CS
  117:[hyper:52,46,demod:39,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........1  |
|  clauses generated        .........3  |
|  clauses kept             ........60  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.050 sec)
** ok, it's safe.
==========
case #2-4: Run2(Run2(shop(c1,c2)))
----------
hypo: P(Run2(Run1(shop(c1,c2))))
hypo: P(Run1(Run1(shop(c1,c2))))_
goal: P(Run2(Run2(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......856  |
|  clauses kept             .......140  |
|  clauses forward subsumed .......175  |
|  clauses back subsumed    .........7  |
+---------------------------------------+
(total run time 0.390 sec)
** fail
** check with the initial state : Run2(Run2(Init))_
goal: P(Run2(Run2(Init)))*
 
** PROOF ________________________________
 
  7:[] Init = shop(init1,init2)
  9:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
       = shop(_v148,run2(_v147,ticket1(_v148)))
  10:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  39:[] stat1(init1) = non-CS
  40:[] ticket1(init1) = 0
  52:[demod:7,9,40,10,39,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........54  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.060 sec)
** ok, it's safe.
adding axiom: P(Run2(Run2(shop(c1,c2))))
adding axiom: P(Run2(Run1(shop(c1,c2))))
adding axiom: P(Run1(Run1(shop(c1,c2))))
==========
case #3-1: Run1(Run1(Run1(shop(c1,c2))))
----------
hypo: P(Run1(Run1(Run2(shop(c1,c2)))))
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))
hypo: P(Run2(Run1(Run2(shop(c1,c2)))))
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run1(Run1(Run1(shop(c1,c2)))))*
 
** PROOF ________________________________
 
  1:[back-demod:16] ~(stat1(c1) = CS) | 
                    ~(Stat2(shop(c1,c2)) 
                      = CS)
  14:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
        = shop(run1(_v143,ticket2(_v144)),
               _v144)
  16:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  17:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  33:[] (_v210:Status = _v210) = true
  48:[] ~(stat1(run1(_v241:Customer1,_v240:NatNum)) 
          = wait) | stat1(_v241:Customer1) 
                    = non-CS
  52:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  56:[flip] (stat1(run1(_v273:Customer1,
                        _v272:NatNum)) = 
             non-CS) = (stat1(_v273) = CS)
  58:[demod:14,16] stat1(run1(run1(run1(c1,
                                        ticket2(c2)),
                                   ticket2(c2)),
                              ticket2(c2))) 
                   = CS
  59:[demod:14,17] stat2(c2) = CS
  126:[back-demod:16,1,demod:17,back-demod:59] 
    ~(stat1(c1) = CS) | ~(CS = CS)
  136:[back-demod:59,126,demod:33] 
    ~(stat1(c1) = CS)
  138:[hyper:58,52] stat1(run1(run1(c1,ticket2(c2)),
                               ticket2(c2))) 
                    = wait
  268:[hyper:138,48,demod:56] 
    stat1(c1) = CS
  269:[binary:268,136] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........16  |
|  clauses generated        .......119  |
|  clauses kept             ........97  |
|  clauses forward subsumed ........20  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.150 sec)
** success
==========
case #3-2: Run1(Run1(Run2(shop(c1,c2))))
----------
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))
hypo: P(Run2(Run1(Run2(shop(c1,c2)))))
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run1(Run1(Run2(shop(c1,c2)))))*
 
** PROOF ________________________________
 
  7:[back-demod:13] ~(Stat1(Run2(shop(run1(run1(c1,
                                                ticket2(c2)),
                                           ticket2(c2)),
                                      c2))) 
                      = CS) | ~(Stat2(Run2(shop(run1(run1(c1,
                                                          ticket2(c2)),
                                                     ticket2(c2)),
                                                c2))) 
                                = CS)
  13:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
        = shop(run1(_v143,ticket2(_v144)),
               _v144)
  14:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  15:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  16:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  25:[] stat2(run2(_v183:Customer2,_v184:NatNum)) 
        = CS | ~(stat2(_v183:Customer2) 
                 = wait) | ~(ticket2(_v183:Customer2) 
                             < _v184:NatNum)
  26:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  29:[] ~(stat2(_v200:Customer2) = wait) | 
        ticket2(run2(_v200:Customer2,_v199:NatNum)) 
        = ticket2(_v200)
  32:[] (_v210:Status = _v210) = true
  35:[] _v287:NatNum < s(_v287)
  46:[] ~(stat1(_v237:Customer1) = non-CS) | 
        stat1(run1(_v237:Customer1,_v236:NatNum)) 
        = wait
  47:[] ~(stat1(run1(_v241:Customer1,_v240:NatNum)) 
          = wait) | stat1(_v241:Customer1) 
                    = non-CS
  48:[] ~(stat1(_v244:Customer1) = non-CS) | 
        ticket1(run1(_v244:Customer1,_v245:NatNum)) 
        = s(_v245)
  51:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  52:[] ~(stat1(_v261:Customer1) = wait) | 
        _v260:NatNum = 0 | ~(_v260:NatNum 
                             < ticket1(_v261:Customer1)) | 
        stat1(run1(_v261:Customer1,_v260:NatNum)) 
        = error
  54:[] ~(stat1(_v269:Customer1) = wait) | 
        ticket1(run1(_v269:Customer1,_v268:NatNum)) 
        = ticket1(_v269)
  57:[demod:14,13,15,back-demod:215] 
    stat1(run1(run1(c1,ticket2(c2)),ticket2(c2))) 
    = CS
  58:[demod:14,13,16] 
    stat2(run2(c2,ticket1(c1))) = CS
  117:[back-demod:13,7,demod:14,15,16,back-demod:299] 
    ~(stat1(run1(run1(c1,ticket2(c2)),ticket2(c2))) 
      = CS) | ~(stat2(run2(c2,ticket1(run1(c1,
                                           ticket2(c2))))) 
                = CS)
  133:[hyper:57,51,back-demod:215] 
    stat1(run1(c1,ticket2(c2))) = wait
  142:[para-into:57,52,demod:133,32,dconst:back-demod:215] 
    ticket2(c2) = 0 | ~(ticket2(c2) < ticket1(run1(c1,
                                                   ticket2(c2))))
  167:[hyper:58,26] stat2(c2) = wait
  215:[hyper:167,29] 
    ticket2(run2(c2,_v331:NatNum)) = ticket2(c2)
  222:[back-demod:215,57] 
    stat1(run1(run1(c1,ticket2(c2)),ticket2(c2))) 
    = CS
  224:[back-demod:215,133,back-demod:339] 
    wait = wait
  226:[back-demod:215,142,back-demod:338] 
    ticket2(c2) = 0 | ~(ticket2(c2) < s(ticket2(c2)))
  299:[hyper:224,54,back-demod:338] 
    ticket1(run1(run1(c1,ticket2(c2)),_v393:NatNum)) 
    = s(ticket2(c2))
  306:[hyper:224,47] 
    stat1(c1) = non-CS
  307:[back-demod:299,117,demod:222,32,back-demod:338] 
    ~(stat2(run2(c2,s(ticket2(c2)))) = CS)
  338:[hyper:306,48] 
    ticket1(run1(c1,_v410:NatNum)) = s(_v410)
  339:[hyper:306,46] 
    stat1(run1(c1,_v411:NatNum)) = wait
  342:[back-demod:338,226,unit-del:35] 
    ticket2(c2) = 0
  345:[back-demod:338,307,demod:342] 
    ~(stat2(run2(c2,s(0))) = CS)
  419:[para-into:345,25,demod:32,167,342] 
    ~(0 < s(0))
  420:[binary:419,35] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........18  |
|  clauses generated        .......247  |
|  clauses kept             .......136  |
|  clauses forward subsumed ........39  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.280 sec)
** success
==========
case #3-3: Run2(Run1(Run1(shop(c1,c2))))
----------
hypo: P(Run2(Run1(Run2(shop(c1,c2)))))
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run2(Run1(Run1(shop(c1,c2)))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......851  |
|  clauses kept             .......156  |
|  clauses forward subsumed .......163  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.410 sec)
** fail
** check with the initial state : Run2(Run1(Run1(Init)))_
goal: P(Run2(Run1(Run1(Init))))*
 
** PROOF ________________________________
 
  11:[] Init = shop(init1,init2)
  12:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
        = shop(run1(_v143,ticket2(_v144)),
               _v144)
  13:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  15:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  18:[] stat2(init2) = non-CS
  19:[] ticket2(init2) = 0
  25:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  57:[demod:11,12,19,13,15] 
    stat2(run2(init2,ticket1(run1(run1(init1,
                                       0),
                                  0)))) 
    = CS
  156:[hyper:57,25,demod:18,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........2  |
|  clauses generated        ........30  |
|  clauses kept             ........73  |
|  clauses forward subsumed .........5  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.080 sec)
** ok, it's safe.
==========
case #3-4: Run2(Run1(Run2(shop(c1,c2))))
----------
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run2(Run1(Run2(shop(c1,c2)))))*
 
** PROOF ________________________________
 
  8:[back-demod:12] ~(Stat1(Run2(Run2(shop(run1(c1,
                                                ticket2(c2)),
                                           c2)))) 
                      = CS) | ~(Stat2(Run2(Run2(shop(run1(c1,
                                                          ticket2(c2)),
                                                     c2)))) 
                                = CS)
  12:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
        = shop(run1(_v143,ticket2(_v144)),
               _v144)
  13:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  14:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  15:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  20:[] ~(stat2(_v168:Customer2) = non-CS) | 
        stat2(run2(_v168:Customer2,_v167:NatNum)) 
        = wait
  21:[] ~(stat2(run2(_v172:Customer2,_v171:NatNum)) 
          = wait) | stat2(_v172:Customer2) 
                    = non-CS
  22:[] ~(stat2(_v175:Customer2) = non-CS) | 
        ticket2(run2(_v175:Customer2,_v176:NatNum)) 
        = s(_v176)
  25:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  26:[] ~(stat2(_v192:Customer2) = wait) | 
        _v191:NatNum = 0 | ticket2(_v192:Customer2) 
                           < _v191:NatNum | 
        stat2(run2(_v192:Customer2,_v191:NatNum)) 
        = error
  31:[] (_v210:Status = _v210) = true
  32:[] ~(s(_v212:NatNum) < _v212)
  41:[] ~(_v231:NatNum < 0)
  49:[] stat1(run1(_v253:Customer1,_v252:NatNum)) 
        = CS | ~(stat1(_v253:Customer1) 
                 = wait) | _v252:NatNum 
                           < ticket1(_v253:Customer1)
  50:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  53:[] ~(stat1(_v269:Customer1) = wait) | 
        ticket1(run1(_v269:Customer1,_v268:NatNum)) 
        = ticket1(_v269)
  56:[demod:13,12,14,back-demod:338] 
    stat1(run1(c1,s(ticket1(c1)))) = CS
  57:[demod:13,12,15,back-demod:219] 
    stat2(run2(run2(c2,ticket1(c1)),ticket1(c1))) 
    = CS
  116:[back-demod:12,8,demod:13,14,15,back-demod:219] 
    ~(stat1(run1(c1,ticket2(c2))) = CS) | 
    ~(stat2(run2(run2(c2,ticket1(c1)),ticket1(c1))) 
      = CS)
  129:[hyper:56,50] stat1(c1) = wait
  163:[hyper:57,25,back-demod:339] 
    wait = wait
  168:[para-into:57,53,demod:129,31] 
    stat2(run2(run2(c2,ticket1(c1)),ticket1(c1))) 
    = CS
  171:[para-into:57,26,demod:163,31,dconst:back-demod:219] 
    ticket1(c1) = 0 | ticket2(run2(c2,ticket1(c1))) 
                      < ticket1(c1)
  219:[hyper:129,53] 
    ticket1(run1(c1,_v340:NatNum)) = ticket1(c1)
  227:[back-demod:219,116,demod:168,31] 
    ~(stat1(run1(c1,ticket2(c2))) = CS)
  234:[back-demod:219,171,back-demod:338] 
    ticket1(c1) = 0 | s(ticket1(c1)) < ticket1(c1)
  296:[hyper:163,21] 
    stat2(c2) = non-CS
  338:[hyper:296,22] 
    ticket2(run2(c2,_v421:NatNum)) = s(_v421)
  339:[hyper:296,20] 
    stat2(run2(c2,_v422:NatNum)) = wait
  346:[back-demod:338,234,unit-del:32] 
    ticket1(c1) = 0
  367:[para-from:346,49,demod:129,31,unit-del:41] 
    stat1(run1(c1,_v450:NatNum)) = CS
  368:[binary:367,227] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........13  |
|  clauses generated        .......196  |
|  clauses kept             .......128  |
|  clauses forward subsumed ........30  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.250 sec)
** success
==========
case #3-5: Run2(Run2(Run1(shop(c1,c2))))
----------
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run2(Run2(Run1(shop(c1,c2)))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......685  |
|  clauses kept             .......147  |
|  clauses forward subsumed .......126  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.340 sec)
** fail
** check with the initial state : Run2(Run2(Run1(Init)))_
goal: P(Run2(Run2(Run1(Init))))*
 
** PROOF ________________________________
 
  10:[] Init = shop(init1,init2)
  11:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
        = shop(run1(_v143,ticket2(_v144)),
               _v144)
  12:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  13:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  18:[] ticket2(init2) = 0
  42:[] stat1(init1) = non-CS
  49:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  55:[demod:10,11,18,12,13] 
    stat1(run1(init1,0)) = CS
  126:[hyper:55,49,demod:42,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........1  |
|  clauses generated        .........3  |
|  clauses kept             ........66  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.060 sec)
** ok, it's safe.
==========
case #3-6: Run2(Run2(Run2(shop(c1,c2))))
----------
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))_
goal: P(Run2(Run2(Run2(shop(c1,c2)))))*
 
** PROOF ________________________________
 
  1:[back-demod:13] ~(stat1(c1) = CS) | 
                    ~(Stat2(shop(c1,c2)) 
                      = CS)
  12:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  13:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  14:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  20:[] ~(stat2(run2(_v172:Customer2,_v171:NatNum)) 
          = wait) | stat2(_v172:Customer2) 
                    = non-CS
  24:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  28:[flip] (stat2(run2(_v204:Customer2,
                        _v203:NatNum)) = 
             non-CS) = (stat2(_v204) = CS)
  30:[] (_v210:Status = _v210) = true
  55:[demod:12,13] stat1(c1) = CS
  56:[demod:12,14] stat2(run2(run2(run2(c2,
                                        ticket1(c1)),
                                   ticket1(c1)),
                              ticket1(c1))) 
                   = CS
  117:[back-demod:13,1,demod:14,back-demod:55] 
    ~(CS = CS) | ~(stat2(c2) = CS)
  127:[back-demod:55,117,demod:30] 
    ~(stat2(c2) = CS)
  145:[hyper:56,24] stat2(run2(run2(c2,ticket1(c1)),
                               ticket1(c1))) 
                    = wait
  279:[hyper:145,20,demod:28] 
    stat2(c2) = CS
  280:[binary:279,127] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........18  |
|  clauses generated        .......142  |
|  clauses kept             ........94  |
|  clauses forward subsumed ........22  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.120 sec)
** success
adding axiom: P(Run2(Run2(Run1(shop(c1,c2)))))
adding axiom: P(Run2(Run1(Run1(shop(c1,c2)))))
==========
case #4-1: Run2(Run1(Run1(Run1(shop(c1,c2)))))
----------
hypo: P(Run2(Run1(Run1(Run2(shop(c1,c2))))))
hypo: P(Run2(Run2(Run1(Run1(shop(c1,c2))))))
hypo: P(Run2(Run2(Run1(Run2(shop(c1,c2))))))_
goal: P(Run2(Run1(Run1(Run1(shop(c1,c2))))))*
 
** PROOF ________________________________
 
  2:[back-demod:15] ~(Stat1(shop(c1,run2(c2,
                                         ticket1(c1)))) 
                      = CS) | ~(Stat2(shop(c1,
                                           run2(c2,
                                                ticket1(c1)))) 
                                = CS)
  14:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
        = shop(run1(_v143,ticket2(_v144)),
               _v144)
  15:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  16:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  17:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  25:[] stat2(run2(_v179:Customer2,_v180:NatNum)) 
        = CS | ~(stat2(_v179:Customer2) 
                 = wait) | ~(_v180:NatNum 
                             = 0)
  26:[] stat2(run2(_v183:Customer2,_v184:NatNum)) 
        = CS | ~(stat2(_v183:Customer2) 
                 = wait) | ~(ticket2(_v183:Customer2) 
                             < _v184:NatNum)
  27:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  33:[] (_v210:Status = _v210) = true
  36:[] _v287:NatNum < s(_v287)
  39:[] _v291:NatNum = 0 | 0 < _v291:NatNum
  48:[] ~(stat1(run1(_v241:Customer1,_v240:NatNum)) 
          = wait) | stat1(_v241:Customer1) 
                    = non-CS
  49:[] ~(stat1(_v244:Customer1) = non-CS) | 
        ticket1(run1(_v244:Customer1,_v245:NatNum)) 
        = s(_v245)
  52:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  53:[] ~(stat1(_v261:Customer1) = wait) | 
        _v260:NatNum = 0 | ~(_v260:NatNum 
                             < ticket1(_v261:Customer1)) | 
        stat1(run1(_v261:Customer1,_v260:NatNum)) 
        = error
  55:[] ~(stat1(_v269:Customer1) = wait) | 
        ticket1(run1(_v269:Customer1,_v268:NatNum)) 
        = ticket1(_v269)
  56:[flip] (stat1(run1(_v273:Customer1,
                        _v272:NatNum)) = 
             non-CS) = (stat1(_v273) = CS)
  58:[demod:14,15,16,back-demod:397] 
    stat1(run1(run1(run1(c1,0),0),0)) = 
    CS
  59:[demod:14,15,17,back-demod:283] 
    stat2(run2(c2,ticket1(run1(run1(c1,ticket2(c2)),
                               ticket2(c2))))) 
    = CS
  122:[back-demod:15,2,demod:16,17,back-demod:290] 
    ~(CS = CS) | ~(stat2(run2(c2,ticket1(c1))) 
                   = CS)
  135:[hyper:58,52,back-demod:397] 
    stat1(run1(run1(c1,0),0)) = wait
  140:[para-into:58,53,demod:135,33,dconst:back-demod:397] 
    0 = 0 | ~(0 < ticket1(run1(run1(c1,0),
                               0)))
  165:[hyper:59,27] stat2(c2) = wait
  283:[hyper:135,55,back-demod:397] 
    ticket1(run1(run1(run1(c1,0),0),_v382:NatNum)) 
    = ticket1(run1(run1(c1,0),0))
  290:[hyper:135,48,demod:56] 
    stat1(c1) = CS
  297:[back-demod:290,122,demod:33] 
    ~(stat2(run2(c2,ticket1(c1))) = CS)
  386:[para-into:297,26,demod:33,165,back-demod:397] 
    ~(0 < ticket1(c1))
  387:[para-into:297,25,demod:33,165] 
    ~(ticket1(c1) = 0)
  390:[hyper:387,39] 
    0 < ticket1(c1)
  397:[para-into:140,49,demod:56,290,33,unit-del:36] 
    ticket2(c2) = 0
  423:[back-demod:397,386] 
    ~(0 < ticket1(c1))
  424:[binary:423,390] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........21  |
|  clauses generated        .......235  |
|  clauses kept             .......146  |
|  clauses forward subsumed ........50  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.310 sec)
** success
==========
case #4-2: Run2(Run1(Run1(Run2(shop(c1,c2)))))
----------
hypo: P(Run2(Run2(Run1(Run1(shop(c1,c2))))))
hypo: P(Run2(Run2(Run1(Run2(shop(c1,c2))))))_
goal: P(Run2(Run1(Run1(Run2(shop(c1,c2))))))*
 
** PROOF ________________________________
 
  13:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
        = shop(run1(_v143,ticket2(_v144)),
               _v144)
  14:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  15:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  16:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  21:[] ~(stat2(_v168:Customer2) = non-CS) | 
        stat2(run2(_v168:Customer2,_v167:NatNum)) 
        = wait
  22:[] ~(stat2(run2(_v172:Customer2,_v171:NatNum)) 
          = wait) | stat2(_v172:Customer2) 
                    = non-CS
  23:[] ~(stat2(_v175:Customer2) = non-CS) | 
        ticket2(run2(_v175:Customer2,_v176:NatNum)) 
        = s(_v176)
  26:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  32:[] (_v210:Status = _v210) = true
  34:[] ~(s(_v214:NatNum) = 0)
  35:[] _v287:NatNum < s(_v287)
  47:[] ~(stat1(run1(_v241:Customer1,_v240:NatNum)) 
          = wait) | stat1(_v241:Customer1) 
                    = non-CS
  48:[] ~(stat1(_v244:Customer1) = non-CS) | 
        ticket1(run1(_v244:Customer1,_v245:NatNum)) 
        = s(_v245)
  51:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  52:[] ~(stat1(_v261:Customer1) = wait) | 
        _v260:NatNum = 0 | ~(_v260:NatNum 
                             < ticket1(_v261:Customer1)) | 
        stat1(run1(_v261:Customer1,_v260:NatNum)) 
        = error
  57:[demod:14,13,15,back-demod:285] 
    stat1(run1(run1(c1,s(ticket1(c1))),s(ticket1(c1)))) 
    = CS
  58:[demod:14,13,16,back-demod:285] 
    stat2(run2(run2(c2,ticket1(c1)),ticket1(run1(run1(c1,
                                                      s(ticket1(c1))),
                                                 s(ticket1(c1)))))) 
    = CS
  132:[hyper:57,51,back-demod:285] 
    stat1(run1(c1,s(ticket1(c1)))) = wait
  141:[para-into:57,52,demod:132,32,dconst:back-demod:285] 
    s(ticket1(c1)) = 0 | ~(s(ticket1(c1)) 
                           < ticket1(run1(c1,
                                          s(ticket1(c1)))))
  166:[hyper:58,26,back-demod:286] 
    wait = wait
  238:[hyper:166,22] 
    stat2(c2) = non-CS
  285:[hyper:238,23] 
    ticket2(run2(c2,_v373:NatNum)) = s(_v373)
  286:[hyper:238,21] 
    stat2(run2(c2,_v374:NatNum)) = wait
  290:[back-demod:285,132] 
    stat1(run1(c1,s(ticket1(c1)))) = wait
  292:[back-demod:285,141,unit-del:34,back-demod:449] 
    ~(s(ticket1(c1)) < s(s(ticket1(c1))))
  409:[hyper:290,47] 
    stat1(c1) = non-CS
  449:[hyper:409,48] 
    ticket1(run1(c1,_v541:NatNum)) = s(_v541)
  452:[back-demod:449,292] 
    ~(s(ticket1(c1)) < s(s(ticket1(c1))))
  453:[binary:452,35] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........13  |
|  clauses generated        .......240  |
|  clauses kept             .......164  |
|  clauses forward subsumed ........36  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.320 sec)
** success
==========
case #4-3: Run2(Run2(Run1(Run1(shop(c1,c2)))))
----------
hypo: P(Run2(Run2(Run1(Run2(shop(c1,c2))))))_
goal: P(Run2(Run2(Run1(Run1(shop(c1,c2))))))*
 
** PROOF ________________________________
 
  12:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
        = shop(run1(_v143,ticket2(_v144)),
               _v144)
  13:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  14:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  15:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  21:[] ~(stat2(run2(_v172:Customer2,_v171:NatNum)) 
          = wait) | stat2(_v172:Customer2) 
                    = non-CS
  22:[] ~(stat2(_v175:Customer2) = non-CS) | 
        ticket2(run2(_v175:Customer2,_v176:NatNum)) 
        = s(_v176)
  25:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  26:[] ~(stat2(_v192:Customer2) = wait) | 
        _v191:NatNum = 0 | ticket2(_v192:Customer2) 
                           < _v191:NatNum | 
        stat2(run2(_v192:Customer2,_v191:NatNum)) 
        = error
  31:[] (_v210:Status = _v210) = true
  32:[] ~(s(_v212:NatNum) < _v212)
  34:[] _v287:NatNum < s(_v287)
  36:[] ~(s(_v216:NatNum) = _v216)
  45:[] ~(stat1(_v237:Customer1) = non-CS) | 
        stat1(run1(_v237:Customer1,_v236:NatNum)) 
        = wait
  46:[] ~(stat1(run1(_v241:Customer1,_v240:NatNum)) 
          = wait) | stat1(_v241:Customer1) 
                    = non-CS
  47:[] ~(stat1(_v244:Customer1) = non-CS) | 
        ticket1(run1(_v244:Customer1,_v245:NatNum)) 
        = s(_v245)
  50:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  51:[] ~(stat1(_v261:Customer1) = wait) | 
        _v260:NatNum = 0 | ~(_v260:NatNum 
                             < ticket1(_v261:Customer1)) | 
        stat1(run1(_v261:Customer1,_v260:NatNum)) 
        = error
  53:[] ~(stat1(_v269:Customer1) = wait) | 
        ticket1(run1(_v269:Customer1,_v268:NatNum)) 
        = ticket1(_v269)
  56:[demod:12,13,14] 
    stat1(run1(run1(c1,ticket2(c2)),ticket2(c2))) 
    = CS
  57:[demod:12,13,15,back-demod:207] 
    stat2(run2(run2(c2,ticket1(run1(c1,ticket2(c2)))),
               ticket1(run1(c1,ticket2(c2))))) 
    = CS
  131:[hyper:56,50,back-demod:252] 
    wait = wait
  136:[para-into:56,51,demod:131,31,dconst:back-demod:251] 
    ticket2(c2) = 0 | ~(ticket2(c2) < s(ticket2(c2)))
  161:[hyper:57,25,back-demod:207] 
    stat2(run2(c2,ticket1(run1(c1,ticket2(c2))))) 
    = wait
  170:[para-into:57,26,demod:161,31,dconst:back-demod:207] 
    ticket1(run1(c1,ticket2(c2))) = 0 | 
    ticket2(run2(c2,ticket1(run1(c1,ticket2(c2))))) 
    < ticket1(run1(c1,ticket2(c2)))
  207:[hyper:131,53,back-demod:251] 
    ticket1(run1(run1(c1,ticket2(c2)),_v331:NatNum)) 
    = s(ticket2(c2))
  213:[hyper:131,46] 
    stat1(c1) = non-CS
  216:[back-demod:207,161,back-demod:251] 
    stat2(run2(c2,s(ticket2(c2)))) = wait
  220:[back-demod:207,170,back-demod:251] 
    s(ticket2(c2)) = 0 | ticket2(run2(c2,
                                      s(ticket2(c2)))) 
                         < s(ticket2(c2))
  251:[hyper:213,47] 
    ticket1(run1(c1,_v355:NatNum)) = s(_v355)
  252:[hyper:213,45] 
    stat1(run1(c1,_v356:NatNum)) = wait
  254:[back-demod:251,136,unit-del:34] 
    ticket2(c2) = 0
  259:[back-demod:251,216,demod:254] 
    stat2(run2(c2,s(0))) = wait
  261:[back-demod:251,220,demod:254,unit-del:36,back-demod:379] 
    s(s(0)) < s(0)
  351:[hyper:259,21] 
    stat2(c2) = non-CS
  379:[hyper:351,22] 
    ticket2(run2(c2,_v472:NatNum)) = s(_v472)
  381:[back-demod:379,261] 
    s(s(0)) < s(0)
  382:[binary:381,32] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........14  |
|  clauses generated        .......208  |
|  clauses kept             .......135  |
|  clauses forward subsumed ........31  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.260 sec)
** success
==========
case #4-4: Run2(Run2(Run1(Run2(shop(c1,c2)))))
----------_
goal: P(Run2(Run2(Run1(Run2(shop(c1,c2))))))*
 
** PROOF ________________________________
 
  3:[back-demod:11] ~(Stat1(shop(run1(c1,
                                      ticket2(c2)),
                                 c2)) = 
                      CS) | ~(Stat2(shop(run1(c1,
                                              ticket2(c2)),
                                         c2)) 
                              = CS)
  11:[] Run1(shop(_v143:Customer1,_v144:Customer2)) 
        = shop(run1(_v143,ticket2(_v144)),
               _v144)
  12:[] Run2(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(_v148,run2(_v147,ticket1(_v148)))
  13:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  14:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  20:[] ~(stat2(run2(_v172:Customer2,_v171:NatNum)) 
          = wait) | stat2(_v172:Customer2) 
                    = non-CS
  21:[] ~(stat2(_v175:Customer2) = non-CS) | 
        ticket2(run2(_v175:Customer2,_v176:NatNum)) 
        = s(_v176)
  24:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  25:[] ~(stat2(_v192:Customer2) = wait) | 
        _v191:NatNum = 0 | ticket2(_v192:Customer2) 
                           < _v191:NatNum | 
        stat2(run2(_v192:Customer2,_v191:NatNum)) 
        = error
  28:[flip] (stat2(run2(_v204:Customer2,
                        _v203:NatNum)) = 
             non-CS) = (stat2(_v204) = CS)
  29:[] ~(stat2(_v208:Customer2) = CS) | 
        ticket2(run2(_v208:Customer2,_v207:NatNum)) 
        = 0
  30:[] (_v210:Status = _v210) = true
  31:[] ~(s(_v212:NatNum) < _v212)
  40:[] ~(_v231:NatNum < 0)
  48:[] stat1(run1(_v253:Customer1,_v252:NatNum)) 
        = CS | ~(stat1(_v253:Customer1) 
                 = wait) | _v252:NatNum 
                           < ticket1(_v253:Customer1)
  49:[] ~(stat1(run1(_v257:Customer1,_v256:NatNum)) 
          = CS) | stat1(_v257:Customer1) 
                  = wait
  52:[] ~(stat1(_v269:Customer1) = wait) | 
        ticket1(run1(_v269:Customer1,_v268:NatNum)) 
        = ticket1(_v269)
  55:[demod:12,11,13,back-demod:630] 
    stat1(run1(c1,0)) = CS
  56:[demod:12,11,14,back-demod:221] 
    stat2(run2(run2(run2(c2,ticket1(c1)),
                    ticket1(c1)),ticket1(c1))) 
    = CS
  110:[back-demod:11,3,demod:13,14,back-demod:585] 
    ~(stat1(run1(c1,ticket2(c2))) = CS) | 
    ~(CS = CS)
  126:[hyper:55,49] stat1(c1) = wait
  159:[hyper:56,24,back-demod:221] 
    stat2(run2(run2(c2,ticket1(c1)),ticket1(c1))) 
    = wait
  173:[para-into:56,25,demod:159,30,dconst:back-demod:221] 
    ticket1(c1) = 0 | ticket2(run2(run2(c2,
                                        ticket1(c1)),
                                   ticket1(c1))) 
                      < ticket1(c1)
  221:[hyper:126,52,back-demod:886] 
    ticket1(run1(c1,_v340:NatNum)) = 0
  222:[hyper:126,48,back-demod:886] 
    _v341:NatNum < 0 | stat1(run1(c1,_v341:NatNum)) 
                       = CS
  232:[back-demod:221,159,back-demod:886] 
    stat2(run2(run2(c2,0),0)) = wait
  239:[back-demod:221,173,back-demod:886] 
    0 = 0 | ticket2(run2(run2(c2,0),0)) 
            < 0
  546:[para-from:222,110,demod:30,back-demod:585] 
    ~(CS = CS) | ticket2(c2) < ticket1(c1)
  585:[hyper:232,20,demod:28] 
    stat2(c2) = CS
  600:[back-demod:585,546,demod:30,back-demod:886] 
    ticket2(c2) < 0
  630:[hyper:585,29] 
    ticket2(run2(c2,_v694:NatNum)) = 0
  886:[para-into:239,21,demod:28,585,30,unit-del:31] 
    ticket1(c1) = 0
  906:[back-demod:886,600] 
    ticket2(c2) < 0
  907:[binary:906,40] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......676  |
|  clauses kept             .......186  |
|  clauses forward subsumed .......148  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.540 sec)
** success
** Predicate P is invriant!!
 
(grand total time 10.591 sec)
\end{verbatim}
      }
  \item 結果は, 検査仕様の予想通りである：
    \begin{itemize}
    \item 最終ケースは \verb:#4-4: であり, 予想通り4ステップの遷移で
      検査が終了している.
    \item 実行ログを見ると, 事前に設定した反駁システムのフラグ・パラメータ
      に従って実行が行われている事が了解できる.
    \item 各ケース毎に, 実行文脈, 証明対象とする項がその都度正しく表示
      されている.
    \item 証明結果が証明対象毎に正しく表示されている.
    \item 証明に失敗した場合, 同じ文脈で初期状態に対する検査が正しく
      行われている. また全てのこのような場合, 正常で終了している.
    \item 最終結果は予想通り「成功」である. 
    \end{itemize}
  \end{enumerate}
\end{enumerate}

\subsection{反例発見終了の場合}
\label{sec:model-counter-end}
モデル検査システムは, ある文脈(システム状態)で,
指定の性質を表現した述語の証明に失敗した場合, 同じ文脈で初期状態に
関して述語の証明を行う. これは, 初期状態から性質の保証されない
状態へ入る事があるかどうかを検査するためである. この証明にも
失敗した場合, 今度は具体的な反例を探す. 本節はこのような機能が
正しく実現されているかを検査するものである.

\subsubsection{検査内容}

\begin{enumerate}
\item モデル検査を行った結果が, 正常とはならないケースを
  用意する.
\item このケースでモデル検査機能を起動し, 反例が正しく得られるか
  どうかを見る.
\end{enumerate}

具体的なテストデータ, 実行手順は次節で示す.

\subsubsection{テストデータと手順}
\label{sec:model-counter-data}
\begin{enumerate}
\item 以下の内容のモジュール定義,および実行スクリプトを記入した
  ファイル ``model-counter.mod'' を用意する.
  この内容は, 第\ref{sec:model-normal-end-data} 節の第2項で示した
  テストデータを修正し, 安全性が証明できないようにしたものである.
  {\small
\begin{verbatim}
**>
**> モデル検査：反例発見終了の場合
**>

set include FOPL-CLAUSE on
 
**> 自然数
-- the natural numbers
mod! NATNUM
{
  [ NatNum ]
  op 0 : -> NatNum
  op s : NatNum -> NatNum
  pred _<_ : NatNum NatNum
  vars M N : NatNum
  ax ~(s(M) < M) .
  ax ~(s(M) = 0) .
  ax [SOS]: M < s(M) .
  ax [SOS]: 0 < s(M) .
  ax ~(s(M) = M) .
  ax [SOS]: M = 0 | 0 < M .
  ax ~(0 < M)| ~(M = 0) . 
  ax ~(M = N & M < N) .
  ax ~(M < N & N < M) .
  ax ~(M < 0) .
  ax M = M .
}

**> システム状態
-- the program counters
mod! STATUS
{
  [ Status ]
  ops non-CS wait CS : -> Status
  var S : Status
  ax (S = S) = true .
}

**> 客1
-- customers
mod* CUSTOMER1
{
  protecting(NATNUM + STATUS)
  *[ Customer1 ]*
  op init1 : -> Customer1
  -- attributes
  bop ticket1 : Customer1 -> NatNum
  bop stat1 : Customer1 -> Status
  -- methods
  bop run1 : Customer1 NatNum -> Customer1
  vars C C1 : Customer1  vars M N : NatNum
  eq stat1(init1) = non-CS .
  eq ticket1(init1) = 0 .
  ax stat1(C) = non-CS -> stat1(run1(C,M))= wait .
  ax stat1(run1(C,M))= wait -> stat1(C) = non-CS | stat1(C) = wait .
  ax stat1(C) = non-CS -> ticket1(run1(C,M)) = s(M) .
  ax stat1(C) = wait & (M = 0 | ~(M < ticket1(C))) -> stat1(run1(C,M)) = CS .
  ax stat1(run1(C,M)) = CS -> stat1(C) = wait .
  ax stat1(C) = wait & ~(M = 0) & M < ticket1(C) -> stat1(run1(C,M)) = wait .
  ax stat1(C) = wait -> ticket1(run1(C,M)) = ticket1(C) .
  ax (stat1(C) = CS) = (stat1(run1(C,M)) = non-CS) .
  ax stat1(C) = CS -> ticket1(run1(C,M)) = 0 .
}

**> 客2
mod* CUSTOMER2 {
  protecting(NATNUM + STATUS)
  *[ Customer2 ]*
  op init2 : -> Customer2
  -- attributes
  bop ticket2 : Customer2 -> NatNum
  bop stat2 : Customer2 -> Status
  -- methods
  bop run2 : Customer2 NatNum -> Customer2
  vars C C1 : Customer2  var M : NatNum
  eq stat2(init2) = non-CS .
  eq ticket2(init2) = 0 .
  ax stat2(C) = non-CS -> stat2(run2(C,M))= wait .
  ax stat2(run2(C,M))= wait -> stat2(C) = non-CS | stat2(C) = wait .
  ax stat2(C) = non-CS -> ticket2(run2(C,M)) = s(M) .
  ax stat2(C) 
     = wait & (M = 0 | ~(M < ticket2(C))) -> stat2(run2(C,M)) = CS .
  ax stat2(run2(C,M)) = CS -> stat2(C) = wait .
  ax stat2(C) = wait & ~(M = 0) & M < ticket2(C) 
     -> stat2(run2(C,M)) = wait .
  ax stat2(C) = wait -> ticket2(run2(C,M)) = ticket2(C) .
  ax (stat2(C) = CS) = (stat2(run2(C,M)) = non-CS) .
  ax stat2(C) = CS -> ticket2(run2(C,M)) = 0 .
}

**> 店
-- bakery algorithm
mod* SHOP
{
  protecting(CUSTOMER1 + CUSTOMER2)
  *[ Shop ]*
  op shop : Customer1 Customer2 -> Shop { coherent }
  bop Run1 : Shop -> Shop
  bop Run2 : Shop -> Shop
  **
  bop Run : Shop -> Shop
  **
  bop Stat1 : Shop -> Status
  bop Stat2 : Shop -> Status
  bop Ticket1 : Shop -> NatNum
  bop Ticket2 : Shop -> NatNum
  op Init : -> Shop
  vars C1 D1 : Customer1   vars C2 D2 : Customer2
  var S : Shop   var B : Bool
  ax B = B .
  eq Init = shop(init1,init2) .
  beq Run1(shop(C1,C2)) = shop(run1(C1,ticket2(C2)),C2) .
  beq Run2(shop(C1,C2)) = shop(C1,run2(C2,ticket1(C1))) .
  beq Run(shop(C1,C2)) 
      = shop(run1(C1,ticket2(C2)),run2(C2,ticket1(C1))) .
  eq Stat1(shop(C1,C2)) = stat1(C1) .
  eq Stat2(shop(C1,C2)) = stat2(C2) .
  eq Ticket1(shop(C1,C2)) = ticket1(C1) .
  eq Ticket2(shop(C1,C2)) = ticket2(C2) .
}

**> 
mod* PROOF
{

  protecting(SHOP)

  op c1 : -> Customer1 .
  op c2 : -> Customer2 .

  pred P : Shop .
  #define P(S:Shop) ::= ~(Stat1(S) = CS & Stat2(S) = CS) .

}

**> 反駁エンジンのオプションを設定する
option reset
flag(process-input, on)
flag(print-kept, off)
flag(print-new-demod, off)
flag(print-back-demod, off)
flag(print-back-sub, off)
flag(control-memory, on)
param(max-sos, 500)
param(pick-given-ratio, 4)
param(stats-level, 1)
flag(kb2, on)
flag(back-unit-deletion, on)
flag(hyper-res, on)
flag(unit-deletion, on)
flag(factor, on)
flag(universal-symmetry,off)
flag(dist-const,on)
flag(input-sos-first,on)
param(max-proofs,1)
param(max-given,51)

**> 長大なログを抑制する
flag(quiet,on)
evq (setq *print-line-limit* 40)

** ただし, 証明と統計情報は印字する.
flag(print-proofs,on)
flag(print-stats,on)
** 
**> 対象モジュールのオープン
open PROOF
**> 反駁システムの初期化
db reset
**> sos 節集合の設定
sos = { SOS }

**> モデル検査コマンドの起動
--> check safety P of shop(c1,c2) from Init
check safety P of shop(c1,c2) from Init

close

**
eof

\end{verbatim}
  }
\item 上で示した内容のファイルをシステムにロードし,
  結果を見る.
  この時次のようになっていなければならない.
  \begin{itemize}
  \item ある文脈で証明に失敗した場合, 初期状態に関して同じ文脈での
    検査を行う事.
  \item 初期状態に関して問題がなければ, 次の文脈での検査にゆく事.
  \item 初期状態に関して失敗した場合, 反例を探す処理へゆく事.
    反例が見付かったならば, その旨表示し, モデル検査を「失敗」として
    終了すること.
  \end{itemize}
\end{enumerate}

\subsubsection{実行結果}
\begin{itemize}
\item 第\ref{sec:model-counter-data}節で示されたファイル 
  ``model-counter.mod'' をシステムにロードした.
  結果のログは以下の通りである：
  {\small
\begin{verbatim}
CafeOBJ> in model-counter
processing input : ./model-counter.mod
**> 
**> モデル検査：反例発見終了の場合
**> 
**> 自然数
-- defining module! NATNUM....._...........* done.
**> システム状態
-- defining module! STATUS....._.* done.
**> 客1
-- defining module* CUSTOMER1_*........_...........*
** system failed to prove =*= is a congruence of CUSTOMER1 done.
**> 客2
-- defining module* CUSTOMER2_*........_...........*
** system failed to prove =*= is a congruence of CUSTOMER2 done.
**> 店
-- defining module* SHOP_*..............._.........*
** system failed to prove =*= is a congruence of SHOP done.
**> 
-- defining module* PROOF...._._* done.
**> 反駁エンジンのオプションを設定する
-- setting flag "process-input" to "on"
-- setting flag "print-kept" to "off"
-- setting flag "print-new-demod" to "off"
-- setting flag "print-back-demod" to "off"
-- setting flag "print-back-sub" to "off"
-- setting flag "control-memory" to "on"
-- setting parameter "max-sos" to 500.
-- setting parameter "pick-given-ratio" to 4.
-- setting parameter "stats-level" to 1.
-- setting flag "kb2" to "on"
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
-- setting flag "back-unit-deletion" to "on"
   dependent: flag(unit-deletion, on)
-- setting flag "hyper-res" to "on"
-- setting flag "unit-deletion" to "on"
-- setting flag "factor" to "on"
-- setting flag "universal-symmetry" to "off"
-- setting flag "dist-const" to "on"
-- setting flag "input-sos-first" to "on"
-- setting parameter "max-proofs" to 1.
-- setting parameter "max-given" to 51.
**> 長大なログを抑制する
-- setting flag "quiet" to "on"
   dependent: flag(print-message, off)
**> 対象モジュールのオープン
-- opening module PROOF.. done.
**> 反駁システムの初期化
**> sos 節集合の設定
**> モデル検査コマンドの起動
--> check safety P of shop(c1,c2) from Init
==========
case #0-1: shop(c1,c2)
----------_
goal: P(shop(c1,c2))*
** Search stopped because SOS is empty.
 
** PigNose statistics ------------------+
|  clauses given            ........13  |
|  clauses generated        ........89  |
|  clauses kept             ........56  |
|  clauses forward subsumed ........20  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.050 sec)
** fail
** check with the initial state : Init_
goal: P(Init)*
 
** PROOF ________________________________
 
  2:[] Init = shop(init1,init2)
  6:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
       = stat1(_v152)
  34:[] stat1(init1) = non-CS
  46:[demod:2,6,34,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........43  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.030 sec)
** ok, it's safe.
adding axiom: P(shop(c1,c2))
==========
case #1-1: Run1(shop(c1,c2))
----------
hypo: P(Run2(shop(c1,c2)))
hypo: P(Run(shop(c1,c2)))_
goal: P(Run1(shop(c1,c2)))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......844  |
|  clauses kept             .......153  |
|  clauses forward subsumed .......166  |
|  clauses back subsumed    .........3  |
+---------------------------------------+
(total run time 0.530 sec)
** fail
** check with the initial state : Run1(Init)_
goal: P(Run1(Init))*
 
** PROOF ________________________________
 
  5:[] Init = shop(init1,init2)
  6:[] Run1(shop(_v139:Customer1,_v140:Customer2)) 
       = shop(run1(_v139,ticket2(_v140)),
              _v140)
  10:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  13:[] stat2(init2) = non-CS
  14:[] ticket2(init2) = 0
  50:[demod:5,6,14,10,13,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........50  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.040 sec)
** ok, it's safe.
==========
case #1-2: Run2(shop(c1,c2))
----------
hypo: P(Run1(shop(c1,c2)))
hypo: P(Run(shop(c1,c2)))_
goal: P(Run2(shop(c1,c2)))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......844  |
|  clauses kept             .......153  |
|  clauses forward subsumed .......166  |
|  clauses back subsumed    .........3  |
+---------------------------------------+
(total run time 0.520 sec)
** fail
** check with the initial state : Run2(Init)_
goal: P(Run2(Init))*
 
** PROOF ________________________________
 
  5:[] Init = shop(init1,init2)
  7:[] Run2(shop(_v144:Customer1,_v143:Customer2)) 
       = shop(_v144,run2(_v143,ticket1(_v144)))
  9:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
       = stat1(_v152)
  37:[] stat1(init1) = non-CS
  38:[] ticket1(init1) = 0
  49:[demod:5,7,38,9,37,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........49  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.030 sec)
** ok, it's safe.
==========
case #1-3: Run(shop(c1,c2))
----------
hypo: P(Run2(shop(c1,c2)))
hypo: P(Run1(shop(c1,c2)))_
goal: P(Run(shop(c1,c2)))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......895  |
|  clauses kept             .......173  |
|  clauses forward subsumed .......159  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.470 sec)
** fail
** check with the initial state : Run(Init)_
goal: P(Run(Init))*
 
** PROOF ________________________________
 
  5:[] Init = shop(init1,init2)
  8:[] Run(shop(_v148:Customer1,_v147:Customer2)) 
       = shop(run1(_v148,ticket2(_v147)),
              run2(_v147,ticket1(_v148)))
  9:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
       = stat1(_v152)
  14:[] ticket2(init2) = 0
  37:[] stat1(init1) = non-CS
  38:[] ticket1(init1) = 0
  44:[] ~(stat1(run1(_v253:Customer1,_v252:NatNum)) 
          = CS) | stat1(_v253:Customer1) 
                  = wait
  49:[demod:5,8,14,38,9] 
    stat1(run1(init1,0)) = CS
  109:[hyper:49,44,demod:37,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........1  |
|  clauses generated        .........3  |
|  clauses kept             ........55  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.070 sec)
** ok, it's safe.
adding axiom: P(Run(shop(c1,c2)))
adding axiom: P(Run2(shop(c1,c2)))
adding axiom: P(Run1(shop(c1,c2)))
==========
case #2-1: Run1(Run1(shop(c1,c2)))
----------
hypo: P(Run1(Run2(shop(c1,c2))))
hypo: P(Run1(Run(shop(c1,c2))))
hypo: P(Run2(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))
hypo: P(Run2(Run(shop(c1,c2))))
hypo: P(Run(Run1(shop(c1,c2))))
hypo: P(Run(Run2(shop(c1,c2))))
hypo: P(Run(Run(shop(c1,c2))))_
goal: P(Run1(Run1(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .....1,477  |
|  clauses kept             .......305  |
|  clauses forward subsumed .......662  |
|  clauses back subsumed    .........3  |
+---------------------------------------+
(total run time 1.070 sec)
** fail
** check with the initial state : Run1(Run1(Init))_
goal: P(Run1(Run1(Init)))*
 
** PROOF ________________________________
 
  14:[] Init = shop(init1,init2)
  15:[] Run1(shop(_v139:Customer1,_v140:Customer2)) 
        = shop(run1(_v139,ticket2(_v140)),
               _v140)
  19:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  22:[] stat2(init2) = non-CS
  23:[] ticket2(init2) = 0
  59:[demod:14,15,23,19,22,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........68  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.060 sec)
** ok, it's safe.
==========
case #2-2: Run1(Run2(shop(c1,c2)))
----------
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run1(Run(shop(c1,c2))))
hypo: P(Run2(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))
hypo: P(Run2(Run(shop(c1,c2))))
hypo: P(Run(Run1(shop(c1,c2))))
hypo: P(Run(Run2(shop(c1,c2))))
hypo: P(Run(Run(shop(c1,c2))))_
goal: P(Run1(Run2(shop(c1,c2))))*
 
** PROOF ________________________________
 
  2:[back-demod:17] ~(Stat1(shop(run1(c1,
                                      ticket2(c2)),
                                 run2(c2,
                                      ticket1(c1)))) 
                      = CS) | ~(Stat2(shop(run1(c1,
                                                ticket2(c2)),
                                           run2(c2,
                                                ticket1(c1)))) 
                                = CS)
  15:[] Run1(shop(_v139:Customer1,_v140:Customer2)) 
        = shop(run1(_v139,ticket2(_v140)),
               _v140)
  16:[] Run2(shop(_v144:Customer1,_v143:Customer2)) 
        = shop(_v144,run2(_v143,ticket1(_v144)))
  17:[] Run(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(run1(_v148,ticket2(_v147)),
               run2(_v147,ticket1(_v148)))
  18:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  19:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  29:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  31:[] ~(stat2(_v196:Customer2) = wait) | 
        ticket2(run2(_v196:Customer2,_v195:NatNum)) 
        = ticket2(_v196)
  34:[] (_v206:Status = _v206) = true
  58:[demod:16,15,18] 
    stat1(run1(c1,ticket2(run2(c2,ticket1(c1))))) 
    = CS
  59:[demod:16,15,19] 
    stat2(run2(c2,ticket1(c1))) = CS
  123:[back-demod:17,2,demod:18,19,back-demod:59] 
    ~(stat1(run1(c1,ticket2(c2))) = CS) | 
    ~(CS = CS)
  137:[back-demod:59,123,demod:34] 
    ~(stat1(run1(c1,ticket2(c2))) = CS)
  145:[para-into:58,31,unit-del:137] 
    ~(stat2(c2) = wait)
  172:[hyper:59,29] stat2(c2) = wait
  173:[binary:172,145] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........2  |
|  clauses generated        ........31  |
|  clauses kept             ........86  |
|  clauses forward subsumed .........6  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.110 sec)
** success
==========
case #2-3: Run1(Run(shop(c1,c2)))
----------
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run2(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))
hypo: P(Run2(Run(shop(c1,c2))))
hypo: P(Run(Run1(shop(c1,c2))))
hypo: P(Run(Run2(shop(c1,c2))))
hypo: P(Run(Run(shop(c1,c2))))_
goal: P(Run1(Run(shop(c1,c2))))*
 
** PROOF ________________________________
 
  9:[back-demod:14] ~(Stat1(Run(shop(run1(c1,
                                          ticket2(c2)),
                                     c2))) 
                      = CS) | ~(Stat2(Run(shop(run1(c1,
                                                    ticket2(c2)),
                                               c2))) 
                                = CS)
  14:[] Run1(shop(_v139:Customer1,_v140:Customer2)) 
        = shop(run1(_v139,ticket2(_v140)),
               _v140)
  16:[] Run(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(run1(_v148,ticket2(_v147)),
               run2(_v147,ticket1(_v148)))
  17:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  18:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  27:[] stat2(run2(_v184:Customer2,_v183:NatNum)) 
        = CS | ~(stat2(_v184:Customer2) 
                 = wait) | _v183:NatNum 
                           < ticket2(_v184:Customer2)
  28:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  30:[] ~(stat2(_v196:Customer2) = wait) | 
        ticket2(run2(_v196:Customer2,_v195:NatNum)) 
        = ticket2(_v196)
  33:[] (_v206:Status = _v206) = true
  34:[] ~(s(_v208:NatNum) < _v208)
  48:[] ~(stat1(run1(_v237:Customer1,_v236:NatNum)) 
          = wait) | stat1(_v237:Customer1) 
                    = non-CS | stat1(_v237:Customer1) 
                               = wait
  49:[] ~(stat1(_v240:Customer1) = non-CS) | 
        ticket1(run1(_v240:Customer1,_v241:NatNum)) 
        = s(_v241)
  52:[] ~(stat1(run1(_v253:Customer1,_v252:NatNum)) 
          = CS) | stat1(_v253:Customer1) 
                  = wait
  54:[] ~(stat1(_v261:Customer1) = wait) | 
        ticket1(run1(_v261:Customer1,_v260:NatNum)) 
        = ticket1(_v261)
  57:[demod:16,14,17,back-demod:222] 
    stat1(run1(run1(c1,ticket2(c2)),ticket2(c2))) 
    = CS
  58:[demod:16,14,18] 
    stat2(run2(c2,ticket1(c1))) = CS
  117:[back-demod:14,9,demod:16,17,18] 
    ~(stat1(run1(run1(c1,ticket2(c2)),ticket2(c2))) 
      = CS) | ~(stat2(run2(c2,ticket1(run1(c1,
                                           ticket2(c2))))) 
                = CS)
  136:[hyper:57,52] stat1(run1(c1,ticket2(c2))) 
                    = wait
  142:[para-into:57,30,back-demod:169] 
    stat1(run1(run1(c1,ticket2(c2)),ticket2(c2))) 
    = CS | ~(wait = wait)
  169:[hyper:58,28] stat2(c2) = wait
  173:[back-demod:169,142,demod:33] 
    stat1(run1(run1(c1,ticket2(c2)),ticket2(c2))) 
    = CS
  222:[hyper:169,30] 
    ticket2(run2(c2,_v324:NatNum)) = ticket2(c2)
  223:[hyper:169,27] 
    _v325:NatNum < ticket2(c2) | stat2(run2(c2,
                                            _v325:NatNum)) 
                                 = CS
  279:[hyper:136,48] 
    stat1(c1) = wait | stat1(c1) = non-CS
  383:[hyper:279,54] 
    stat1(c1) = non-CS | ticket1(run1(c1,
                                      _v436:NatNum)) 
                         = ticket1(c1)
  534:[hyper:223,117,173] 
    ticket1(run1(c1,ticket2(c2))) < ticket2(c2)
  579:[para-into:534,49,unit-del:34] 
    ~(stat1(c1) = non-CS)
  587:[binary:579,383,back-unit-del] 
    ticket1(run1(c1,_v612:NatNum)) = ticket1(c1)
  686:[para-from:587,117,demod:173,33,58] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........35  |
|  clauses generated        .......502  |
|  clauses kept             .......158  |
|  clauses forward subsumed .......124  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.350 sec)
** success
==========
case #2-4: Run2(Run1(shop(c1,c2)))
----------
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))
hypo: P(Run2(Run(shop(c1,c2))))
hypo: P(Run(Run1(shop(c1,c2))))
hypo: P(Run(Run2(shop(c1,c2))))
hypo: P(Run(Run(shop(c1,c2))))_
goal: P(Run2(Run1(shop(c1,c2))))*
 
** PROOF ________________________________
 
  2:[back-demod:15] ~(Stat1(shop(run1(c1,
                                      ticket2(c2)),
                                 run2(c2,
                                      ticket1(c1)))) 
                      = CS) | ~(Stat2(shop(run1(c1,
                                                ticket2(c2)),
                                           run2(c2,
                                                ticket1(c1)))) 
                                = CS)
  13:[] Run1(shop(_v139:Customer1,_v140:Customer2)) 
        = shop(run1(_v139,ticket2(_v140)),
               _v140)
  14:[] Run2(shop(_v144:Customer1,_v143:Customer2)) 
        = shop(_v144,run2(_v143,ticket1(_v144)))
  15:[] Run(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(run1(_v148,ticket2(_v147)),
               run2(_v147,ticket1(_v148)))
  16:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  17:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  32:[] (_v206:Status = _v206) = true
  51:[] ~(stat1(run1(_v253:Customer1,_v252:NatNum)) 
          = CS) | stat1(_v253:Customer1) 
                  = wait
  53:[] ~(stat1(_v261:Customer1) = wait) | 
        ticket1(run1(_v261:Customer1,_v260:NatNum)) 
        = ticket1(_v261)
  56:[demod:13,14,16] 
    stat1(run1(c1,ticket2(c2))) = CS
  57:[demod:13,14,17] 
    stat2(run2(c2,ticket1(run1(c1,ticket2(c2))))) 
    = CS
  118:[back-demod:15,2,demod:16,17,back-demod:56] 
    ~(CS = CS) | ~(stat2(run2(c2,ticket1(c1))) 
                   = CS)
  130:[back-demod:56,118,demod:32] 
    ~(stat2(run2(c2,ticket1(c1))) = CS)
  134:[hyper:56,51] stat1(c1) = wait
  167:[para-into:57,53,demod:134,32] 
    stat2(run2(c2,ticket1(c1))) = CS
  168:[binary:167,130] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........2  |
|  clauses generated        ........30  |
|  clauses kept             ........80  |
|  clauses forward subsumed .........6  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.100 sec)
** success
==========
case #2-5: Run2(Run2(shop(c1,c2)))
----------
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run2(Run(shop(c1,c2))))
hypo: P(Run(Run1(shop(c1,c2))))
hypo: P(Run(Run2(shop(c1,c2))))
hypo: P(Run(Run(shop(c1,c2))))_
goal: P(Run2(Run2(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .....1,477  |
|  clauses kept             .......286  |
|  clauses forward subsumed .......621  |
|  clauses back subsumed    .........3  |
+---------------------------------------+
(total run time 0.960 sec)
** fail
** check with the initial state : Run2(Run2(Init))_
goal: P(Run2(Run2(Init)))*
 
** PROOF ________________________________
 
  11:[] Init = shop(init1,init2)
  13:[] Run2(shop(_v144:Customer1,_v143:Customer2)) 
        = shop(_v144,run2(_v143,ticket1(_v144)))
  15:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  43:[] stat1(init1) = non-CS
  44:[] ticket1(init1) = 0
  55:[demod:11,13,44,15,43,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........61  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.060 sec)
** ok, it's safe.
==========
case #2-6: Run2(Run(shop(c1,c2)))
----------
hypo: P(Run2(Run2(shop(c1,c2))))
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run(Run1(shop(c1,c2))))
hypo: P(Run(Run2(shop(c1,c2))))
hypo: P(Run(Run(shop(c1,c2))))_
goal: P(Run2(Run(shop(c1,c2))))*
 
** PROOF ________________________________
 
  8:[back-demod:13] ~(Stat1(Run(shop(c1,
                                     run2(c2,
                                          ticket1(c1))))) 
                      = CS) | ~(Stat2(Run(shop(c1,
                                               run2(c2,
                                                    ticket1(c1))))) 
                                = CS)
  13:[] Run2(shop(_v144:Customer1,_v143:Customer2)) 
        = shop(_v144,run2(_v143,ticket1(_v144)))
  14:[] Run(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(run1(_v148,ticket2(_v147)),
               run2(_v147,ticket1(_v148)))
  15:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  16:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  22:[] ~(stat2(run2(_v172:Customer2,_v171:NatNum)) 
          = wait) | stat2(_v172:Customer2) 
                    = non-CS | stat2(_v172:Customer2) 
                               = wait
  23:[] ~(stat2(_v175:Customer2) = non-CS) | 
        ticket2(run2(_v175:Customer2,_v176:NatNum)) 
        = s(_v176)
  26:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  28:[] ~(stat2(_v196:Customer2) = wait) | 
        ticket2(run2(_v196:Customer2,_v195:NatNum)) 
        = ticket2(_v196)
  31:[] (_v206:Status = _v206) = true
  32:[] ~(s(_v208:NatNum) < _v208)
  49:[] stat1(run1(_v249:Customer1,_v248:NatNum)) 
        = CS | ~(stat1(_v249:Customer1) 
                 = wait) | _v248:NatNum 
                           < ticket1(_v249:Customer1)
  50:[] ~(stat1(run1(_v253:Customer1,_v252:NatNum)) 
          = CS) | stat1(_v253:Customer1) 
                  = wait
  52:[] ~(stat1(_v261:Customer1) = wait) | 
        ticket1(run1(_v261:Customer1,_v260:NatNum)) 
        = ticket1(_v261)
  55:[demod:14,13,15] 
    stat1(run1(c1,ticket2(c2))) = CS
  56:[demod:14,13,16,back-demod:212] 
    stat2(run2(run2(c2,ticket1(c1)),ticket1(c1))) 
    = CS
  115:[back-demod:13,8,demod:14,15,16,back-demod:162] 
    ~(stat1(run1(c1,ticket2(run2(c2,ticket1(c1))))) 
      = CS) | ~(CS = CS)
  130:[hyper:55,50] stat1(c1) = wait
  159:[hyper:56,26] stat2(run2(c2,ticket1(c1))) 
                    = wait
  162:[para-into:56,52,demod:130,31] 
    stat2(run2(run2(c2,ticket1(c1)),ticket1(c1))) 
    = CS
  171:[back-demod:162,115,demod:31] 
    ~(stat1(run1(c1,ticket2(run2(c2,ticket1(c1))))) 
      = CS)
  212:[hyper:130,52] 
    ticket1(run1(c1,_v324:NatNum)) = ticket1(c1)
  213:[hyper:130,49] 
    _v325:NatNum < ticket1(c1) | stat1(run1(c1,
                                            _v325:NatNum)) 
                                 = CS
  269:[hyper:159,22] 
    stat2(c2) = wait | stat2(c2) = non-CS
  360:[hyper:269,23] 
    stat2(c2) = wait | ticket2(run2(c2,_v430:NatNum)) 
                       = s(_v430)
  629:[para-into:171,28,demod:55,31] 
    ~(stat2(c2) = wait)
  641:[binary:629,360,back-unit-del] 
    ticket2(run2(c2,_v640:NatNum)) = s(_v640)
  727:[hyper:213,171,demod:641] 
    s(ticket1(c1)) < ticket1(c1)
  728:[binary:727,32] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........36  |
|  clauses generated        .......562  |
|  clauses kept             .......156  |
|  clauses forward subsumed .......117  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.370 sec)
** success
==========
case #2-7: Run(Run1(shop(c1,c2)))
----------
hypo: P(Run2(Run2(shop(c1,c2))))
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run(Run2(shop(c1,c2))))
hypo: P(Run(Run(shop(c1,c2))))_
goal: P(Run(Run1(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .....1,481  |
|  clauses kept             .......293  |
|  clauses forward subsumed .......542  |
|  clauses back subsumed    .........8  |
+---------------------------------------+
(total run time 0.950 sec)
** fail
** check with the initial state : Run(Run1(Init))_
goal: P(Run(Run1(Init)))*
 
** PROOF ________________________________
 
  10:[] Init = shop(init1,init2)
  11:[] Run1(shop(_v139:Customer1,_v140:Customer2)) 
        = shop(run1(_v139,ticket2(_v140)),
               _v140)
  13:[] Run(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(run1(_v148,ticket2(_v147)),
               run2(_v147,ticket1(_v148)))
  15:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  18:[] stat2(init2) = non-CS
  19:[] ticket2(init2) = 0
  25:[] ~(stat2(run2(_v188:Customer2,_v187:NatNum)) 
          = CS) | stat2(_v188:Customer2) 
                  = wait
  55:[demod:10,11,19,13,15] 
    stat2(run2(init2,ticket1(run1(init1,
                                  0)))) 
    = CS
  150:[hyper:55,25,demod:18,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........2  |
|  clauses generated        ........28  |
|  clauses kept             ........69  |
|  clauses forward subsumed .........5  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.100 sec)
** ok, it's safe.
==========
case #2-8: Run(Run2(shop(c1,c2)))
----------
hypo: P(Run(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run(Run(shop(c1,c2))))_
goal: P(Run(Run2(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .....1,629  |
|  clauses kept             .......301  |
|  clauses forward subsumed .......632  |
|  clauses back subsumed    .........5  |
+---------------------------------------+
(total run time 1.100 sec)
** fail
** check with the initial state : Run(Run2(Init))_
goal: P(Run(Run2(Init)))*
 
** PROOF ________________________________
 
  10:[] Init = shop(init1,init2)
  12:[] Run2(shop(_v144:Customer1,_v143:Customer2)) 
        = shop(_v144,run2(_v143,ticket1(_v144)))
  13:[] Run(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(run1(_v148,ticket2(_v147)),
               run2(_v147,ticket1(_v148)))
  14:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  42:[] stat1(init1) = non-CS
  43:[] ticket1(init1) = 0
  49:[] ~(stat1(run1(_v253:Customer1,_v252:NatNum)) 
          = CS) | stat1(_v253:Customer1) 
                  = wait
  54:[demod:10,12,43,13,14] 
    stat1(run1(init1,ticket2(run2(init2,
                                  0)))) 
    = CS
  124:[hyper:54,49,demod:42,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........1  |
|  clauses generated        .........3  |
|  clauses kept             ........65  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.090 sec)
** ok, it's safe.
==========
case #2-9: Run(Run(shop(c1,c2)))
----------
hypo: P(Run(Run2(shop(c1,c2))))
hypo: P(Run(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))
hypo: P(Run1(Run1(shop(c1,c2))))_
goal: P(Run(Run(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .....1,428  |
|  clauses kept             .......320  |
|  clauses forward subsumed .......486  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 1.120 sec)
** fail
** check with the initial state : Run(Run(Init))_
goal: P(Run(Run(Init)))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........51  |
|  clauses generated        .......754  |
|  clauses kept             .......152  |
|  clauses forward subsumed .......112  |
|  clauses back subsumed    .........4  |
+---------------------------------------+
(total run time 0.430 sec)
** fail!
  trying to find a counter example: _
ax: P(Run(Run(Init)))*
 
** PROOF ________________________________
 
  10:[] Init = shop(init1,init2)
  13:[] Run(shop(_v148:Customer1,_v147:Customer2)) 
        = shop(run1(_v148,ticket2(_v147)),
               run2(_v147,ticket1(_v148)))
  14:[] Stat1(shop(_v152:Customer1,_v151:Customer2)) 
        = stat1(_v152)
  15:[] Stat2(shop(_v155:Customer1,_v156:Customer2)) 
        = stat2(_v156)
  18:[] stat2(init2) = non-CS
  19:[] ticket2(init2) = 0
  20:[] ~(stat2(_v168:Customer2) = non-CS) | 
        stat2(run2(_v168:Customer2,_v167:NatNum)) 
        = wait
  22:[] ~(stat2(_v175:Customer2) = non-CS) | 
        ticket2(run2(_v175:Customer2,_v176:NatNum)) 
        = s(_v176)
  24:[] stat2(run2(_v184:Customer2,_v183:NatNum)) 
        = CS | ~(stat2(_v184:Customer2) 
                 = wait) | _v183:NatNum 
                           < ticket2(_v184:Customer2)
  30:[] (_v206:Status = _v206) = true
  39:[] ~(_v222:NatNum < _v221:NatNum) | 
        ~(_v221:NatNum < _v222:NatNum)
  42:[] stat1(init1) = non-CS
  43:[] ticket1(init1) = 0
  44:[] ~(stat1(_v233:Customer1) = non-CS) | 
        stat1(run1(_v233:Customer1,_v232:NatNum)) 
        = wait
  46:[] ~(stat1(_v240:Customer1) = non-CS) | 
        ticket1(run1(_v240:Customer1,_v241:NatNum)) 
        = s(_v241)
  48:[] stat1(run1(_v249:Customer1,_v248:NatNum)) 
        = CS | ~(stat1(_v249:Customer1) 
                 = wait) | _v248:NatNum 
                           < ticket1(_v249:Customer1)
  54:[demod:10,13,19,43,14,15] 
    ~(stat1(run1(run1(init1,0),ticket2(run2(init2,
                                            0)))) 
      = CS) | ~(stat2(run2(run2(init2,0),
                           ticket1(run1(init1,
                                        0)))) 
                = CS)
  115:[factor:39] ~(_v275:NatNum < _v275)
  126:[para-into:54,48,demod:30] 
    ~(stat2(run2(run2(init2,0),ticket1(run1(init1,
                                            0)))) 
      = CS) | ~(stat1(run1(init1,0)) = wait) | 
    ticket2(run2(init2,0)) < ticket1(run1(init1,
                                          0))
  184:[para-into:126,44,demod:30,42] 
    ~(stat2(run2(run2(init2,0),ticket1(run1(init1,
                                            0)))) 
      = CS) | ticket2(run2(init2,0)) < ticket1(run1(init1,
                                                    0))
  224:[para-into:184,46,demod:42,30] 
    ~(stat2(run2(run2(init2,0),s(0))) = 
      CS) | ticket2(run2(init2,0)) < ticket1(run1(init1,
                                                  0))
  247:[para-into:224,22,demod:18,30] 
    ~(stat2(run2(run2(init2,0),s(0))) = 
      CS) | s(0) < ticket1(run1(init1,0))
  280:[para-into:247,46,demod:42,30,unit-del:115] 
    ~(stat2(run2(run2(init2,0),s(0))) = 
      CS)
  283:[para-into:280,24,demod:30] 
    ~(stat2(run2(init2,0)) = wait) | s(0) 
                                     < ticket2(run2(init2,
                                                    0))
  297:[para-into:283,22,demod:18,30,unit-del:115] 
    ~(stat2(run2(init2,0)) = wait)
  298:[para-into:297,20,demod:30,18] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........15  |
|  clauses generated        .......170  |
|  clauses kept             .......104  |
|  clauses forward subsumed ........18  |
|  clauses back subsumed    .........9  |
+---------------------------------------+
(total run time 0.260 sec)
** found a counter example!
  initial state can reach to a hazardous state.
** Failed to prove safety of P.
 
(grand total time 13.288 sec)
\end{verbatim}
    }
\item 結果は, 検査仕様に示された通りである：
  \begin{itemize}
  \item 最終的に反例が示され, モデル検査が不成功に終った旨
    表示して, 検査を終了している.
  \end{itemize}
\end{itemize}

\subsection{不定終了の場合}
\label{sec:model-unknown-end}
モデル検査は一般に決定不能であるので, 事前に定められた計算資源の
使用量を超過した場合には, モデル検査システムを終了し,
検査に失敗した旨報告しなければならない.
本節はこれについて, 正しく実現されているかどうかの検査である.

\subsubsection{検査内容}
\begin{itemize}
\item 反駁システムのフラグ, パラメータによって, 推論に対する
  リソース制約条件を設定する:
  \begin{itemize}
  \item 実行時間の制約(max-seconds)
  \item given clause の数の制約(max-given)
  \end{itemize}
\item モデル検査システムの実行制約フラグ(inv-check-max-depth)を
  用いて, 遷移ステップ数の制約を設定する.
\item 以上の制約を施し, 適当な仕様を用意して, モデル検査を起動し,
  上記の制約によって実際に実行制約がかかり, 最終的に失敗で
  終了することを確認する.
\end{itemize}

\subsubsection{テストデータと手順}
\label{sec:model-unknown-data}
\begin{itemize}
\item したに示す内容のモジュール定義, スクリプトが入ったファイル
  ``model-unknown.mod'' を用意する：
{\small
\begin{verbatim}
**>
**> モデル検査不定終了の場合
**> 

set include FOPL-CLAUSE on

-- the natural numbers
mod! NATNUM
{
  [ NatNum ]
  op 0 : -> NatNum
  op s : NatNum -> NatNum
  pred _<_ : NatNum NatNum
  vars M N : NatNum
  ax ~(s(M) < M) .
  ax [SOS1]: ~(s(M) = 0) .
  ax [SOS]: M < s(M) .
  ax [SOS]: 0 < s(M) .
  ax ~(s(M) = M) .
  ax [SOS]: M = 0 | 0 < M .
  ax ~(0 < M)| ~(M = 0) . 
  ax ~(M = N & M < N) .
  ax ~(M < N & N < M) .
  ax ~(M < 0) .
  ax M = M .
}

-- the program counters
mod! STATUS
{
  [ Status ]
  ops non-CS wait CS : -> Status
  var S : Status
  ax (S = S) = true .
}

-- customers
mod* CUSTOMER1
{
  protecting(NATNUM + STATUS)
  *[ Customer1 ]*
  op init1 : -> Customer1
  -- attributes
  bop ticket1 : Customer1 -> NatNum
  bop stat1 : Customer1 -> Status
  -- methods
  bop run1 : Customer1 NatNum -> Customer1
  vars C C1 : Customer1  vars M N : NatNum
  eq stat1(init1) = non-CS .
  eq ticket1(init1) = 0 .
  ax stat1(C) = non-CS -> stat1(run1(C,M))= wait .
  ax stat1(run1(C,M))= wait 
     -> stat1(C) = non-CS | stat1(C) = wait .
  ax stat1(C) = non-CS -> ticket1(run1(C,M)) = s(M) .
  ax stat1(C) = wait & (M = 0 | ~(M < ticket1(C))) 
     -> stat1(run1(C,M)) = CS .
  ax stat1(run1(C,M)) = CS -> stat1(C) = wait .
  ax stat1(C) = wait & ~(M = 0) & M < ticket1(C) 
     -> stat1(run1(C,M)) = wait .
  ax stat1(C) = wait -> ticket1(run1(C,M)) = ticket1(C) .
  ax (stat1(C) = CS) = (stat1(run1(C,M)) = non-CS) .
  ax stat1(C) = CS -> ticket1(run1(C,M)) = 0 .
}

mod* CUSTOMER2
{
  protecting(NATNUM + STATUS)
  *[ Customer2 ]*
  op init2 : -> Customer2
  -- attributes
  bop ticket2 : Customer2 -> NatNum
  bop stat2 : Customer2 -> Status
  -- methods
  bop run2 : Customer2 NatNum -> Customer2
  vars C C1 : Customer2  var M : NatNum
  eq stat2(init2) = non-CS .
  eq ticket2(init2) = 0 .
  ax stat2(C) = non-CS -> stat2(run2(C,M))= wait .
  ax stat2(run2(C,M))= wait 
     -> stat2(C) = non-CS | stat2(C) = wait .
  ax stat2(C) = non-CS -> ticket2(run2(C,M)) = s(M) .
  ax stat2(C) = wait & (M = 0 | ticket2(C) < M) 
     -> stat2(run2(C,M)) = CS .
  ax stat2(run2(C,M)) = CS -> stat2(C) = wait .
  ax stat2(C) = wait & ~(M = 0) & ~(ticket2(C) < M) 
     -> stat2(run2(C,M)) = wait .
  ax stat2(C) = wait -> ticket2(run2(C,M)) = ticket2(C) .
  ax (stat2(C) = CS) = (stat2(run2(C,M)) = non-CS) .
  ax stat2(C) = CS -> ticket2(run2(C,M)) = 0 .
}

-- bakery algorithm
mod* SHOP
{
  protecting(CUSTOMER1 + CUSTOMER2)
  *[ Shop ]*
  op shop : Customer1 Customer2 -> Shop { coherent }
  bop Run1 : Shop -> Shop
  bop Run2 : Shop -> Shop
  bop Stat1 : Shop -> Status
  bop Stat2 : Shop -> Status
  bop Ticket1 : Shop -> NatNum
  bop Ticket2 : Shop -> NatNum
  op Init : -> Shop
  vars C1 D1 : Customer1   vars C2 D2 : Customer2
  var S : Shop   var B : Bool
  ax B = B .
  eq Init = shop(init1,init2) .
  beq Run1(shop(C1,C2)) = shop(run1(C1,ticket2(C2)),C2) .
  beq Run2(shop(C1,C2)) = shop(C1,run2(C2,ticket1(C1))) .
  eq Stat1(shop(C1,C2)) = stat1(C1) .
  eq Stat2(shop(C1,C2)) = stat2(C2) .
  eq Ticket1(shop(C1,C2)) = ticket1(C1) .
  eq Ticket2(shop(C1,C2)) = ticket2(C2) .
}

mod* PROOF
{

  protecting(SHOP)

  op c1 : -> Customer1 .
  op c2 : -> Customer2 .

  pred P : Shop .
  #define P(S:Shop) ::= ~(Stat1(S) = CS & Stat2(S) = CS) .

}

**> 反駁システムのオプション設定
option reset
flag(control-memory,on)
flag(kb2, on)
flag(back-unit-deletion, on)
flag(hyper-res, on)
flag(unit-deletion, on)
flag(factor, on)
flag(universal-symmetry,off)
flag(dist-const,on)
flag(input-sos-first,on)
**
param(max-proofs,1)
param(max-sos, 150)
param(pick-given-ratio, 4)
param(stats-level, 1)

**> 制約条件の設定
param(max-seconds, 1)
param(max-given, 50)
param(inv-check-max-depth, 4)

flag(quiet,on)
flag(print-proofs,off)
flag(print-stats,on)
**

open PROOF
db reset

**> SOS の設定
sos = { SOS SOS1 }

**> モデル検査の起動
--> check safety P of shop(c1,c2) from Init
check safety P of shop(c1,c2) from Init

close


\end{verbatim}
}
\end{itemize}

\subsubsection{実行結果}

\begin{enumerate}
\item 第\ref{sec:model-unknown-data}節で示されたファイル
  ``model-unknown.mod'' をシステムにロードした.
  結果は下に示す通りである：
  {\small
\begin{verbatim}
CafeOBJ> in model-unknown
processing input : ./model-unknown.mod
**> 
**> モデル検査不定終了の場合
**> 
-- defining module! NATNUM....._...........* done.
-- defining module! STATUS....._.* done.
-- defining module* CUSTOMER1_*........_...........*
** system failed to prove =*= is a congruence of CUSTOMER1 done.
-- defining module* CUSTOMER2_*........_...........*
** system failed to prove =*= is a congruence of CUSTOMER2 done.
-- defining module* SHOP_*.............._........*
** system failed to prove =*= is a congruence of SHOP done.
-- defining module* PROOF...._._* done.
**> 反駁システムのオプション設定
-- setting flag "control-memory" to "on"
-- setting flag "kb2" to "on"
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(process-input, on)
   dependent: flag(lrpo, on)
-- setting flag "back-unit-deletion" to "on"
   dependent: flag(unit-deletion, on)
-- setting flag "hyper-res" to "on"
-- setting flag "unit-deletion" to "on"
-- setting flag "factor" to "on"
-- setting flag "universal-symmetry" to "off"
-- setting flag "dist-const" to "on"
-- setting flag "input-sos-first" to "on"
-- setting parameter "max-proofs" to 1.
-- setting parameter "max-sos" to 150.
-- setting parameter "pick-given-ratio" to 4.
-- setting parameter "stats-level" to 1.
**> 制約条件の設定
-- setting parameter "max-seconds" to 1.
-- setting parameter "max-given" to 50.
-- setting parameter "inv-check-max-depth" to 4.
-- setting flag "quiet" to "on"
   dependent: flag(print-message, off)
-- opening module PROOF.. done.
**> SOS の設定
**> モデル検査の起動
--> check safety P of shop(c1,c2) from Init
==========
case #0-1: shop(c1,c2)
----------_
goal: P(shop(c1,c2))*
** Search stopped because SOS is empty.
 
** PigNose statistics ------------------+
|  clauses given            ........14  |
|  clauses generated        ........89  |
|  clauses kept             ........55  |
|  clauses forward subsumed ........20  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.050 sec)
** fail
** check with the initial state : Init_
goal: P(Init)*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........41  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.040 sec)
** ok, it's safe.
adding axiom: P(shop(c1,c2))
==========
case #1-1: Run1(shop(c1,c2))
----------
hypo: P(Run2(shop(c1,c2)))_
goal: P(Run1(shop(c1,c2)))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........50  |
|  clauses generated        .......782  |
|  clauses kept             .......138  |
|  clauses forward subsumed .......154  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.460 sec)
** fail
** check with the initial state : Run1(Init)_
goal: P(Run1(Init))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........46  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.020 sec)
** ok, it's safe.
==========
case #1-2: Run2(shop(c1,c2))
----------
hypo: P(Run1(shop(c1,c2)))_
goal: P(Run2(shop(c1,c2)))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........50  |
|  clauses generated        .......891  |
|  clauses kept             .......176  |
|  clauses forward subsumed .......237  |
|  clauses back subsumed    .........7  |
+---------------------------------------+
(total run time 0.570 sec)
** fail
** check with the initial state : Run2(Init)_
goal: P(Run2(Init))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........45  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.030 sec)
** ok, it's safe.
adding axiom: P(Run2(shop(c1,c2)))
adding axiom: P(Run1(shop(c1,c2)))
==========
case #2-1: Run1(Run1(shop(c1,c2)))
----------
hypo: P(Run1(Run2(shop(c1,c2))))
hypo: P(Run2(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))_
goal: P(Run1(Run1(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........50  |
|  clauses generated        .....1,390  |
|  clauses kept             .......281  |
|  clauses forward subsumed .......625  |
|  clauses back subsumed    .........3  |
+---------------------------------------+
(total run time 0.970 sec)
** fail
** check with the initial state : Run1(Run1(Init))_
goal: P(Run1(Run1(Init)))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........54  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.040 sec)
** ok, it's safe.
==========
case #2-2: Run1(Run2(shop(c1,c2)))
----------
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run2(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))_
goal: P(Run1(Run2(shop(c1,c2))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........7  |
|  clauses generated        ........64  |
|  clauses kept             ........78  |
|  clauses forward subsumed ........14  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.070 sec)
** success
==========
case #2-3: Run2(Run1(shop(c1,c2)))
----------
hypo: P(Run1(Run1(shop(c1,c2))))
hypo: P(Run2(Run2(shop(c1,c2))))_
goal: P(Run2(Run1(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........50  |
|  clauses generated        .......961  |
|  clauses kept             .......199  |
|  clauses forward subsumed .......200  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.540 sec)
** fail
** check with the initial state : Run2(Run1(Init))_
goal: P(Run2(Run1(Init)))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........1  |
|  clauses generated        .........3  |
|  clauses kept             ........58  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.040 sec)
** ok, it's safe.
==========
case #2-4: Run2(Run2(shop(c1,c2)))
----------
hypo: P(Run2(Run1(shop(c1,c2))))
hypo: P(Run1(Run1(shop(c1,c2))))_
goal: P(Run2(Run2(shop(c1,c2))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........50  |
|  clauses generated        .....1,456  |
|  clauses kept             .......247  |
|  clauses forward subsumed .......532  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.940 sec)
** fail
** check with the initial state : Run2(Run2(Init))_
goal: P(Run2(Run2(Init)))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........1  |
|  clauses kept             ........51  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.050 sec)
** ok, it's safe.
adding axiom: P(Run2(Run2(shop(c1,c2))))
adding axiom: P(Run2(Run1(shop(c1,c2))))
adding axiom: P(Run1(Run1(shop(c1,c2))))
==========
case #3-1: Run1(Run1(Run1(shop(c1,c2))))
----------
hypo: P(Run1(Run1(Run2(shop(c1,c2)))))
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))
hypo: P(Run2(Run1(Run2(shop(c1,c2)))))
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run1(Run1(Run1(shop(c1,c2)))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........19  |
|  clauses generated        .......140  |
|  clauses kept             .......105  |
|  clauses forward subsumed ........24  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.150 sec)
** success
==========
case #3-2: Run1(Run1(Run2(shop(c1,c2))))
----------
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))
hypo: P(Run2(Run1(Run2(shop(c1,c2)))))
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run1(Run1(Run2(shop(c1,c2)))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........33  |
|  clauses generated        .......602  |
|  clauses kept             .......178  |
|  clauses forward subsumed .......137  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.390 sec)
** success
==========
case #3-3: Run2(Run1(Run1(shop(c1,c2))))
----------
hypo: P(Run2(Run1(Run2(shop(c1,c2)))))
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run2(Run1(Run1(shop(c1,c2)))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........50  |
|  clauses generated        .....1,351  |
|  clauses kept             .......263  |
|  clauses forward subsumed .......406  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.840 sec)
** fail
** check with the initial state : Run2(Run1(Run1(Init)))_
goal: P(Run2(Run1(Run1(Init))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........2  |
|  clauses generated        ........28  |
|  clauses kept             ........70  |
|  clauses forward subsumed .........5  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.060 sec)
** ok, it's safe.
==========
case #3-4: Run2(Run1(Run2(shop(c1,c2))))
----------
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run2(Run1(Run2(shop(c1,c2)))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........28  |
|  clauses generated        .......326  |
|  clauses kept             .......147  |
|  clauses forward subsumed ........65  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.270 sec)
** success
==========
case #3-5: Run2(Run2(Run1(shop(c1,c2))))
----------
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))
hypo: P(Run2(Run2(Run2(shop(c1,c2)))))_
goal: P(Run2(Run2(Run1(shop(c1,c2)))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........50  |
|  clauses generated        .....1,290  |
|  clauses kept             .......237  |
|  clauses forward subsumed .......485  |
|  clauses back subsumed    .........3  |
+---------------------------------------+
(total run time 0.700 sec)
** fail
** check with the initial state : Run2(Run2(Run1(Init)))_
goal: P(Run2(Run2(Run1(Init))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........1  |
|  clauses generated        .........3  |
|  clauses kept             ........64  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.080 sec)
** ok, it's safe.
==========
case #3-6: Run2(Run2(Run2(shop(c1,c2))))
----------
hypo: P(Run2(Run2(Run1(shop(c1,c2)))))
hypo: P(Run2(Run1(Run1(shop(c1,c2)))))_
goal: P(Run2(Run2(Run2(shop(c1,c2)))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........20  |
|  clauses generated        .......160  |
|  clauses kept             .......101  |
|  clauses forward subsumed ........26  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.150 sec)
** success
adding axiom: P(Run2(Run2(Run1(shop(c1,c2)))))
adding axiom: P(Run2(Run1(Run1(shop(c1,c2)))))
==========
case #4-1: Run2(Run1(Run1(Run1(shop(c1,c2)))))
----------
hypo: P(Run2(Run1(Run1(Run2(shop(c1,c2))))))
hypo: P(Run2(Run2(Run1(Run1(shop(c1,c2))))))
hypo: P(Run2(Run2(Run1(Run2(shop(c1,c2))))))_
goal: P(Run2(Run1(Run1(Run1(shop(c1,c2))))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........43  |
|  clauses generated        .......665  |
|  clauses kept             .......248  |
|  clauses forward subsumed .......149  |
|  clauses back subsumed    .........1  |
+---------------------------------------+
(total run time 0.560 sec)
** success
==========
case #4-2: Run2(Run1(Run1(Run2(shop(c1,c2)))))
----------
hypo: P(Run2(Run2(Run1(Run1(shop(c1,c2))))))
hypo: P(Run2(Run2(Run1(Run2(shop(c1,c2))))))_
goal: P(Run2(Run1(Run1(Run2(shop(c1,c2))))))*
** Search stopped due to max-seconds option.
 
** PigNose statistics ------------------+
|  clauses given            ........49  |
|  clauses generated        .....1,509  |
|  clauses kept             .......262  |
|  clauses forward subsumed .......342  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 1.020 sec)
** fail
** check with the initial state : Run2(Run1(Run1(Run2(Init))))_
goal: P(Run2(Run1(Run1(Run2(Init)))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........18  |
|  clauses generated        .......315  |
|  clauses kept             .......125  |
|  clauses forward subsumed ........38  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.300 sec)
** ok, it's safe.
==========
case #4-3: Run2(Run2(Run1(Run1(shop(c1,c2)))))
----------
hypo: P(Run2(Run1(Run1(Run2(shop(c1,c2))))))
hypo: P(Run2(Run2(Run1(Run2(shop(c1,c2))))))_
goal: P(Run2(Run2(Run1(Run1(shop(c1,c2))))))*
** Search stopped due to max-seconds option.
 
** PigNose statistics ------------------+
|  clauses given            ........48  |
|  clauses generated        .....1,540  |
|  clauses kept             .......262  |
|  clauses forward subsumed .......471  |
|  clauses back subsumed    .........3  |
+---------------------------------------+
(total run time 1.000 sec)
** fail
** check with the initial state : Run2(Run2(Run1(Run1(Init))))_
goal: P(Run2(Run2(Run1(Run1(Init)))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........30  |
|  clauses generated        .......580  |
|  clauses kept             .......147  |
|  clauses forward subsumed ........80  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.440 sec)
** ok, it's safe.
==========
case #4-4: Run2(Run2(Run1(Run2(shop(c1,c2)))))
----------
hypo: P(Run2(Run2(Run1(Run1(shop(c1,c2))))))
hypo: P(Run2(Run1(Run1(Run2(shop(c1,c2))))))_
goal: P(Run2(Run2(Run1(Run2(shop(c1,c2))))))*
** Search stopped due to max-given option.
 
** PigNose statistics ------------------+
|  clauses given            ........50  |
|  clauses generated        .......820  |
|  clauses kept             .......216  |
|  clauses forward subsumed .......213  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.550 sec)
** fail
** check with the initial state : Run2(Run2(Run1(Run2(Init))))_
goal: P(Run2(Run2(Run1(Run2(Init)))))*
** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........1  |
|  clauses generated        .........3  |
|  clauses kept             ........68  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.070 sec)
** ok, it's safe.
adding axiom: P(Run2(Run2(Run1(Run2(shop(c1,c2))))))
adding axiom: P(Run2(Run2(Run1(Run1(shop(c1,c2))))))
adding axiom: P(Run2(Run1(Run1(Run2(shop(c1,c2))))))
-- stopping invariance check due to `inv-check-max-depth'
** Failed to prove safety of P.
 
(grand total time 15.387 sec)
\end{verbatim}
    }
\item 上のログを見て分かる通り,
  max-seconds, あるいは max-given の制約によって,
  推論の中断が正しく行われていることが分かる.

  また, inv-check-max-depth の設定が 4 であったため,
  最終的に第4ステップを終えた後に, モデル検査が中断され,
  その旨が表示されている.  そのため結果「不成功」に終っている.

\item 以上の結果は検査仕様で予期された通りである.

\end{enumerate}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
