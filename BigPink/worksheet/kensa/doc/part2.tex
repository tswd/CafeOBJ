\part{反駁システム検査仕様・結果}
\label{sec:refutation-engine}

反駁システムは, 主として表\ref{tab:system-functions}の 
2 項(検証に必要な両模擬関係の自動生成機能)と,
5 項(モデル検査の対象となる性質を記述する論理系の記号処理機能)
に対応するものである.
このシステムは, 他の2つのサブシステム「仕様検証システム」,
および「モデル検査システム」の機能を実現する上で必要となる
(多ソート)一階述語論理系における問題定義ならびに定理証明エンジンと, 
これを使用するためのスクリプト言語を提供するものとなっている.
このサブシステムは, 検証推論システムの中核をなす実行主体となっており, 
システムの基本的な機能を担うものである.
システムの検査においては, 反駁エンジンが他の2サブシステムに必要な
定理証明機能を過不足無く提供しているかどうかを検査する事が
重要である. したがって, 反駁エンジンに関する検査, 特に 5 項
(モデル検査の対象となる性質を記述する論理系の記号処理機能)については
必要機能を細分化して, 検査項目を立てる事とする.

\section{両模擬関係}
\label{sec:bi-simular}
機能第2項(検証に必要な両模擬関係の自動生成機能 -- 表\ref{tab:system-functions})
に対する検査項目と, その結果, 並びに各検査項目の具体的な内容について述べる.

\subsection{検査項目}
\label{sec:bi-sim-test-item}
検査項目は以下の通りである：
\begin{enumerate}
\item 両模擬関係オペレータの自動生成\\
  両模擬関係を定義するオペレータ \verb:_=*=_: を
  隠れソートを含むモジュールを定義した際に, システムが
  適切に自動生成しているかどうかを検査する.

\item 両模擬関係オペレータ公理の自動生成\\
  両模擬関係を表現するオペレータ \verb:_=*=_:が, 同等関係
  (congruence) あることが解った場合に, 
  この関係を定義するような公理が自動宣言されているかどうかを検査する.
  また, そうでない場合は, システムはこれに関する公理をなにも生成しないことを
  検査する.
\end{enumerate}

\subsection{検査結果一覧}
\label{sec:bi-sim-res-all}
検査結果は表 \ref{tab:bi-sim-test}に示す通りである.
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}[h]{|l|c|c|} \hline
      検査項目 & 結果 & 該当章番号 \\\hline
      両模擬関係オペレータの自動生成 & ○ & \ref{sec:bi-sim-op} \\
      両模擬関係オペレータ公理の自動生成 & ○ & \ref{sec:bi-sim-ax} \\
      \hline
    \end{tabular}
    \caption{両模擬関係検査結果一覧}
    \label{tab:bi-sim-test}
  \end{center}
\end{table}

\subsection{両模擬関係オペレータの自動生成}
\label{sec:bi-sim-op}
\subsubsection{検査内容}

\begin{enumerate}
\item 隠れソートを宣言しているモジュールをシステムにロードし,
  オペレータ \verb:_=*=_: が隠れソートに関して定義されているかどうか
  を検査する.
  隠れソート $H$ に関して,
\begin{verbatim}
  op _=*=_ : H H  -> Bool
\end{verbatim}
  の形のオペレータが宣言されていなければならない.
  これはインタプリタのコマンド \verb:describe op: によって,
  このオペレータに関する情報を見る事よって確認する.


\item また, システムが組込みで持っている, 隠れソートに関する一般的な両模擬関係
  \verb:_=*=_: とのオーバロードが適切に行われていなければならない.
  つまり, これより下位のオペレータとなっていなければならない.
  これも, インタプリタのコマンド \verb:describe op: によって確認する.

\item このオペレータが実際に有効であることは, これを含む適当な項が
  システムによって正しくパーズされることを確認することで行う
  (インタプリタの \verb:parse: コマンドを用いる).

\end{enumerate}

\subsubsection{テストデータと手順}
\label{sec:bi-sim-op-test-data}
試験には下に示すモジュール宣言, 及び試験のためのコマンドを
ファイル ``bisim-optest.mod'' に書き込み, 
インタプリタにロードする事によって実施する.
{\small
\begin{verbatim}
**
** 両模擬関係オペレータの自動生成検査
**

mod* BISIMOP
{
  protecting(NAT)
  [ Elt ]
  -- 隠れソートの宣言
  *[ Bag ]*

  op empty :  -> Bag 
  -- メソッド
  bop put : Elt Bag -> Bag    -- method 
  bop take : Elt Bag -> Bag   -- method
  -- アトリビュート
  bop get : Bag Elt -> Nat    -- attribute

  vars E E' : Elt
  var B : Bag 

  eq get(empty, E) = 0 .
  cq get(put(E, B), E')  =  get(B, E')   if E =/= E' .
  eq get(put(E, B), E)   = s(get(B, E)) . 
  cq get(take(E, B), E') =  get(B, E')   if E =/= E' .
  eq get(take(E, B), E)  = p(get(B, E)) .

}

select BISIMOP

**> _=*=_ が自動生成されているかどうかの確認
**> generic な _=*=_ とオーバロードしていることも確認する:
describe op _=*=_

**> _=*=_ を含む項をパーズして，オペレータがきちんと定義されて
**> いるかどうかを確認する:
parse b1:Bag =*= b1 .
parse put(e:Elt, b1:Bag) =*= put(e, b2:Bag) .
parse take(e:Elt, b1:Bag) =*= take(e, b2:Bag) .

**
eof


\end{verbatim}
}

\subsubsection{実行結果}
前節(第\ref{sec:bi-sim-op-test-data}節)で述べたテストデータを
書き込んだファイル ``bisim-optest.mod'' をインタプリタに
読み込んだ. 結果のログを以下に示す.
{\small
\begin{verbatim}
CafeOBJ> in bisim-optest
processing input : ./bisim-optest.mod
-- defining module* BISIMOP ..........done
[Warning]: axiom : get(take(E,B),E) = p get(B,E)
    contains error operators..*
** system failed to prove =*= is a congruence of BISIMOP done.
**> _=*=_ が自動生成されているかどうかの確認
**> generic な _=*=_ とオーバロードしていることも確認する:
============================================================
name                : _=*=_
module              : TRUTH
number of arguments : 2
default attributes  :
 rewrite strategy   : not specified
 syntax             :
   precedence       : not specified
   computed prec.   : 41
   form             : (arg:51) "=*=" (arg:51) 
 theory             : 
------------------------------------------------------------
rank                : ?Bag ?Bag -> ?Bool
  module            : BISIMOP
  theory            : 
  rewrite strategy  : (1 2 0)
  precedence        : 51
  lower oprations   :
    Bag Bag -> Bool
  axioms            :
------------------------------------------------------------
rank                : Bag Bag -> Bool
  module            : BISIMOP
  theory            : 
  rewrite strategy  : (1 2 0)
  precedence        : 51
  axioms            :
------------------------------------------------------------
rank                : _ HUniversal _ _ HUniversal _ -> Bool
  module            : TRUTH
  theory            : 
  rewrite strategy  : (1 2 0)
  precedence        : 51
  lower oprations   :
    ?Bag ?Bag -> ?Bool
    Bag Bag -> Bool
  axioms            :
**> _=*=_ を含む項をパーズして，オペレータがきちんと定義されて
**> いるかどうかを確認する:
(b1 =*= b1) : Bool
(put(e,b1) =*= put(e,b2)) : Bool
(take(e,b1) =*= take(e,b2)) : Bool
BISIMOP> 
\end{verbatim}
}
上の通り正しい結果となった.

\subsection{両模擬関係オペレータ公理の自動生成}
\label{sec:bi-sim-ax}
\subsubsection{検査内容}
\begin{enumerate}
\item 隠れソートに関するソートを宣言しているモジュールを
  システムにロードする. CafeOBJ インタプリタは, 
  オペレータ \verb:_=*=_: が合同関係(congruence) であることを
  自動的に検査するが，結果として合同関係であるとなった際に,
  \verb:_=*=_: が, 具体的にどのような条件を満足する時に
  \verb:A =*= B: が言えるのかの定義を公理の形で自動生成
  しなければならない．

  具体的には, ある隠れソート $H$ のインスタンス $h1$ と 
  $h2$ に関して, 
\begin{verbatim}
  h1 =*= h2 = true if a_1(h1) == a_1(h2) and
                      a_2(h1) == a_2(h2) and
                              :
                      a_n(h1) == a_n(h2) .
\end{verbatim}
  という形の条件付き等式を生成しなければならない.
  ここで, 各 \verb:ai: は $H$ のアトリビュートである.

  検査では, \verb:_=*=_: が合同関係となるようなモジュールを
  定義し, 実際に公理が自動生成されているかどうかを,
  インタプリタの \verb:show: コマンドを用いてモジュール内容を
  見る事によって確認する.

\item 上の 1 のような, 合同関係にならない場合には, 
  公理の自動追加があってはならない. 
  このことを, \verb:_=*=_: が合同関係となならないような
  モジュールを定義し, 同じく \verb:show: コマンドを用いて
  モジュール内容を見る事によって確認する.
\end{enumerate}

\subsubsection{テストデータと手順}
下に示すテストデータを, ファイル ``bisim-ax.mod'' に書き込み,
インタプリタにロードすることによって結果を確認する.

{\small
\begin{verbatim}
**>
**> 両模擬関係試験-1: 公理の自動生成
**> 

**> _=*=_ が合同関係になるケース
**> 公理が自動生成されていなければならない．

mod* BISIM-AX-1 (X :: TRIV) 
{
  *[ H ]*
  op method : Elt H -> H
  bop a1 : H Elt -> Elt
  bop a2 : H Elt Elt -> Elt
  bop a3 : Elt H -> Elt
  bop a4 : Elt H -> Elt
}

**> システムは _=*=_ が congruence であるとメッセージを出しているはず．
**> 実際に公理が追加されているかどうかを show コマンドで調べる．
show BISIM-AX-1

**> 次の例は _=*=_ が合同関係にはならないケース
**> 公理の追加があってはならない．

mod* BISIM-AX-2 (X :: TRIV) 
{
  
  *[ H ]*

  op zero : -> Elt
  op empty :  -> H 
  -- メソッド
  bop put : Elt H -> H    -- method 
  bop take : Elt H -> H   -- method
  -- アトリビュート
  bop get : H Elt -> Elt    -- attribute

  vars E E' : Elt
  var B : H 

  eq get(empty, E) = zero .
  cq get(put(E, B), E')  =  get(B, E')   if E =/= E' .
  eq get(put(E, B), E)   = get(B, E) . 
  cq get(take(E, B), E') =  get(B, E')   if E =/= E' .
  eq get(take(E, B), E)  = get(B, E) .
}

**> show で確認する．
show BISIM-AX-2

\end{verbatim}
}

\subsubsection{実行結果}
前節で定義したファイル ``bisim-ax.mod'' をシステムにロードした
結果のログを以下に示す.
{\small
\begin{verbatim}
CafeOBJ> in bisim-ax
processing input : ./bisim-ax.mod
**> 
**> 両模擬関係試験-1: 公理の自動生成
**> 
**> _=*=_ が合同関係になるケース
**> 公理が自動生成されていなければならない．
-- defining module* BISIM-AX-1_*_*......._*
** system already proved =*= is a congruence of BISIM-AX-1 done.
**> システムは _=*=_ が congruence であるとメッセージを出しているはず．
**> 実際に公理が追加されているかどうかを show コマンドで調べる．
module* BISIM-AX-1 (X :: TRIV)
{
  imports {
    protecting (BOOL)
  }
  signature {
    *[ H ]*
    op method : Elt H -> H
    bop a1 : H Elt -> Elt
    bop a2 : H Elt Elt -> Elt
    bop a3 : Elt H -> Elt
    bop a4 : Elt H -> Elt
  }
  axioms {
    ceq hs1:H =*= hs2:H = true if a4(vs18:Elt,hs1:H) == a4(vs18,
                                                           hs2:H) 
                                  and a3(vs14:Elt,hs1) == a3(vs14,
                                                             hs2) 
                                  and a2(hs1,vs6:Elt,vs8:Elt) 
                                      == a2(hs2,vs6,vs8) and 
                                  a1(hs1,vs2:Elt) == a1(hs2,
                                                        vs2) .
  }
}
**> 次の例は _=*=_ が合同関係にはならないケース
**> 公理の追加があってはならない．
-- defining module* BISIM-AX-2_*_*........._.....*
** system failed to prove =*= is a congruence of BISIM-AX-2 done.
**> show で確認する．
module* BISIM-AX-2 (X :: TRIV)
{
  imports {
    protecting (BOOL)
  }
  signature {
    *[ H ]*
    op zero : -> Elt
    op empty : -> H
    bop put : Elt H -> H
    bop take : Elt H -> H
    bop get : H Elt -> Elt { strat: (1 0 2) }
  }
  axioms {
    var E : Elt
    var E' : Elt
    var B : H
    eq get(empty,E) = zero .
    ceq get(put(E,B),E') = get(B,E') if E =/= E' .
    eq get(put(E,B),E) = get(B,E) .
    ceq get(take(E,B),E') = get(B,E') if E =/= E' .
    eq get(take(E,B),E) = get(B,E) .
  }
}
CafeOBJ> 
\end{verbatim}
}

上の通り正しい結果が得られた．

%%%%%%%
\section{論理系の記号処理機能の検査について}
\label{sec:engine}
本章以降では, 機能第5項 -- モデル検査の対象となる性質を記述する論理系の記号
処理機能(表\ref{tab:system-functions}を参照) に対する検査項目と, 結果,
並びに各検査項目の具体的な内容について述べる.

先に述べた通り, この機能は他のサブシステムの機能を実現するのに必要となる
基本的な機能を提供するものであり, その具体的な機能は多岐に渡る.
そのため本機能に関しては, それを下記に示す2つのカテゴリに大きく分割し, 
それぞれについて別個の章立てとした検査項目を立てる事によって, 
検査仕様ならびに結果を示す事とする. 

\begin{itemize}
\item 一階述語文による記述機能 \\
  (多ソート)一階述語論理の文による公理や宣言文の記述を,
  従来の CafeOBJ 項の記述と合わせて使用できるようにする機能.

\item 定理証明機能 \\
  CafeOBJ モジュールを実行文脈として, ある一階述語論理の文が
  モジュールで記述された公理からの論理的帰結となるのかどうかを
  証明する機能.

\end{itemize}

%%%%%
\section{一階述語文による記述機能}
\subsection{検査項目}
\begin{itemize}
\item 一階述語文の記述 \\
  モジュールにおいて, 一階述語文による公理の宣言等,
  一階述語の文が正しく受け付けられるか否かを検査する.
\item FOPL-CLAUSE モジュールの自動輸入\\
  組み込みの FOPL-CLAUSE モジュールの自動的輸入の機能が
  正しく実現されているか否かを検査する.
\item 節形式への変換 \\
  通常の等式や一階述語文による公理が, 反駁システムのエンジンで
  処理可能とするための, 節形式への変換が正しく行われること
  を検査する.
\end{itemize}

\subsection{検査結果一覧}
検査結果は表 \ref{tab:fopl-res}に示す通りである.
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}[h]{|l|c|c|} \hline
      検査項目 & 結果 & 該当章番号 \\\hline
      一階述語文の記述 & ○ & \ref{sec:fopl-axiom} \\
      FOPL-CLAUSE モジュールの自動輸入 & ○ & \ref{sec:fopl-import} \\
      節形式への変換 & ○ & \ref{sec:fopl-trans} \\\hline
    \end{tabular}
    \caption{一階述語文による記述機能検査結果一覧}
    \label{tab:fopl-res}
  \end{center}
\end{table}

\subsection{一階述語文の記述}
\label{sec:fopl-axiom}
\subsubsection{検査内容}
\begin{enumerate}
\item 一階述語の文の入力\\
  通常の項に加えて, 一階述語文が入力可能であることを確認する.
\item 一階述語文による公理宣言\\
  通常の等式に併せて, CafeOBJ モジュール内で
  一階述語の文による公理の宣言が正しく受け付けられることを
  確認する.
\end{enumerate}
具体的なテストデータと, 実行手順については次節を参照されたい.

\subsubsection{テスト手順と手順}
\label{sec:fopl-input-data}
\begin{enumerate}
\item 一階述語文の入力
  \begin{enumerate}
  \item  下に示すような内容のスクリプトを書き込んだファイル
    ``fopl-input.mod'' を用意する.
    {\small
\begin{verbatim}
**>
**> FOPL 文入力に関する検査
**>

**> 例として用いる組み込みの NAT をオープンする
open NAT

**> FOPL 文の入力を可能とするため, FOPL-CLAUSE を輸入
protecting(FOPL-CLAUSE)

**> 検査に使用する命題や述語を宣言する.
--> ops p q r : -> Bool .
--> pred P : Nat .
--> pred Q : Nat .
--> pred R : Nat Nat .
--> pred S : Nat Nat .
--> op  a   : -> Nat .

ops p q r : -> Bool .
pred P : Nat .
pred Q : Nat .
pred R : Nat Nat .
pred S : Nat Nat .
op  a   : -> Nat .

**> FOPL 文の入力試験
--> let t1 = (p -> q) -> (q -> r) .
let t1 = (p -> q) -> (q -> r) .

--> let t2 = \A[X2:Nat]\E[Y1:Nat]\A[X1:Nat]\E[Y2:Nat]R(X1,Y1) & S(X2,Y2) .
let t2 = \A[X2:Nat]\E[Y1:Nat]\A[X1:Nat]\E[Y2:Nat]R(X1,Y1) & S(X2,Y2) .

--> let t3 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) &
-->          (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
let t3 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) &
         (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
--> let t4 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) |
-->          (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
let t4 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) |
         (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .

--> let t5 = \A[X:Nat]P(X) -> 
-->                   (\E[Y:Nat](R(X,Y) -> P(a)) & 
-->                             (\A[Z:Nat]R(Y,Z) -> P(X))) .
let t5 = \A[X:Nat]P(X) -> 
                   (\E[Y:Nat](R(X,Y) -> P(a)) & 
                             (\A[Z:Nat]R(Y,Z) -> P(X))) .

**> 入力された FOPL 文の表示
**> t1 : 
-->
show term t1 .
**> t2 : 
-->
show term t2 .
**> t3 :
-->
show term t3 .
**> t4 : 
-->
show term t4
**> t5 : 
-->
show term t5
**
close
--
eof
\end{verbatim}
      }
  \end{enumerate}
  \item 出力結果を見て, 正しく項が受け付けられている事を
    確認する.
\item 一階述語文による公理宣言
  \begin{enumerate}
  \item 下に示す内容のスクリプトを入れたファイル
    ``fopl-axiom'' を用意する.
    {\small
\begin{verbatim}
**>
**> FOPL 文による公理の宣言機能検査
**>

**> 例として用いる組み込みの NAT をオープンする
open NAT

**> FOPL 文の入力を可能とするため, FOPL-CLAUSE を輸入
protecting(FOPL-CLAUSE)

**> 検査に使用する命題や述語を宣言する.
--> ops p q r : -> Bool .
--> pred P : Nat .
--> pred Q : Nat .
--> pred R : Nat Nat .
--> pred S : Nat Nat .
--> op  a   : -> Nat .

ops p q r : -> Bool .
pred P : Nat .
pred Q : Nat .
pred R : Nat Nat .
pred S : Nat Nat .
op  a   : -> Nat .

**> FOPL 文による公理宣言.
--> ax[t1]: (p -> q) -> (q -> r) .
ax[t1]: (p -> q) -> (q -> r) .

--> ax[t2]: \A[X2:Nat]\E[Y1:Nat]\A[X1:Nat]\E[Y2:Nat]R(X1,Y1) & S(X2,Y2) .
ax[t2]: \A[X2:Nat]\E[Y1:Nat]\A[X1:Nat]\E[Y2:Nat]R(X1,Y1) & S(X2,Y2) .

--> goal[t3]: (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) &
-->          (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
goal[t3]: (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) &
          (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
--> goal[t4]: (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) |
-->           (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
goal[t4]: (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) |
          (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .

--> ax[t5] \A[X:Nat]P(X) -> 
-->                 (\E[Y:Nat](R(X,Y) -> P(a)) & 
-->                           (\A[Z:Nat]R(Y,Z) -> P(X))) .
ax[t5]: \A[X:Nat]P(X) -> 
           (\E[Y:Nat](R(X,Y) -> P(a)) & 
                     (\A[Z:Nat]R(Y,Z) -> P(X))) .

**> モジュールを表示し, 上記の公理が正しく受け付けられて
**> いること確認する.
show .
**
close
--
eof

\end{verbatim}
      }
  \item システム出力の最後のモジュール表示により, 
    ラベルを付けて宣言された各一階述語の文による公理が正しく
    認識されていることを確認する.
  \end{enumerate}
\end{enumerate}

\subsubsection{実行結果}
\begin{enumerate}
\item 一階述語の文の入力
\begin{enumerate}
  \item 第\ref{sec:fopl-input-data}節の第1項で示されたファイル
    ``fopl-input.mod'' をシステムにロードした.
    結果のログを下に示す：
    {\small
\begin{verbatim}
CafeOBJ> in fopl-input
processing input : ./fopl-input.mod
**> 
**> FOPL 文入力に関する検査
**> 
**> 例として用いる組み込みの NAT をオープンする
-- opening module NAT.. done.
**> FOPL 文の入力を可能とするため, FOPL-CLAUSE を輸入
**> 検査に使用する命題や述語を宣言する.
--> ops p q r : -> Bool .
--> pred P : Nat .
--> pred Q : Nat .
--> pred R : Nat Nat .
--> pred S : Nat Nat .
--> op  a   : -> Nat .
**> FOPL 文の入力試験
--> let t1 = (p -> q) -> (q -> r) ._
--> let t2 = \A[X2:Nat]\E[Y1:Nat]\A[X1:Nat]\E[Y2:Nat]R(X1,Y1) & S(X2,Y2) .
--> let t3 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) &
-->          (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
--> let t4 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) |
-->          (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
--> let t5 = \A[X:Nat]P(X) -> 
-->                   (\E[Y:Nat](R(X,Y) -> P(a)) & 
-->                             (\A[Z:Nat]R(Y,Z) -> P(X))) .
**> 入力された FOPL 文の表示
**> t1 : 
--> 
((p -> q) -> (q -> r)) : FoplSentence
**> t2 : 
--> 
(\A [ X2:Nat ] (\E [ Y1:Nat ] (\A [ X1:Nat ] (\E [ Y2:Nat ] (R(X1,
                                                               Y1) &
                                                              S(X2,
                                                                Y2)))))) : 
    FoplSentence
**> t3 :
--> 
((\A [ X:Nat ] (P(X) -> (\E [ Y:Nat ] R(X,Y)))) & (\A [ X ] ((~
                                                               P(X)) ->
                                                              (~
                                                                (\E
                                                                  [
                                                                  Y ]
                                                                  R(X,
                                                                    Y)))))) : 
    FoplSentence
**> t4 : 
--> 
((\A [ X:Nat ] (P(X) -> (\E [ Y:Nat ] R(X,Y)))) | (\A [ X ] ((~
                                                               P(X)) ->
                                                              (~
                                                                (\E
                                                                  [
                                                                  Y ]
                                                                  R(X,
                                                                    Y)))))) : 
    FoplSentence
**> t5 : 
--> 
(\A [ X:Nat ] (P(X) -> (\E [ Y:Nat ] ((R(X,Y) -> P(a)) & (\A
                                                           [
                                                           Z:Nat ]
                                                           (R(Y,
                                                              Z) ->
                                                             P(X))))))) : 
    FoplSentence
\end{verbatim}
      }
  \item 上記の結果をみて了解されるように, 各 let 変数 t1 〜 t5 に束縛
    された一階述語文は正しくパーズされ, システムが認識している.
  \end{enumerate}
\item 一階述語文による公理宣言
  \begin{enumerate}
  \item 第\ref{sec:fopl-input-data}節の第2項で示されたファイル
    ``fopl-axioms.mod'' をシステムにロードした.
    結果のログを下に示す：
    {\small
\begin{verbatim}
CafeOBJ> in fopl-axioms
processing input : ./fopl-axioms.mod
**> 
**> FOPL 文による公理の宣言機能検査
**> 
**> 例として用いる組み込みの NAT をオープンする
-- opening module NAT.. done.
**> FOPL 文の入力を可能とするため, FOPL-CLAUSE を輸入
**> 検査に使用する命題や述語を宣言する.
--> ops p q r : -> Bool .
--> pred P : Nat .
--> pred Q : Nat .
--> pred R : Nat Nat .
--> pred S : Nat Nat .
--> op  a   : -> Nat .
**> FOPL 文による公理宣言.
--> ax[t1]: (p -> q) -> (q -> r) ._
--> ax[t2]: \A[X2:Nat]\E[Y1:Nat]\A[X1:Nat]\E[Y2:Nat]R(X1,Y1) & S(X2,Y2) .
--> goal[t3]: (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) &
-->          (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
--> goal[t4]: (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) |
-->           (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
--> ax[t5] \A[X:Nat]P(X) -> 
-->                 (\E[Y:Nat](R(X,Y) -> P(a)) & 
-->                           (\A[Z:Nat]R(Y,Z) -> P(X))) .
**> モジュールを表示し, 上記の公理が正しく受け付けられて
**> いること確認する.*
module! NAT
      principal-sort Nat
{ ** opening
  imports {
    protecting (NZNAT)
    protecting (NAT-VALUE)
    protecting (FOPL-CLAUSE)
  }
  signature {
    op s _ : Nat -> NzNat { prec: 15 }
    pred _ >= _ : Nat Nat  { meta-demod prec: 51 }
    pred _ > _ : Nat Nat  { meta-demod prec: 51 }
    pred _ <= _ : Nat Nat  { meta-demod prec: 51 }
    pred _ < _ : Nat Nat  { meta-demod prec: 51 }
    op _ quo _ : Nat NzNat -> Nat { prec: 31 l-assoc }
    op _ * _ : Nat Nat -> Nat { assoc comm idr: 1 prec: 31 r-assoc
                                }
    op _ + _ : Nat Nat -> Nat { assoc comm idr: 0 prec: 33 r-assoc
                                }
    op sd : Nat Nat -> Nat { comm prec: 0 }
    op _ rem _ : Nat NzNat -> Nat { prec: 31 l-assoc }
    pred _ divides _ : NzNat Nat  { meta-demod prec: 51 }
    op p _ : NzNat -> Nat { prec: 15 }
    pred p : 
    pred q : 
    pred r : 
    pred P : Nat 
    pred Q : Nat 
    pred R : Nat Nat 
    pred S : Nat Nat 
    op a : -> Nat
  }
  axioms {
    var M : Nat
    var N : Nat
    var NN : NzNat
    eq sd(M,N) = #! (abs (- m n)) .
    eq M + N = #! (+ m n) .
    eq N * 0 = 0 .
    eq M quo NN = #! (truncate m nn) .
    eq M rem NN = #! (rem m nn) .
    eq NN divides M = #! (= 0 (rem m nn)) .
    eq N < 0 = false .
    eq 0 < NN = true .
    eq NN <= 0 = false .
    eq 0 <= N = true .
    eq 0 > N = false .
    eq NN > 0 = true .
    eq 0 >= NN = false .
    eq N >= 0 = true .
    eq s 0 = 1 .
    eq p NN = #! (- nn 1) .
    eq [ident4] : 0 + X-ID:Nat = X-ID:Nat .
    eq [ident5] : 1 * X-ID:Nat = X-ID:Nat .
    ax [t1] : (p -> q) -> (q -> r) .
    ax [t2] : \A [ X2:Nat ] (\E [ Y1:Nat ] (\A [ X1:Nat ] (\E 
                                                           [ 
                                                           Y2:Nat 
                                                           ] 
                                                           R(X1,
                                                             Y1) 
                                                           & 
                                                           S(X2,
                                                             Y2)))) .
    goal [t3] : (\A [ X:Nat ] P(X) -> (\E [ Y:Nat ] R(X,Y))) 
                & (\A [ X ] ~ P(X) -> ~ (\E [ Y ] R(X,Y))) .
    goal [t4] : (\A [ X:Nat ] P(X) -> (\E [ Y:Nat ] R(X,Y))) 
                | (\A [ X ] ~ P(X) -> ~ (\E [ Y ] R(X,Y))) .
    ax [t5] : \A [ X:Nat ] P(X) -> (\E [ Y:Nat ] (R(X,Y) -> 
                                                  P(a)) & (\A 
                                                           [ 
                                                           Z:Nat 
                                                           ] 
                                                           R(Y,
                                                             Z) 
                                                           -> 
                                                           P(X))) .
  }
}
\end{verbatim}
      }
  \item 上の最後のモジュール内容の表示を見て了解されるように,
    ラベル t1 〜 t5 を付けて宣言された各一階述語の文による
    公理は正しく受け付けられ, モジュール内の公理の一つとして
    認識されている.
  \end{enumerate}
\end{enumerate}

\subsection{FOPL-CLAUSE モジュールの自動輸入}
\label{sec:fopl-import}
\subsubsection{検査内容}
\begin{enumerate}
\item スイッチ include FOPL-CLAUSE を on に設定した
  状態でモジュールを宣言する. 
  このモジュールには一階述語の文による公理が
  記述されているものとする. 
  この時エラーにならずに公理が処理される事を確認する.
\item スイッチ include FOPL-CLAUSE が off の状態で,
  一階述語文による公理の宣言を含むモジュールを定義し,
  構文解析エラーとなることを確認する.
  これは, このスイッチが off の状態では自動輸入が
  行われない事を確認するためのものである.
\end{enumerate}

\subsubsection{テストデータと手順}
\label{sec:import-fopl-data}
\begin{enumerate}
\item 下に示すモジュール宣言を, ファイル ``import-fopl.mod''
  に書き込んでおく.
  {\small
\begin{verbatim}
**>
**> FOPL-CLAUSE 自動輸入の検査
**>
module R
{
  [E]
  pred Shaves : E E
  op Barber : -> E
  var x : E
  ax Shaves(x,x) | Shaves(Barber, x) .
  ax Shaves(Barber,x) -> ~(Shaves(x,x)) .
}

**> モジュール R に自動的に FOPL-CLAUSE が輸入されているか
**> どうかを, show コマンドでみる.
show R .
\end{verbatim}
    }
\item スイッチ include FOPL-CLAUSE を on に設定し, 
  上で示したファイル ``import-fopl.mod'' をシステムにロードする.
  この時, エラーとならずに正常に処理されることを確認する.
\item 次に, スイッチ include FOPL-CLAUSE を off に設定し,
  先の ``import-fopl.mod'' をロードし, エラーとなることを確認する.
\end{enumerate}

\subsubsection{実行結果}
\begin{enumerate}
\item スイッチ include FOPL-CLAUSE を on に設定して
  第\ref{sec:import-fopl-data}節で示されたファイル
  ``import-fopl'' をロードした. 結果は下の通りである：
  {\small
\begin{verbatim}
CafeOBJ> set include FOPL-CLAUSE on
CafeOBJ> in import-fopl
processing input : ./import-fopl.mod
**> 
**> FOPL-CLAUSE 自動輸入の検査
**> 
-- defining module R...._..* done.
**> モジュール R に自動的に FOPL-CLAUSE が輸入されているか
**> どうかを, show コマンドでみる.
module R
{
  imports {
    protecting (BOOL)
    protecting (FOPL-CLAUSE)
  }
  signature {
    [ E ]
    pred Shaves : E E 
    op Barber : -> E
  }
  axioms {
    var x : E
    ax Shaves(x,x) | Shaves(Barber,x) .
    ax Shaves(Barber,x) -> ~ Shaves(x,x) .
  }
}
\end{verbatim}
    }
  予想通り, 正常にロードが終り, 最後の show コマンドの結果を
  見ると, 自動的に FOPL-CLAUSE が輸入されていることが分かる.

\item スイッチ include-FOPL-CLAUSE を off に設定し,
  ファイル ``import-fopl.mod'' をロードした.
  結果は下に示す通りである：
  {\small
\begin{verbatim}
CafeOBJ> set include FOPL-CLAUSE off
CafeOBJ> in import-fopl
processing input : ./import-fopl.mod
**> 
**> FOPL-CLAUSE 自動輸入の検査
**> 
-- defining module R
[Warning]: redefining module R ...._
[Error] no successfull parse
  parsed:[ Shaves(x,x) ], rest:[ (| Shaves ( Barber , x )) ]
[Error]: no parse for FOPL formula
    (Shaves ( x , x ) | Shaves ( Barber , x ))
-- failed to evaluate the form:
(%fax ("Shaves" "(" "x" "," "x" ")" "|" "Shaves" "(" "Barber" "," "x" ")") nil
 nil nil)

** returning to top level
CafeOBJ> sh R
*
module R
{
  imports {
    protecting (BOOL)
  }
  signature {
    [ E ]
    pred Shaves : E E 
    op Barber : -> E
  }
}
\end{verbatim}
    }
  予想通り, 一階述語文の公理の構文解析でエラーとなっている.
  また, 手動で入力した show コマンドの結果も, 
  モジュール R には, FOPL-CLAUSEが輸入されていないことが分かる.
\end{enumerate}

\subsection{節形式への変換}
\label{sec:fopl-trans}
反駁システムは, resolution 原理に基づいて定理証明を実行するため,
一階述語の文を含む, 全ての公理を節形式に変換する.
利用者に示されるシステムの動作情報もこの節形式によって提示される.
本節ではこの節形式変換にかかわる検査について記述する.

\subsubsection{検査内容}
\begin{enumerate}
\item 公理の自動変換\\
  モジュールに含まれる公理が節形式に変換されることを
  list コマンドを用いて, 反駁システム初期化後のシステム
  節集合を表示する事によって確認する.

\item 節形式変換コマンドの動作 \\
  与えられた一階述語の文を節形式に変換して表示する
  コマンド clause を用いて, 節形式への変換が正しいか否かを
  検査する.
\end{enumerate}

\subsubsection{テストデータと手順}
\label{sec:fopl-trans-data}
\begin{enumerate}
\item 公理の自動変換
  \begin{enumerate}
  \item 下に示す, モジュール宣言とスクリプトを書き込んだファイル
    ``clausal-form.mod'' を用意する：
    {\small
\begin{verbatim}
**>
**> 公理の節形式への自動変換検査
**> 

set include FOPL-CLAUSE on

module R
{

  [E]
  pred Shaves : E E
  op Barber : -> E
  var x : E
  ax[ax1]: Shaves(x,x) | Shaves(Barber, x) .
  ax[ax2]: Shaves(Barber,x) -> ~(Shaves(x,x)) .
}

option reset

**> モジュール R 文脈モジュールに設定する
--> select R
select R

**> 反駁システムの初期化
--> db reset
db reset

**> 自動変換されているはずの節集合を見る
--> list axioms
list axioms
\end{verbatim}
      }
  \item 最後の list axioms コマンドの発行によって, モジュール R で
    宣言された2つの公理を節形式に変換したものが表示されるはずである.
  \item 上で表示された各節と公理との関係を見るために,
    describe clause コマンドによって, 節番号を指定し, その節が
    どの公理に由来する物なのかを表示し, 正しい事を確認する.
  \end{enumerate}

\item 節形式変換コマンドの動作
  \begin{enumerate}
  \item 下に示すスクリプトを書き込んだファイル 
    ``clause-trans.mod'' を用意する：
    {\small
\begin{verbatim}
**>
**> 節形式変換機能の検査
**>
-- test formula translation
open NAT
protecting(FOPL-CLAUSE)
ops p q r : -> Bool .
pred P : Nat .
pred Q : Nat .
pred R : Nat Nat .
pred S : Nat Nat .
op  a   : -> Nat .
let t1 = (p -> q) -> (q -> r) .
let t2 = \A[X2:Nat]\E[Y1:Nat]\A[X1:Nat]\E[Y2:Nat]R(X1,Y1) & S(X2,Y2) .
let t3 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) &
         (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
let t4 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) |
         (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .

let t5 = \A[X:Nat]P(X) -> 
                   (\E[Y:Nat](R(X,Y) -> P(a)) & 
                             (\A[Z:Nat]R(Y,Z) -> P(X))) .

**> 反駁システムの初期化
option reset
db reset

**> t1 〜 t5 の各項に対して節形式変換コマンドを実行する：
--> clause t1 .
clause t1 .
--> clasuse t2 .
clause t2 .
--> clause t3 .
clause t3 .
--> clause t4 .
clause t4 .
--> clause t5 .
clause t5 . 
**
close
--
eof
\end{verbatim}
      }
  \item 各 clause コマンドの実行結果は, それぞれ, 下のようで
    なければならない：
    \begin{description}
    \item[clause t1]:
\begin{verbatim}
 下のような形の節
  ~(q) | r
\end{verbatim}
    \item[clause t2]:
\begin{verbatim}
 下のような形の2個の節(#fa と #fb はスコーレム関数)
   R(X:Nat,#fa.Nat(Y:Nat))
   S(X:Nat,#fb.Nat(X,Y:Nat))
\end{verbatim}
    \item[clause t3]:
\begin{verbatim}
 下のような形の2個の節(#fc はスコーレム関数)
   ~(P(X:Nat)) | R(X,#fc.Nat(X))
   P(X:Nat) | ~(R(X:Nat,Y:Nat))
\end{verbatim}
    \item[clause t4]:
\begin{verbatim}
 下のような形の節(#fd はスコーレム関数)
  ~(P(X:Nat)) | R(X,#fd.Nat(X)) 
  | P(Y:Nat) | ~(R(Y:Nat,Z:Nat))
\end{verbatim}
    \item[clause t5]:
\begin{verbatim}
 下のような形の節(#fe はスコーレム関数)
  ~(P(X:Nat)) | ~(R(X:Nat,#feNat(X))) | P(a)
\end{verbatim}
    \end{description}
  \end{enumerate}
\end{enumerate}

\subsubsection{実行結果}
\begin{enumerate}
\item 公理の自動変換
  \begin{enumerate}
  \item 第\ref{sec:fopl-trans-data}節の第1項で示されたファイル
    ``clausal-form.mod'' をシステムにロードした.
    結果は下の通り：
    {\small
\begin{verbatim}
CafeOBJ> in clausal-form
processing input : ./clausal-form.mod
**> 
**> 公理の節形式への自動変換検査
**> 
-- defining module R...._..* done.
**> モジュール R 文脈モジュールに設定する
--> select R
**> 反駁システムの初期化
--> db reset
**> 自動変換されているはずの節集合を見る
--> list axioms
1:[] Shaves(_v2:E,_v2) | Shaves(Barber,_v2:E)
2:[] ~(Shaves(Barber,_v4:E)) | ~(Shaves(_v4:E,_v4))
R> 
\end{verbatim}
      }
  \item 結果を見て分かる通り, モジュール R の公理は
    節形式に変換されている.
  \item 次に, describe clause コマンドを用いて,
    上で表示された各節に付いて, システムの情報表示を見た.
    結果は下の通りである.
    {\small
\begin{verbatim}
R> describe clause 1
-- clause derived from formula:
Shaves(_v1:E,_v1) | Shaves(Barber,_v1)
1:[] Shaves(_v2:E,_v2) | Shaves(Barber,_v2:E)
R> describe clause 2
-- clause derived from formula:
~ Shaves(Barber,_v3:E) | ~ Shaves(_v3,_v3)
2:[] ~(Shaves(Barber,_v4:E)) | ~(Shaves(_v4:E,_v4))
\end{verbatim}
      }
  \item 上の結果を見て了解される通り, システムは正しく
    公理と節との関係を把握し, 節形式への変換が行われていることが
    確認できた.
  \end{enumerate}
\item 節形式変換コマンドの動作
  \begin{enumerate}
  \item 第\ref{sec:fopl-trans-data}節の第2項で示されたファイル
    ``clause-trans.mod'' をシステムにロードした.
    結果は下に示すとおりである:
    {\small
\begin{verbatim}
CafeOBJ> in clause-trans
processing input : ./clause-trans.mod
**> 
**> 節形式変換機能の検査
**> 
-- opening module NAT.. done._
**> 反駁システムの初期化*
**> t1 〜 t5 の各項に対して節形式変換コマンドを実行する：
--> clause t1 .
29:[] ~(q) | r
--> clasuse t2 ._
30:[] R(_v27:Nat,#f-2.Nat(_v28:Nat))
31:[] S(_v29:Nat,#f-1.Nat(_v29,_v30:Nat))
--> clause t3 ._
32:[] ~(P(_v34:Nat)) | R(_v34:Nat,#f-3.Nat(_v34))
33:[] P(_v35:Nat) | ~(R(_v35:Nat,_v36:Nat))
--> clause t4 ._
34:[] ~(P(_v40:Nat)) | R(_v40:Nat,#f-4.Nat(_v40)) | P(_v41:Nat) | 
      ~(R(_v41:Nat,_v42:Nat))
--> clause t5 ._
35:[] ~(P(_v45:Nat)) | ~(R(_v45:Nat,#f-5.Nat(_v45))) | P(a)
\end{verbatim}
      }
  \item 上の結果を見て分かる通り, 第\ref{sec:fopl-trans-data}節の第2項で
    示された期待値通りの結果となっている.
  \end{enumerate}
\end{enumerate}
%%%%%%%%%%%%%%%%%
\section{定理証明機能}
\subsection{検査項目}
反駁システムにおける定理証明は, 複数の推論規則による推論が
可能である. 検査においては, まずそれぞれの推論規則による証明が
基本的に正しく実現されているかどうかを検査する.
また, 推論過程の情報表示や統計情報, また証明木の印字などの
機能についても, 適切に実現されているかどうかの検査を行う.
最後に, 複雑な問題を用いて総合的な試験を実行する.

\begin{itemize}
\item[(1)] Binary Resolution \\
  Binary Resolution を推論ルールとして用いた定理証明について検査する.
\item[(2)] Hyper Resolution\\
  Hyper Resolution を推論ルールとして用いた定理証明について検査する.
\item[(3)] Paramodulation \\
  Paramodulation を推論ルールとして用いた定理証明について検査する.
\item[(4)] 自動モード \\
  システムが適当な推論ルールを選択する, 自動(auto)モードによる
  定理証明について検査する.
\item[(5)] Demodulation \\
  推論中の demodulation の実行について検査する.
\item[(6)] 情報表示 \\
  推論過程の表示が適切になされているかを検査する.
\item[(7)] 統計情報表示 \\
  結果に関する統計情報の表示が適切になされているかを検査する.
\item[(8)] 証明木表示\\
  証明に成功した場合の, 証明木(反駁木)が適切に表示されているかを
  検査する.
\item[(9)] 総合試験 \\
  複数の推論ルールを組み合わせた定理証明について, より複雑な例に
  より検査する.
\end{itemize}

上記の内, (5)Demodulation, (6)情報表示, (7)統計情報表示, そして
(8)証明木表示の4項目は, 証明過程一般にかかわる機能であるので
単独では検査せず, (1) から (3) の各推論ルールに関する検査の中で, 
併せて検査項目を立て, 同時に検査を行う事とする.
また, (4)自動モードについては, (2)Hyper Resolution と,
(3)Paramodulation において自動モードを選択し, それぞれ
hyper resolution および paramodulation が推論ルールとして
選択されることを確認することによって検査を行う.

\subsection{検査結果一覧}
証明機能に関する検査結果の一覧を表 \ref{tab:proof-res-all} に示す.
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}[h]{|l|c|c|} \hline
      検査項目 & 結果 & 該当章番号 \\\hline
      Binary Resolution & ○ & \ref{sec:binary-res} \\
      Hyper Resolution & ○ & \ref{sec:hyper-res} \\
      Paramodulation & ○ & \ref{sec:paramod} \\
      自動モード & ○ & \ref{sec:hyper-res}, \ref{sec:paramod},\ref{sec:total-test} \\
      Demodulation & ○ & \ref{sec:hyper-res}, \\
      情報表示 & ○ & \ref{sec:binary-res},\ref{sec:hyper-res},\ref{sec:paramod} \\
      統計情報表示 & ○ & \ref{sec:binary-res},\ref{sec:hyper-res},\ref{sec:paramod} \\
      証明木表示 & ○ & \ref{sec:binary-res},\ref{sec:hyper-res},\ref{sec:paramod} \\
      総合試験 & ○ & \ref{sec:total-test} \\\hline
    \end{tabular}
    \caption{定理証明機能検査結果一覧}
    \label{tab:proof-res-all}
  \end{center}
\end{table}

\subsection{Binary Resolution}
\label{sec:binary-res}

\subsubsection{検査内容}
\begin{enumerate}
\item binary resolution を用いた定理証明を行うモジュールと
  スクリプトを用意し, システムにロード, 結果を見る.
  この時以下の項目に付いて検査を行う：
  \begin{itemize}
  \item 確かに binary resolution が推論ルールとして用いられて
    いること. これは, システムの表示する導出節の履歴欄および,
    その内容を見る事によって判断する.
  \item 結果が正しいこと. 正しい反駁結果が得られている事.
    これは出力される証明木によって判断する.
  \item binary resolution を推論規則として用いる場合,
    factor や unit deletion 機構も同時に有効とならなければ
    ならない. これらが実際に有効となっていることを確認する.
    これは，システムの情報表示(導出節や証明木の表示)を参照することで
    確認する.
  \item システムの情報表示機能の検査：\\
    実行フェーズ, 入力節, given clause, 終了状態の表示が
    正しくなされているかどうかを検査する.
  \item 証明木の表示機能の検査：\\
    反駁に成功した場合の証明木表示機能が正しく行われて
    いることを検査する.
  \item 統計情報の表示機能の検査：\\
    システムが実行中に収集した統計情報の一覧を最後に
    表示している事を検査する.
  \end{itemize}
\end{enumerate}

\subsubsection{テストデータと手順}
\label{sec:binary-res-data}

\begin{enumerate}
\item 次に示す内容のファイル ``binary-res.mod'' を用意する：
  {\small
\begin{verbatim}
**>
**> Binary Resolution の試験
**> Otter 3.05 のサンプルプログラムを CafeOBJ
**> に書き換えたものであり，結果が反駁に成功することは
**> 分かっている．

module ANDREWS
{
  [ E ]
  pred p : E 
  pred q : E
}

open ANDREWS
protecting (FOPL-CLAUSE)

**> 証明したいゴール
goal [GOAL]: (( (\E[x:E] \A[y:E] (p (x) <-> p(y)))
                 <-> ( (\E[u:E] q(u)) <-> (\A[v:E] p(v)))))
              <->
              ((\E[w:E]\A[z:E] (q(z) <-> q(w)))
                <->
                  ((\E[x1:E] p(x1)) <-> (\A[x2:E] q(x2)))) .

**> システムのリセット
option reset
db reset
**> binary resolution を用いることを指定
flag(binary-res,on)
flag(process-input,on)
**> ログが長大となるので一部を抑制
flag(print-kept,off)
flag(print-back-sub,off)
evq (setq *print-line-limit* 40)

**> SOS の設定
sos = { GOAL }

**> エンジンの起動
resolve .

close
--
eof
\end{verbatim}
    }
\item 上で示したデータは, Otter\cite{otter} システムの例題をもとに作成
  されたものであり, 反駁に成功する, つまりシステムが正常に動作すれば,
  GOAL の証明に成功する事があらかじめ分かっている物である.
\item 出力のログを用いて, 以下の点に付いて確認を行う.
  \begin{itemize}
  \item binary resolution を用いた証明過程：
    \begin{itemize}
    \item 結果が反駁成功となっていること
    \item 推論ルールとして binary resolution が用いられている事.
    \item factoring 処理や, unit deletion 処理が有効となっており,
      実際に使用されていること.
    \end{itemize}
  \item 情報表示：
    \begin{itemize}
    \item 処理過程についての情報が出力されていること
    \item 初期入力節(usable, sos 各節集合)の内容表示, それらに対する
      処理内容についての情報が出力されていること
    \item 推論過程において, given clause の表示が行われていること
    \item 終了理由についての表示が行われている事.
    \end{itemize}
  \item 証明木の表示：
    \begin{itemize}
    \item 反駁に成功した場合に証明木が表示されている事
    \item 表示は古い節(小さな節番号の節)から, 新たな節の順に
      順序付けられて表示されている事.
    \end{itemize}
  \item 統計情報の表示：
    \begin{itemize}
    \item 最後に実行中に収集された統計情報が表示されていること.
    \end{itemize}
  \end{itemize}
\end{enumerate}

\subsubsection{実行結果}
\begin{enumerate}
\item 第\ref{sec:binary-res-data}節で示されたファイル
  ``binary-res.mod'' をシステムにロードした.
  結果のログを以下に示す：
  {\small
\begin{verbatim}
CafeOBJ> in binary-res
processing input : ./binary-res.mod
**> 
**> Binary Resolution の試験
**> Otter 3.05 のサンプルプログラムを CafeOBJ
**> に書き換えたものであり，結果が反駁に成功することは
**> 分かっている．
-- defining module ANDREWS
[Warning]: redefining module ANDREWS ..._* done.
-- opening module ANDREWS.. done.
**> 証明したいゴール_
**> システムのリセット*_*
**> binary resolution を用いることを指定
-- setting flag "binary-res" to "on"
   dependent: flag(factor, on)
   dependent: flag(unit-deletion, on)
-- setting flag "process-input" to "on"
**> ログが長大となるので一部を抑制
-- setting flag "print-kept" to "off"
-- setting flag "print-back-sub" to "off"
**> SOS の設定
**> エンジンの起動
 
** start input processing.

 
** USABLE _______________________________
 
 
 process usable:
 
** SOS __________________________________
 
  1:[] p(_v26:E) | ~(q(_v27:E)) | p(_v28:E) | 
       p(#f-1.E(_v28:E)) | q(_v29:E) | q(#f-7.E(_v29:E)) | 
       ~(p(_v25:E)) | q(_v30:E)
  2:[] p(_v31:E) | ~(q(_v32:E)) | p(_v33:E) | 
       p(#f-1.E(_v33:E)) | q(_v34:E) | q(#f-7.E(_v34:E)) | 
       ~(q(#c-8.E)) | p(#c-9.E)
  3:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v36:E) | 
       p(#f-1.E(_v36:E)) | q(_v37:E) | q(#f-7.E(_v37:E)) | 
       ~(p(_v35:E)) | q(_v38:E)
  4:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v39:E) | 
       p(#f-1.E(_v39:E)) | q(_v40:E) | q(#f-7.E(_v40:E)) | 
       ~(q(#c-8.E)) | p(#c-9.E)
  5:[] p(_v42:E) | ~(q(_v43:E)) | p(_v44:E) | 
       p(#f-1.E(_v44:E)) | ~(q(_v45:E)) | 
       ~(q(#f-7.E(_v45:E))) | ~(p(_v41:E)) | 
       q(_v46:E)
  6:[] p(_v47:E) | ~(q(_v48:E)) | p(_v49:E) | 
       p(#f-1.E(_v49:E)) | ~(q(_v50:E)) | 
       ~(q(#f-7.E(_v50:E))) | ~(q(#c-8.E)) | 
       p(#c-9.E)
  7:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v52:E) | 
       p(#f-1.E(_v52:E)) | ~(q(_v53:E)) | 
       ~(q(#f-7.E(_v53:E))) | ~(p(_v51:E)) | 
       q(_v54:E)
  8:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v55:E) | 
       p(#f-1.E(_v55:E)) | ~(q(_v56:E)) | 
       ~(q(#f-7.E(_v56:E))) | ~(q(#c-8.E)) | 
       p(#c-9.E)
  9:[] p(_v58:E) | ~(q(_v59:E)) | ~(p(_v60:E)) | 
       ~(p(#f-1.E(_v60:E))) | q(_v61:E) | 
       q(#f-7.E(_v61:E)) | ~(p(_v57:E)) | 
       q(_v62:E)
  10:[] p(_v63:E) | ~(q(_v64:E)) | ~(p(_v65:E)) | 
        ~(p(#f-1.E(_v65:E))) | q(_v66:E) | 
        q(#f-7.E(_v66:E)) | ~(q(#c-8.E)) | 
        p(#c-9.E)
  11:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v68:E)) | 
        ~(p(#f-1.E(_v68:E))) | q(_v69:E) | 
        q(#f-7.E(_v69:E)) | ~(p(_v67:E)) | 
        q(_v70:E)
  12:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v71:E)) | 
        ~(p(#f-1.E(_v71:E))) | q(_v72:E) | 
        q(#f-7.E(_v72:E)) | ~(q(#c-8.E)) | 
        p(#c-9.E)
  13:[] p(_v74:E) | ~(q(_v75:E)) | ~(p(_v76:E)) | 
        ~(p(#f-1.E(_v76:E))) | ~(q(_v77:E)) | 
        ~(q(#f-7.E(_v77:E))) | ~(p(_v73:E)) | 
        q(_v78:E)
  14:[] p(_v79:E) | ~(q(_v80:E)) | ~(p(_v81:E)) | 
        ~(p(#f-1.E(_v81:E))) | ~(q(_v82:E)) | 
        ~(q(#f-7.E(_v82:E))) | ~(q(#c-8.E)) | 
        p(#c-9.E)
  15:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v84:E)) | 
        ~(p(#f-1.E(_v84:E))) | ~(q(_v85:E)) | 
        ~(q(#f-7.E(_v85:E))) | ~(p(_v83:E)) | 
        q(_v86:E)
  16:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v87:E)) | 
        ~(p(#f-1.E(_v87:E))) | ~(q(_v88:E)) | 
        ~(q(#f-7.E(_v88:E))) | ~(q(#c-8.E)) | 
        p(#c-9.E)
  17:[] p(_v91:E) | ~(q(_v92:E)) | p(_v93:E) | 
        p(#f-1.E(_v93:E)) | q(_v90:E) | 
        p(#c-10.E) | ~(q(_v89:E)) | q(#c-12.E)
  18:[] p(_v95:E) | ~(q(_v96:E)) | p(_v97:E) | 
        p(#f-1.E(_v97:E)) | q(_v94:E) | 
        p(#c-10.E) | ~(q(#c-12.E)) | q(_v98:E)
  19:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v101:E) | 
        p(#f-1.E(_v101:E)) | q(_v100:E) | 
        p(#c-10.E) | ~(q(_v99:E)) | q(#c-12.E)
  20:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v103:E) | 
        p(#f-1.E(_v103:E)) | q(_v102:E) | 
        p(#c-10.E) | ~(q(#c-12.E)) | q(_v104:E)
  21:[] p(_v106:E) | ~(q(_v107:E)) | p(_v108:E) | 
        p(#f-1.E(_v108:E)) | ~(q(#c-11.E)) | 
        ~(p(_v109:E)) | ~(q(_v105:E)) | 
        q(#c-12.E)
  22:[] p(_v110:E) | ~(q(_v111:E)) | p(_v112:E) | 
        p(#f-1.E(_v112:E)) | ~(q(#c-11.E)) | 
        ~(p(_v113:E)) | ~(q(#c-12.E)) | 
        q(_v114:E)
  23:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v116:E) | 
        p(#f-1.E(_v116:E)) | ~(q(#c-11.E)) | 
        ~(p(_v117:E)) | ~(q(_v115:E)) | 
        q(#c-12.E)
  24:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v118:E) | 
        p(#f-1.E(_v118:E)) | ~(q(#c-11.E)) | 
        ~(p(_v119:E)) | ~(q(#c-12.E)) | 
        q(_v120:E)
  25:[] p(_v123:E) | ~(q(_v124:E)) | ~(p(_v125:E)) | 
        ~(p(#f-1.E(_v125:E))) | q(_v122:E) | 
        p(#c-10.E) | ~(q(_v121:E)) | q(#c-12.E)
  26:[] p(_v127:E) | ~(q(_v128:E)) | ~(p(_v129:E)) | 
        ~(p(#f-1.E(_v129:E))) | q(_v126:E) | 
        p(#c-10.E) | ~(q(#c-12.E)) | q(_v130:E)
  27:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v133:E)) | 
        ~(p(#f-1.E(_v133:E))) | q(_v132:E) | 
        p(#c-10.E) | ~(q(_v131:E)) | q(#c-12.E)
  28:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v135:E)) | 
        ~(p(#f-1.E(_v135:E))) | q(_v134:E) | 
        p(#c-10.E) | ~(q(#c-12.E)) | q(_v136:E)
  29:[] p(_v138:E) | ~(q(_v139:E)) | ~(p(_v140:E)) | 
        ~(p(#f-1.E(_v140:E))) | ~(q(#c-11.E)) | 
        ~(p(_v141:E)) | ~(q(_v137:E)) | 
        q(#c-12.E)
  30:[] p(_v142:E) | ~(q(_v143:E)) | ~(p(_v144:E)) | 
        ~(p(#f-1.E(_v144:E))) | ~(q(#c-11.E)) | 
        ~(p(_v145:E)) | ~(q(#c-12.E)) | 
        q(_v146:E)
  31:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v148:E)) | 
        ~(p(#f-1.E(_v148:E))) | ~(q(#c-11.E)) | 
        ~(p(_v149:E)) | ~(q(_v147:E)) | 
        q(#c-12.E)
  32:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v150:E)) | 
        ~(p(#f-1.E(_v150:E))) | ~(q(#c-11.E)) | 
        ~(p(_v151:E)) | ~(q(#c-12.E)) | 
        q(_v152:E)
  33:[] p(_v154:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v155:E) | q(_v156:E) | q(#f-7.E(_v156:E)) | 
        ~(p(_v153:E)) | q(_v157:E)
  34:[] p(_v158:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v159:E) | q(_v160:E) | q(#f-7.E(_v160:E)) | 
        ~(q(#c-8.E)) | p(#c-9.E)
  35:[] p(#c-6.E) | ~(p(_v162:E)) | q(#c-4.E) | 
        p(_v163:E) | q(_v164:E) | q(#f-7.E(_v164:E)) | 
        ~(p(_v161:E)) | q(_v165:E)
  36:[] p(#c-6.E) | ~(p(_v166:E)) | q(#c-4.E) | 
        p(_v167:E) | q(_v168:E) | q(#f-7.E(_v168:E)) | 
        ~(q(#c-8.E)) | p(#c-9.E)
  37:[] p(_v170:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v171:E) | ~(q(_v172:E)) | ~(q(#f-7.E(_v172:E))) | 
        ~(p(_v169:E)) | q(_v173:E)
  38:[] p(_v174:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v175:E) | ~(q(_v176:E)) | ~(q(#f-7.E(_v176:E))) | 
        ~(q(#c-8.E)) | p(#c-9.E)
  39:[] p(#c-6.E) | ~(p(_v178:E)) | q(#c-4.E) | 
        p(_v179:E) | ~(q(_v180:E)) | ~(q(#f-7.E(_v180:E))) | 
        ~(p(_v177:E)) | q(_v181:E)
  40:[] p(#c-6.E) | ~(p(_v182:E)) | q(#c-4.E) | 
        p(_v183:E) | ~(q(_v184:E)) | ~(q(#f-7.E(_v184:E))) | 
        ~(q(#c-8.E)) | p(#c-9.E)
  41:[] p(_v187:E) | ~(p(#c-6.E)) | ~(q(_v186:E)) | 
        ~(p(#c-5.E)) | q(_v188:E) | q(#f-7.E(_v188:E)) | 
        ~(p(_v185:E)) | q(_v189:E)
  42:[] p(_v191:E) | ~(p(#c-6.E)) | ~(q(_v190:E)) | 
        ~(p(#c-5.E)) | q(_v192:E) | q(#f-7.E(_v192:E)) | 
        ~(q(#c-8.E)) | p(#c-9.E)
  43:[] p(#c-6.E) | ~(p(_v195:E)) | ~(q(_v194:E)) | 
        ~(p(#c-5.E)) | q(_v196:E) | q(#f-7.E(_v196:E)) | 
        ~(p(_v193:E)) | q(_v197:E)
  44:[] p(#c-6.E) | ~(p(_v199:E)) | ~(q(_v198:E)) | 
        ~(p(#c-5.E)) | q(_v200:E) | q(#f-7.E(_v200:E)) | 
        ~(q(#c-8.E)) | p(#c-9.E)
  45:[] p(_v203:E) | ~(p(#c-6.E)) | ~(q(_v202:E)) | 
        ~(p(#c-5.E)) | ~(q(_v204:E)) | ~(q(#f-7.E(_v204:E))) | 
        ~(p(_v201:E)) | q(_v205:E)
  46:[] p(_v207:E) | ~(p(#c-6.E)) | ~(q(_v206:E)) | 
        ~(p(#c-5.E)) | ~(q(_v208:E)) | ~(q(#f-7.E(_v208:E))) | 
        ~(q(#c-8.E)) | p(#c-9.E)
  47:[] p(#c-6.E) | ~(p(_v211:E)) | ~(q(_v210:E)) | 
        ~(p(#c-5.E)) | ~(q(_v212:E)) | ~(q(#f-7.E(_v212:E))) | 
        ~(p(_v209:E)) | q(_v213:E)
  48:[] p(#c-6.E) | ~(p(_v215:E)) | ~(q(_v214:E)) | 
        ~(p(#c-5.E)) | ~(q(_v216:E)) | ~(q(#f-7.E(_v216:E))) | 
        ~(q(#c-8.E)) | p(#c-9.E)
  49:[] p(_v219:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v220:E) | q(_v218:E) | p(#c-10.E) | 
        ~(q(_v217:E)) | q(#c-12.E)
  50:[] p(_v222:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v223:E) | q(_v221:E) | p(#c-10.E) | 
        ~(q(#c-12.E)) | q(_v224:E)
  51:[] p(#c-6.E) | ~(p(_v227:E)) | q(#c-4.E) | 
        p(_v228:E) | q(_v226:E) | p(#c-10.E) | 
        ~(q(_v225:E)) | q(#c-12.E)
  52:[] p(#c-6.E) | ~(p(_v230:E)) | q(#c-4.E) | 
        p(_v231:E) | q(_v229:E) | p(#c-10.E) | 
        ~(q(#c-12.E)) | q(_v232:E)
  53:[] p(_v234:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v235:E) | ~(q(#c-11.E)) | ~(p(_v236:E)) | 
        ~(q(_v233:E)) | q(#c-12.E)
  54:[] p(_v237:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v238:E) | ~(q(#c-11.E)) | ~(p(_v239:E)) | 
        ~(q(#c-12.E)) | q(_v240:E)
  55:[] p(#c-6.E) | ~(p(_v242:E)) | q(#c-4.E) | 
        p(_v243:E) | ~(q(#c-11.E)) | ~(p(_v244:E)) | 
        ~(q(_v241:E)) | q(#c-12.E)
  56:[] p(#c-6.E) | ~(p(_v245:E)) | q(#c-4.E) | 
        p(_v246:E) | ~(q(#c-11.E)) | ~(p(_v247:E)) | 
        ~(q(#c-12.E)) | q(_v248:E)
  57:[] p(_v252:E) | ~(p(#c-6.E)) | ~(q(_v251:E)) | 
        ~(p(#c-5.E)) | q(_v250:E) | p(#c-10.E) | 
        ~(q(_v249:E)) | q(#c-12.E)
  58:[] p(_v255:E) | ~(p(#c-6.E)) | ~(q(_v254:E)) | 
        ~(p(#c-5.E)) | q(_v253:E) | p(#c-10.E) | 
        ~(q(#c-12.E)) | q(_v256:E)
  59:[] p(#c-6.E) | ~(p(_v260:E)) | ~(q(_v259:E)) | 
        ~(p(#c-5.E)) | q(_v258:E) | p(#c-10.E) | 
        ~(q(_v257:E)) | q(#c-12.E)
  60:[] p(#c-6.E) | ~(p(_v263:E)) | ~(q(_v262:E)) | 
        ~(p(#c-5.E)) | q(_v261:E) | p(#c-10.E) | 
        ~(q(#c-12.E)) | q(_v264:E)
  61:[] p(_v267:E) | ~(p(#c-6.E)) | ~(q(_v266:E)) | 
        ~(p(#c-5.E)) | ~(q(#c-11.E)) | ~(p(_v268:E)) | 
        ~(q(_v265:E)) | q(#c-12.E)
  62:[] p(_v270:E) | ~(p(#c-6.E)) | ~(q(_v269:E)) | 
        ~(p(#c-5.E)) | ~(q(#c-11.E)) | ~(p(_v271:E)) | 
        ~(q(#c-12.E)) | q(_v272:E)
  63:[] p(#c-6.E) | ~(p(_v275:E)) | ~(q(_v274:E)) | 
        ~(p(#c-5.E)) | ~(q(#c-11.E)) | ~(p(_v276:E)) | 
        ~(q(_v273:E)) | q(#c-12.E)
  64:[] p(#c-6.E) | ~(p(_v278:E)) | ~(q(_v277:E)) | 
        ~(p(#c-5.E)) | ~(q(#c-11.E)) | ~(p(_v279:E)) | 
        ~(q(#c-12.E)) | q(_v280:E)
  65:[] p(_v282:E) | ~(q(_v283:E)) | ~(p(#c-13.E)) | 
        p(_v284:E) | q(#c-19.E) | ~(q(_v285:E)) | 
        ~(p(_v281:E)) | q(_v286:E)
  66:[] p(_v287:E) | ~(q(_v288:E)) | ~(p(#c-13.E)) | 
        p(_v289:E) | q(#c-19.E) | ~(q(_v290:E)) | 
        ~(q(#c-20.E)) | p(#c-21.E)
  67:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v292:E) | q(#c-19.E) | ~(q(_v293:E)) | 
        ~(p(_v291:E)) | q(_v294:E)
  68:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v295:E) | q(#c-19.E) | ~(q(_v296:E)) | 
        ~(q(#c-20.E)) | p(#c-21.E)
  69:[] p(_v299:E) | ~(q(_v300:E)) | ~(p(#c-13.E)) | 
        p(_v301:E) | q(_v298:E) | ~(q(#c-19.E)) | 
        ~(p(_v297:E)) | q(_v302:E)
  70:[] p(_v304:E) | ~(q(_v305:E)) | ~(p(#c-13.E)) | 
        p(_v306:E) | q(_v303:E) | ~(q(#c-19.E)) | 
        ~(q(#c-20.E)) | p(#c-21.E)
  71:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v309:E) | q(_v308:E) | ~(q(#c-19.E)) | 
        ~(p(_v307:E)) | q(_v310:E)
  72:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v312:E) | q(_v311:E) | ~(q(#c-19.E)) | 
        ~(q(#c-20.E)) | p(#c-21.E)
  73:[] p(_v315:E) | ~(q(_v316:E)) | ~(p(_v314:E)) | 
        p(#c-13.E) | q(#c-19.E) | ~(q(_v317:E)) | 
        ~(p(_v313:E)) | q(_v318:E)
  74:[] p(_v320:E) | ~(q(_v321:E)) | ~(p(_v319:E)) | 
        p(#c-13.E) | q(#c-19.E) | ~(q(_v322:E)) | 
        ~(q(#c-20.E)) | p(#c-21.E)
  75:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v324:E)) | 
        p(#c-13.E) | q(#c-19.E) | ~(q(_v325:E)) | 
        ~(p(_v323:E)) | q(_v326:E)
  76:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v327:E)) | 
        p(#c-13.E) | q(#c-19.E) | ~(q(_v328:E)) | 
        ~(q(#c-20.E)) | p(#c-21.E)
  77:[] p(_v332:E) | ~(q(_v333:E)) | ~(p(_v331:E)) | 
        p(#c-13.E) | q(_v330:E) | ~(q(#c-19.E)) | 
        ~(p(_v329:E)) | q(_v334:E)
  78:[] p(_v337:E) | ~(q(_v338:E)) | ~(p(_v336:E)) | 
        p(#c-13.E) | q(_v335:E) | ~(q(#c-19.E)) | 
        ~(q(#c-20.E)) | p(#c-21.E)
  79:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v341:E)) | 
        p(#c-13.E) | q(_v340:E) | ~(q(#c-19.E)) | 
        ~(p(_v339:E)) | q(_v342:E)
  80:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v344:E)) | 
        p(#c-13.E) | q(_v343:E) | ~(q(#c-19.E)) | 
        ~(q(#c-20.E)) | p(#c-21.E)
  81:[] p(_v345:E) | ~(q(_v346:E)) | ~(p(#c-13.E)) | 
        p(_v347:E) | q(_v348:E) | q(#f-22.E(_v348:E)) | 
        p(#c-23.E) | q(_v349:E)
  82:[] p(_v351:E) | ~(q(_v352:E)) | ~(p(#c-13.E)) | 
        p(_v353:E) | q(_v354:E) | q(#f-22.E(_v354:E)) | 
        ~(p(_v350:E)) | ~(q(#c-24.E))
  83:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v355:E) | q(_v356:E) | q(#f-22.E(_v356:E)) | 
        p(#c-23.E) | q(_v357:E)
  84:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v359:E) | q(_v360:E) | q(#f-22.E(_v360:E)) | 
        ~(p(_v358:E)) | ~(q(#c-24.E))
  85:[] p(_v361:E) | ~(q(_v362:E)) | ~(p(#c-13.E)) | 
        p(_v363:E) | ~(q(_v364:E)) | ~(q(#f-22.E(_v364:E))) | 
        p(#c-23.E) | q(_v365:E)
  86:[] p(_v367:E) | ~(q(_v368:E)) | ~(p(#c-13.E)) | 
        p(_v369:E) | ~(q(_v370:E)) | ~(q(#f-22.E(_v370:E))) | 
        ~(p(_v366:E)) | ~(q(#c-24.E))
  87:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v371:E) | ~(q(_v372:E)) | ~(q(#f-22.E(_v372:E))) | 
        p(#c-23.E) | q(_v373:E)
  88:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v375:E) | ~(q(_v376:E)) | ~(q(#f-22.E(_v376:E))) | 
        ~(p(_v374:E)) | ~(q(#c-24.E))
  89:[] p(_v378:E) | ~(q(_v379:E)) | ~(p(_v377:E)) | 
        p(#c-13.E) | q(_v380:E) | q(#f-22.E(_v380:E)) | 
        p(#c-23.E) | q(_v381:E)
  90:[] p(_v384:E) | ~(q(_v385:E)) | ~(p(_v383:E)) | 
        p(#c-13.E) | q(_v386:E) | q(#f-22.E(_v386:E)) | 
        ~(p(_v382:E)) | ~(q(#c-24.E))
  91:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v387:E)) | 
        p(#c-13.E) | q(_v388:E) | q(#f-22.E(_v388:E)) | 
        p(#c-23.E) | q(_v389:E)
  92:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v391:E)) | 
        p(#c-13.E) | q(_v392:E) | q(#f-22.E(_v392:E)) | 
        ~(p(_v390:E)) | ~(q(#c-24.E))
  93:[] p(_v394:E) | ~(q(_v395:E)) | ~(p(_v393:E)) | 
        p(#c-13.E) | ~(q(_v396:E)) | ~(q(#f-22.E(_v396:E))) | 
        p(#c-23.E) | q(_v397:E)
  94:[] p(_v400:E) | ~(q(_v401:E)) | ~(p(_v399:E)) | 
        p(#c-13.E) | ~(q(_v402:E)) | ~(q(#f-22.E(_v402:E))) | 
        ~(p(_v398:E)) | ~(q(#c-24.E))
  95:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v403:E)) | 
        p(#c-13.E) | ~(q(_v404:E)) | ~(q(#f-22.E(_v404:E))) | 
        p(#c-23.E) | q(_v405:E)
  96:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v407:E)) | 
        p(#c-13.E) | ~(q(_v408:E)) | ~(q(#f-22.E(_v408:E))) | 
        ~(p(_v406:E)) | ~(q(#c-24.E))
  97:[] p(_v410:E) | q(#c-17.E) | p(_v411:E) | 
        p(#f-16.E(_v411:E)) | q(#c-19.E) | 
        ~(q(_v412:E)) | ~(p(_v409:E)) | 
        q(_v413:E)
  98:[] p(_v414:E) | q(#c-17.E) | p(_v415:E) | 
        p(#f-16.E(_v415:E)) | q(#c-19.E) | 
        ~(q(_v416:E)) | ~(q(#c-20.E)) | 
        p(#c-21.E)
  99:[] ~(p(#c-18.E)) | ~(q(_v418:E)) | 
        p(_v419:E) | p(#f-16.E(_v419:E)) | 
        q(#c-19.E) | ~(q(_v420:E)) | ~(p(_v417:E)) | 
        q(_v421:E)
  100:[] ~(p(#c-18.E)) | ~(q(_v422:E)) | 
         p(_v423:E) | p(#f-16.E(_v423:E)) | 
         q(#c-19.E) | ~(q(_v424:E)) | ~(q(#c-20.E)) | 
         p(#c-21.E)
  101:[] p(_v427:E) | q(#c-17.E) | p(_v428:E) | 
         p(#f-16.E(_v428:E)) | q(_v426:E) | 
         ~(q(#c-19.E)) | ~(p(_v425:E)) | 
         q(_v429:E)
  102:[] p(_v431:E) | q(#c-17.E) | p(_v432:E) | 
         p(#f-16.E(_v432:E)) | q(_v430:E) | 
         ~(q(#c-19.E)) | ~(q(#c-20.E)) | 
         p(#c-21.E)
  103:[] ~(p(#c-18.E)) | ~(q(_v435:E)) | 
         p(_v436:E) | p(#f-16.E(_v436:E)) | 
         q(_v434:E) | ~(q(#c-19.E)) | ~(p(_v433:E)) | 
         q(_v437:E)
  104:[] ~(p(#c-18.E)) | ~(q(_v439:E)) | 
         p(_v440:E) | p(#f-16.E(_v440:E)) | 
         q(_v438:E) | ~(q(#c-19.E)) | ~(q(#c-20.E)) | 
         p(#c-21.E)
  105:[] p(_v442:E) | q(#c-17.E) | ~(p(_v443:E)) | 
         ~(p(#f-16.E(_v443:E))) | q(#c-19.E) | 
         ~(q(_v444:E)) | ~(p(_v441:E)) | 
         q(_v445:E)
  106:[] p(_v446:E) | q(#c-17.E) | ~(p(_v447:E)) | 
         ~(p(#f-16.E(_v447:E))) | q(#c-19.E) | 
         ~(q(_v448:E)) | ~(q(#c-20.E)) | 
         p(#c-21.E)
  107:[] ~(p(#c-18.E)) | ~(q(_v450:E)) | 
         ~(p(_v451:E)) | ~(p(#f-16.E(_v451:E))) | 
         q(#c-19.E) | ~(q(_v452:E)) | ~(p(_v449:E)) | 
         q(_v453:E)
  108:[] ~(p(#c-18.E)) | ~(q(_v454:E)) | 
         ~(p(_v455:E)) | ~(p(#f-16.E(_v455:E))) | 
         q(#c-19.E) | ~(q(_v456:E)) | ~(q(#c-20.E)) | 
         p(#c-21.E)
  109:[] p(_v459:E) | q(#c-17.E) | ~(p(_v460:E)) | 
         ~(p(#f-16.E(_v460:E))) | q(_v458:E) | 
         ~(q(#c-19.E)) | ~(p(_v457:E)) | 
         q(_v461:E)
  110:[] p(_v463:E) | q(#c-17.E) | ~(p(_v464:E)) | 
         ~(p(#f-16.E(_v464:E))) | q(_v462:E) | 
         ~(q(#c-19.E)) | ~(q(#c-20.E)) | 
         p(#c-21.E)
  111:[] ~(p(#c-18.E)) | ~(q(_v467:E)) | 
         ~(p(_v468:E)) | ~(p(#f-16.E(_v468:E))) | 
         q(_v466:E) | ~(q(#c-19.E)) | ~(p(_v465:E)) | 
         q(_v469:E)
  112:[] ~(p(#c-18.E)) | ~(q(_v471:E)) | 
         ~(p(_v472:E)) | ~(p(#f-16.E(_v472:E))) | 
         q(_v470:E) | ~(q(#c-19.E)) | ~(q(#c-20.E)) | 
         p(#c-21.E)
  113:[] p(_v473:E) | q(#c-17.E) | p(_v474:E) | 
         p(#f-16.E(_v474:E)) | q(_v475:E) | 
         q(#f-22.E(_v475:E)) | p(#c-23.E) | 
         q(_v476:E)
  114:[] p(_v478:E) | q(#c-17.E) | p(_v479:E) | 
         p(#f-16.E(_v479:E)) | q(_v480:E) | 
         q(#f-22.E(_v480:E)) | ~(p(_v477:E)) | 
         ~(q(#c-24.E))
  115:[] ~(p(#c-18.E)) | ~(q(_v481:E)) | 
         p(_v482:E) | p(#f-16.E(_v482:E)) | 
         q(_v483:E) | q(#f-22.E(_v483:E)) | 
         p(#c-23.E) | q(_v484:E)
  116:[] ~(p(#c-18.E)) | ~(q(_v486:E)) | 
         p(_v487:E) | p(#f-16.E(_v487:E)) | 
         q(_v488:E) | q(#f-22.E(_v488:E)) | 
         ~(p(_v485:E)) | ~(q(#c-24.E))
  117:[] p(_v489:E) | q(#c-17.E) | p(_v490:E) | 
         p(#f-16.E(_v490:E)) | ~(q(_v491:E)) | 
         ~(q(#f-22.E(_v491:E))) | p(#c-23.E) | 
         q(_v492:E)
  118:[] p(_v494:E) | q(#c-17.E) | p(_v495:E) | 
         p(#f-16.E(_v495:E)) | ~(q(_v496:E)) | 
         ~(q(#f-22.E(_v496:E))) | ~(p(_v493:E)) | 
         ~(q(#c-24.E))
  119:[] ~(p(#c-18.E)) | ~(q(_v497:E)) | 
         p(_v498:E) | p(#f-16.E(_v498:E)) | 
         ~(q(_v499:E)) | ~(q(#f-22.E(_v499:E))) | 
         p(#c-23.E) | q(_v500:E)
  120:[] ~(p(#c-18.E)) | ~(q(_v502:E)) | 
         p(_v503:E) | p(#f-16.E(_v503:E)) | 
         ~(q(_v504:E)) | ~(q(#f-22.E(_v504:E))) | 
         ~(p(_v501:E)) | ~(q(#c-24.E))
  121:[] p(_v505:E) | q(#c-17.E) | ~(p(_v506:E)) | 
         ~(p(#f-16.E(_v506:E))) | q(_v507:E) | 
         q(#f-22.E(_v507:E)) | p(#c-23.E) | 
         q(_v508:E)
  122:[] p(_v510:E) | q(#c-17.E) | ~(p(_v511:E)) | 
         ~(p(#f-16.E(_v511:E))) | q(_v512:E) | 
         q(#f-22.E(_v512:E)) | ~(p(_v509:E)) | 
         ~(q(#c-24.E))
  123:[] ~(p(#c-18.E)) | ~(q(_v513:E)) | 
         ~(p(_v514:E)) | ~(p(#f-16.E(_v514:E))) | 
         q(_v515:E) | q(#f-22.E(_v515:E)) | 
         p(#c-23.E) | q(_v516:E)
  124:[] ~(p(#c-18.E)) | ~(q(_v518:E)) | 
         ~(p(_v519:E)) | ~(p(#f-16.E(_v519:E))) | 
         q(_v520:E) | q(#f-22.E(_v520:E)) | 
         ~(p(_v517:E)) | ~(q(#c-24.E))
  125:[] p(_v521:E) | q(#c-17.E) | ~(p(_v522:E)) | 
         ~(p(#f-16.E(_v522:E))) | ~(q(_v523:E)) | 
         ~(q(#f-22.E(_v523:E))) | p(#c-23.E) | 
         q(_v524:E)
  126:[] p(_v526:E) | q(#c-17.E) | ~(p(_v527:E)) | 
         ~(p(#f-16.E(_v527:E))) | ~(q(_v528:E)) | 
         ~(q(#f-22.E(_v528:E))) | ~(p(_v525:E)) | 
         ~(q(#c-24.E))
  127:[] ~(p(#c-18.E)) | ~(q(_v529:E)) | 
         ~(p(_v530:E)) | ~(p(#f-16.E(_v530:E))) | 
         ~(q(_v531:E)) | ~(q(#f-22.E(_v531:E))) | 
         p(#c-23.E) | q(_v532:E)
  128:[] ~(p(#c-18.E)) | ~(q(_v534:E)) | 
         ~(p(_v535:E)) | ~(p(#f-16.E(_v535:E))) | 
         ~(q(_v536:E)) | ~(q(#f-22.E(_v536:E))) | 
         ~(p(_v533:E)) | ~(q(#c-24.E))
 
 process sos:
* kept in sos : weight=14
  1:[fsimp:fsimp] p(#f-1.E(_v576:E)) | ~(q(_v577:E)) | 
                  p(_v576:E) | q(_v575:E) | 
                  q(#f-7.E(_v575:E)) | ~(p(_v578:E))
* kept in sos : weight=14
  2:[fsimp:fsimp] p(#f-1.E(_v605:E)) | ~(q(#c-8.E)) | 
                  p(_v605:E) | q(_v604:E) | 
                  q(#f-7.E(_v604:E)) | p(#c-9.E)
* kept in sos : weight=18
  3:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v614:E) | 
       p(#f-1.E(_v614:E)) | q(_v615:E) | 
       q(#f-7.E(_v615:E)) | ~(p(_v613:E)) | 
       q(_v616:E)
* kept in sos : weight=18
  4:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v650:E) | 
       p(#f-1.E(_v650:E)) | q(_v651:E) | 
       q(#f-7.E(_v651:E)) | ~(q(#c-8.E)) | 
       p(#c-9.E)
* kept in sos : weight=18
  5:[] p(_v665:E) | ~(q(_v666:E)) | p(_v667:E) | 
       p(#f-1.E(_v667:E)) | ~(q(_v668:E)) | 
       ~(q(#f-7.E(_v668:E))) | ~(p(_v664:E)) | 
       q(_v669:E)
* kept in sos : weight=18
  6:[] p(_v718:E) | ~(q(_v719:E)) | p(_v720:E) | 
       p(#f-1.E(_v720:E)) | ~(q(_v721:E)) | 
       ~(q(#f-7.E(_v721:E))) | ~(q(#c-8.E)) | 
       p(#c-9.E)
* kept in sos : weight=14
  7:[fsimp:fsimp] q(#c-3.E) | ~(p(#c-2.E)) | 
                  p(_v794:E) | p(#f-1.E(_v794:E)) | 
                  ~(q(_v795:E)) | ~(q(#f-7.E(_v795:E)))
-- following clause subsumed by 7 during input processing:
  8:[] q(#c-3.E) | ~(p(#c-2.E)) | p(_v798:E) | 
       p(#f-1.E(_v798:E)) | ~(q(_v799:E)) | 
       ~(q(#f-7.E(_v799:E))) | ~(q(#c-8.E)) | 
       p(#c-9.E)
* kept in sos : weight=14
  9:[fsimp:fsimp] p(_v832:E) | ~(q(_v833:E)) | 
                  ~(p(_v834:E)) | ~(p(#f-1.E(_v834:E))) | 
                  q(_v835:E) | q(#f-7.E(_v835:E))
-- following clause subsumed by 9 during input processing:
  10:[fsimp:fsimp] p(#c-9.E) | ~(q(#c-8.E)) | 
                   ~(p(_v854:E)) | ~(p(#f-1.E(_v854:E))) | 
                   q(_v855:E) | q(#f-7.E(_v855:E))
* kept in sos : weight=18
  11:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v861:E)) | 
        ~(p(#f-1.E(_v861:E))) | q(_v862:E) | 
        q(#f-7.E(_v862:E)) | ~(p(_v860:E)) | 
        q(_v863:E)
* kept in sos : weight=18
  12:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v916:E)) | 
        ~(p(#f-1.E(_v916:E))) | q(_v917:E) | 
        q(#f-7.E(_v917:E)) | ~(q(#c-8.E)) | 
        p(#c-9.E)
* kept in sos : weight=14
  13:[fsimp:fsimp] p(_v963:E) | ~(q(#f-7.E(_v962:E))) | 
                   ~(p(_v964:E)) | ~(p(#f-1.E(_v964:E))) | 
                   ~(q(_v962:E)) | q(_v965:E)
* kept in sos : weight=14
  14:[fsimp:fsimp] p(#c-9.E) | ~(q(#f-7.E(_v998:E))) | 
                   ~(p(_v999:E)) | ~(p(#f-1.E(_v999:E))) | 
                   ~(q(_v998:E)) | ~(q(#c-8.E))
* kept in sos : weight=18
  15:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v1008:E)) | 
        ~(p(#f-1.E(_v1008:E))) | ~(q(_v1009:E)) | 
        ~(q(#f-7.E(_v1009:E))) | ~(p(_v1007:E)) | 
        q(_v1010:E)
* kept in sos : weight=18
  16:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v1044:E)) | 
        ~(p(#f-1.E(_v1044:E))) | ~(q(_v1045:E)) | 
        ~(q(#f-7.E(_v1045:E))) | ~(q(#c-8.E)) | 
        p(#c-9.E)
* kept in sos : weight=11
  17:[fsimp:fsimp:fsimp] 
    p(#f-1.E(_v1095:E)) | ~(q(_v1094:E)) | 
    p(_v1095:E) | q(#c-12.E) | p(#c-10.E)
* kept in sos : weight=11
  18:[fsimp:fsimp:fsimp] 
    p(#f-1.E(_v1142:E)) | ~(q(#c-12.E)) | 
    p(_v1142:E) | q(_v1141:E) | p(#c-10.E)
-- following clause subsumed by 17 during input processing:
  19:[fsimp] q(#c-3.E) | ~(p(#c-2.E)) | 
             p(_v1155:E) | p(#f-1.E(_v1155:E)) | 
             p(#c-10.E) | ~(q(_v1154:E)) | 
             q(#c-12.E)
-- following clause subsumed by 18 during input processing:
  20:[fsimp:fsimp] q(#c-3.E) | ~(p(#c-2.E)) | 
                   p(_v1170:E) | p(#f-1.E(_v1170:E)) | 
                   p(#c-10.E) | ~(q(#c-12.E))
* kept in sos : weight=11
  21:[fsimp:fsimp:fsimp] 
    p(#f-1.E(_v1210:E)) | ~(q(#c-11.E)) | 
    p(_v1210:E) | ~(p(_v1209:E)) | q(#c-12.E)
* kept in sos : weight=13
  22:[fsimp:fsimp] p(#f-1.E(_v1243:E)) | 
                   ~(q(#c-11.E)) | p(_v1243:E) | 
                   ~(p(_v1244:E)) | ~(q(#c-12.E)) | 
                   q(_v1245:E)
-- following clause subsumed by 21 during input processing:
  23:[fsimp:fsimp] q(#c-3.E) | ~(p(#c-2.E)) | 
                   p(_v1257:E) | p(#f-1.E(_v1257:E)) | 
                   ~(q(#c-11.E)) | q(#c-12.E)
-- following clause subsumed by 22 during input processing:
  24:[fsimp:fsimp] q(#c-3.E) | ~(p(#c-2.E)) | 
                   p(_v1269:E) | p(#f-1.E(_v1269:E)) | 
                   ~(q(#c-11.E)) | ~(q(#c-12.E))
* kept in sos : weight=11
  25:[fsimp:fsimp:fsimp] 
    p(#c-10.E) | ~(q(_v1299:E)) | ~(p(_v1298:E)) | 
    ~(p(#f-1.E(_v1298:E))) | q(#c-12.E)
* kept in sos : weight=11
  26:[fsimp:fsimp:fsimp] 
    p(#c-10.E) | ~(q(#c-12.E)) | ~(p(_v1328:E)) | 
    ~(p(#f-1.E(_v1328:E))) | q(_v1329:E)
* kept in sos : weight=17
  27:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v1335:E)) | 
        ~(p(#f-1.E(_v1335:E))) | q(_v1334:E) | 
        p(#c-10.E) | ~(q(_v1333:E)) | q(#c-12.E)
* kept in sos : weight=17
  28:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v1354:E)) | 
        ~(p(#f-1.E(_v1354:E))) | q(_v1353:E) | 
        p(#c-10.E) | ~(q(#c-12.E)) | q(_v1355:E)
* kept in sos : weight=11
  29:[fsimp:fsimp:fsimp] 
    p(_v1401:E) | ~(q(#c-11.E)) | ~(p(_v1400:E)) | 
    ~(p(#f-1.E(_v1400:E))) | q(#c-12.E)
* kept in sos : weight=13
  30:[fsimp:fsimp] p(_v1424:E) | ~(q(#c-11.E)) | 
                   ~(p(_v1425:E)) | ~(p(#f-1.E(_v1425:E))) | 
                   ~(q(#c-12.E)) | q(_v1426:E)
* kept in sos : weight=17
  31:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v1431:E)) | 
        ~(p(#f-1.E(_v1431:E))) | ~(q(#c-11.E)) | 
        ~(p(_v1432:E)) | ~(q(_v1430:E)) | 
        q(#c-12.E)
* kept in sos : weight=17
  32:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v1457:E)) | 
        ~(p(#f-1.E(_v1457:E))) | ~(q(#c-11.E)) | 
        ~(p(_v1458:E)) | ~(q(#c-12.E)) | 
        q(_v1459:E)
* kept in sos : weight=17
  33:[] p(_v1487:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v1488:E) | q(_v1489:E) | q(#f-7.E(_v1489:E)) | 
        ~(p(_v1486:E)) | q(_v1490:E)
* kept in sos : weight=17
  34:[] p(_v1543:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v1544:E) | q(_v1545:E) | q(#f-7.E(_v1545:E)) | 
        ~(q(#c-8.E)) | p(#c-9.E)
* kept in sos : weight=17
  35:[] p(#c-6.E) | ~(p(_v1571:E)) | q(#c-4.E) | 
        p(_v1572:E) | q(_v1573:E) | q(#f-7.E(_v1573:E)) | 
        ~(p(_v1570:E)) | q(_v1574:E)
* kept in sos : weight=17
  36:[] p(#c-6.E) | ~(p(_v1627:E)) | q(#c-4.E) | 
        p(_v1628:E) | q(_v1629:E) | q(#f-7.E(_v1629:E)) | 
        ~(q(#c-8.E)) | p(#c-9.E)
* kept in sos : weight=11
  37:[fsimp:fsimp:fsimp] 
    p(_v1670:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
    ~(q(_v1671:E)) | ~(q(#f-7.E(_v1671:E)))
-- following clause subsumed by 37 during input processing:
  38:[fsimp:fsimp] p(#c-9.E) | ~(p(#c-6.E)) | 
                   q(#c-4.E) | ~(q(_v1684:E)) | 
                   ~(q(#f-7.E(_v1684:E))) | 
                   ~(q(#c-8.E))
* kept in sos : weight=11
  39:[fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(_v1712:E)) | q(#c-4.E) | 
    ~(q(_v1713:E)) | ~(q(#f-7.E(_v1713:E)))
-- following clause subsumed by 39 during input processing:
  40:[fsimp] p(#c-6.E) | ~(p(_v1722:E)) | 
             q(#c-4.E) | ~(q(_v1723:E)) | 
             ~(q(#f-7.E(_v1723:E))) | ~(q(#c-8.E)) | 
             p(#c-9.E)
* kept in sos : weight=13
  41:[fsimp:fsimp] p(_v1749:E) | ~(p(#c-6.E)) | 
                   ~(q(_v1748:E)) | ~(p(#c-5.E)) | 
                   q(_v1750:E) | q(#f-7.E(_v1750:E))
-- following clause subsumed by 41 during input processing:
  42:[fsimp:fsimp] p(#c-9.E) | ~(p(#c-6.E)) | 
                   ~(q(#c-8.E)) | ~(p(#c-5.E)) | 
                   q(_v1764:E) | q(#f-7.E(_v1764:E))
* kept in sos : weight=11
  43:[fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(#c-5.E)) | ~(q(_v1792:E)) | 
    q(_v1793:E) | q(#f-7.E(_v1793:E))
-- following clause subsumed by 43 during input processing:
  44:[fsimp:fsimp] p(#c-6.E) | ~(p(#c-5.E)) | 
                   ~(q(#c-8.E)) | q(_v1807:E) | 
                   q(#f-7.E(_v1807:E)) | 
                   p(#c-9.E)
* kept in sos : weight=13
  45:[fsimp:fsimp] p(_v1848:E) | ~(p(#c-6.E)) | 
                   ~(q(#f-7.E(_v1847:E))) | 
                   ~(p(#c-5.E)) | ~(q(_v1847:E)) | 
                   q(_v1849:E)
* kept in sos : weight=13
  46:[fsimp:fsimp] p(#c-9.E) | ~(p(#c-6.E)) | 
                   ~(q(#f-7.E(_v1873:E))) | 
                   ~(p(#c-5.E)) | ~(q(_v1873:E)) | 
                   ~(q(#c-8.E))
* kept in sos : weight=11
  47:[fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(#c-5.E)) | ~(q(#f-7.E(_v1929:E))) | 
    ~(q(_v1929:E)) | q(_v1930:E)
* kept in sos : weight=13
  48:[fsimp:fsimp] p(#c-6.E) | ~(p(#c-5.E)) | 
                   ~(q(#f-7.E(_v1954:E))) | 
                   ~(q(_v1954:E)) | ~(q(#c-8.E)) | 
                   p(#c-9.E)
* kept in sos : weight=10
  49:[fsimp:fsimp:fsimp] 
    p(#c-10.E) | ~(p(#c-6.E)) | q(#c-4.E) | 
    ~(q(_v1976:E)) | q(#c-12.E)
* kept in sos : weight=8
  50:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-10.E) | ~(p(#c-6.E)) | q(#c-4.E) | 
    ~(q(#c-12.E))
* kept in sos : weight=12
  51:[fsimp:fsimp] p(#c-6.E) | ~(p(_v2015:E)) | 
                   q(#c-4.E) | p(#c-10.E) | 
                   ~(q(_v2014:E)) | q(#c-12.E)
* kept in sos : weight=10
  52:[fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(_v2035:E)) | q(#c-4.E) | 
    p(#c-10.E) | ~(q(#c-12.E))
* kept in sos : weight=10
  53:[fsimp:fsimp:fsimp] 
    p(_v2055:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
    ~(q(#c-11.E)) | q(#c-12.E)
* kept in sos : weight=10
  54:[fsimp:fsimp:fsimp] 
    p(_v2075:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
    ~(q(#c-11.E)) | ~(q(#c-12.E))
* kept in sos : weight=10
  55:[fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(_v2095:E)) | q(#c-4.E) | 
    ~(q(#c-11.E)) | q(#c-12.E)
* kept in sos : weight=10
  56:[fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(_v2115:E)) | q(#c-4.E) | 
    ~(q(#c-11.E)) | ~(q(#c-12.E))
* kept in sos : weight=10
  57:[fsimp:fsimp:fsimp] 
    p(#c-10.E) | ~(p(#c-6.E)) | ~(q(_v2137:E)) | 
    ~(p(#c-5.E)) | q(#c-12.E)
* kept in sos : weight=10
  58:[fsimp:fsimp:fsimp] 
    p(#c-10.E) | ~(p(#c-6.E)) | ~(q(#c-12.E)) | 
    ~(p(#c-5.E)) | q(_v2159:E)
* kept in sos : weight=10
  59:[fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(#c-5.E)) | ~(q(_v2181:E)) | 
    q(#c-12.E) | p(#c-10.E)
* kept in sos : weight=10
  60:[fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(#c-5.E)) | ~(q(#c-12.E)) | 
    q(_v2203:E) | p(#c-10.E)
* kept in sos : weight=10
  61:[fsimp:fsimp:fsimp] 
    p(_v2224:E) | ~(p(#c-6.E)) | ~(q(#c-11.E)) | 
    ~(p(#c-5.E)) | q(#c-12.E)
* kept in sos : weight=12
  62:[fsimp:fsimp] p(_v2242:E) | ~(p(#c-6.E)) | 
                   ~(q(#c-11.E)) | ~(p(#c-5.E)) | 
                   ~(q(#c-12.E)) | q(_v2243:E)
* kept in sos : weight=8
  63:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(#c-5.E)) | ~(q(#c-11.E)) | 
    q(#c-12.E)
* kept in sos : weight=10
  64:[fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(#c-5.E)) | ~(q(#c-11.E)) | 
    ~(q(#c-12.E)) | q(_v2287:E)
* kept in sos : weight=8
  65:[fsimp:fsimp:fsimp:fsimp] 
    p(_v2326:E) | ~(q(_v2327:E)) | ~(p(#c-13.E)) | 
    q(#c-19.E)
-- following clause subsumed by 65 during input processing:
  66:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-21.E) | ~(q(#c-20.E)) | ~(p(#c-13.E)) | 
    q(#c-19.E)
-- following clause subsumed by 65 during input processing:
  67:[fsimp:fsimp] q(#c-15.E) | ~(p(#c-14.E)) | 
                   ~(p(#c-13.E)) | p(_v2366:E) | 
                   q(#c-19.E) | ~(q(_v2367:E))
-- following clause subsumed by 65 during input processing:
  68:[fsimp:fsimp] q(#c-15.E) | ~(p(#c-14.E)) | 
                   ~(p(#c-13.E)) | p(#c-21.E) | 
                   q(#c-19.E) | ~(q(#c-20.E))
* kept in sos : weight=8
  69:[fsimp:fsimp:fsimp:fsimp] 
    p(_v2415:E) | ~(q(#c-19.E)) | ~(p(#c-13.E)) | 
    q(_v2416:E)
-- following clause subsumed by 69 during input processing:
  70:[fsimp:fsimp:fsimp] 
    p(#c-21.E) | ~(q(#c-19.E)) | ~(p(#c-13.E)) | 
    q(_v2438:E) | ~(q(#c-20.E))
-- following clause subsumed by 69 during input processing:
  71:[fsimp:fsimp:fsimp] 
    q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
    p(_v2458:E) | ~(q(#c-19.E))
-- following clause subsumed by 69 during input processing:
  72:[fsimp:fsimp] q(#c-15.E) | ~(p(#c-14.E)) | 
                   ~(p(#c-13.E)) | p(#c-21.E) | 
                   ~(q(#c-19.E)) | ~(q(#c-20.E))
* kept in sos : weight=8
  73:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(_v2506:E)) | ~(p(_v2505:E)) | 
    q(#c-19.E)
-- following clause subsumed by 73 during input processing:
  74:[fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(#c-20.E)) | ~(p(_v2528:E)) | 
    q(#c-19.E) | p(#c-21.E)
-- following clause subsumed by 73 during input processing:
  75:[fsimp:fsimp:fsimp] 
    q(#c-15.E) | ~(p(#c-14.E)) | p(#c-13.E) | 
    q(#c-19.E) | ~(q(_v2548:E))
-- following clause subsumed by 73 during input processing:
  76:[fsimp:fsimp] q(#c-15.E) | ~(p(#c-14.E)) | 
                   p(#c-13.E) | q(#c-19.E) | 
                   ~(q(#c-20.E)) | p(#c-21.E)
* kept in sos : weight=8
  77:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(#c-19.E)) | ~(p(_v2596:E)) | 
    q(_v2597:E)
-- following clause subsumed by 77 during input processing:
  78:[fsimp:fsimp] p(#c-13.E) | ~(q(#c-19.E)) | 
                   ~(p(_v2616:E)) | q(_v2617:E) | 
                   ~(q(#c-20.E)) | p(#c-21.E)
-- following clause subsumed by 77 during input processing:
  79:[fsimp:fsimp:fsimp:fsimp] 
    q(#c-15.E) | ~(p(#c-14.E)) | p(#c-13.E) | 
    ~(q(#c-19.E))
-- following clause subsumed by 77 during input processing:
  80:[fsimp:fsimp] q(#c-15.E) | ~(p(#c-14.E)) | 
                   p(#c-13.E) | ~(q(#c-19.E)) | 
                   ~(q(#c-20.E)) | p(#c-21.E)
* kept in sos : weight=11
  81:[fsimp:fsimp:fsimp] 
    p(#c-23.E) | ~(q(_v2671:E)) | ~(p(#c-13.E)) | 
    q(_v2672:E) | q(#f-22.E(_v2672:E))
* kept in sos : weight=11
  82:[fsimp:fsimp:fsimp] 
    p(_v2700:E) | ~(q(#c-24.E)) | ~(p(#c-13.E)) | 
    q(_v2701:E) | q(#f-22.E(_v2701:E))
* kept in sos : weight=17
  83:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v2705:E) | q(_v2706:E) | q(#f-22.E(_v2706:E)) | 
        p(#c-23.E) | q(_v2707:E)
* kept in sos : weight=17
  84:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(#c-13.E)) | 
        p(_v2734:E) | q(_v2735:E) | q(#f-22.E(_v2735:E)) | 
        ~(p(_v2733:E)) | ~(q(#c-24.E))
* kept in sos : weight=11
  85:[fsimp:fsimp:fsimp] 
    p(#c-23.E) | ~(q(#f-22.E(_v2803:E))) | 
    ~(p(#c-13.E)) | ~(q(_v2803:E)) | q(_v2804:E)
* kept in sos : weight=11
  86:[fsimp:fsimp:fsimp] 
    p(_v2850:E) | ~(q(#f-22.E(_v2849:E))) | 
    ~(p(#c-13.E)) | ~(q(_v2849:E)) | ~(q(#c-24.E))
-- following clause subsumed by 85 during input processing:
  87:[fsimp:fsimp] q(#c-15.E) | ~(p(#c-14.E)) | 
                   ~(p(#c-13.E)) | p(#c-23.E) | 
                   ~(q(_v2866:E)) | ~(q(#f-22.E(_v2866:E)))
-- following clause subsumed by 86 during input processing:
  88:[fsimp] q(#c-15.E) | ~(p(#c-14.E)) | 
             ~(p(#c-13.E)) | p(_v2876:E) | 
             ~(q(_v2875:E)) | ~(q(#f-22.E(_v2875:E))) | 
             ~(q(#c-24.E))
* kept in sos : weight=13
  89:[fsimp:fsimp] p(#c-13.E) | ~(q(_v2904:E)) | 
                   ~(p(_v2903:E)) | q(_v2902:E) | 
                   q(#f-22.E(_v2902:E)) | 
                   p(#c-23.E)
* kept in sos : weight=11
  90:[fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(#c-24.E)) | ~(p(_v2933:E)) | 
    q(_v2934:E) | q(#f-22.E(_v2934:E))
* kept in sos : weight=17
  91:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v2938:E)) | 
        p(#c-13.E) | q(_v2939:E) | q(#f-22.E(_v2939:E)) | 
        p(#c-23.E) | q(_v2940:E)
* kept in sos : weight=17
  92:[] q(#c-15.E) | ~(p(#c-14.E)) | ~(p(_v2966:E)) | 
        p(#c-13.E) | q(_v2967:E) | q(#f-22.E(_v2967:E)) | 
        ~(p(_v2965:E)) | ~(q(#c-24.E))
* kept in sos : weight=13
  93:[fsimp:fsimp] p(#c-13.E) | ~(q(#f-22.E(_v3036:E))) | 
                   ~(p(_v3035:E)) | ~(q(_v3036:E)) | 
                   p(#c-23.E) | q(_v3037:E)
* kept in sos : weight=11
  94:[fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(#f-22.E(_v3084:E))) | 
    ~(p(_v3085:E)) | ~(q(_v3084:E)) | ~(q(#c-24.E))
-- following clause subsumed by 93 during input processing:
  95:[fsimp:fsimp] q(#c-15.E) | ~(p(#c-14.E)) | 
                   p(#c-13.E) | ~(q(_v3100:E)) | 
                   ~(q(#f-22.E(_v3100:E))) | 
                   p(#c-23.E)
-- following clause subsumed by 94 during input processing:
  96:[fsimp:fsimp] q(#c-15.E) | ~(p(#c-14.E)) | 
                   p(#c-13.E) | ~(q(_v3112:E)) | 
                   ~(q(#f-22.E(_v3112:E))) | 
                   ~(q(#c-24.E))
* kept in sos : weight=13
  97:[fsimp:fsimp] p(#f-16.E(_v3146:E)) | 
                   q(#c-17.E) | p(_v3146:E) | 
                   q(#c-19.E) | ~(q(_v3145:E)) | 
                   ~(p(_v3147:E))
* kept in sos : weight=13
  98:[fsimp:fsimp] p(#f-16.E(_v3169:E)) | 
                   q(#c-17.E) | p(_v3169:E) | 
                   q(#c-19.E) | ~(q(#c-20.E)) | 
                   p(#c-21.E)
* kept in sos : weight=11
  99:[fsimp:fsimp:fsimp] 
    ~(p(#c-18.E)) | ~(q(_v3198:E)) | p(_v3197:E) | 
    p(#f-16.E(_v3197:E)) | q(#c-19.E)
-- following clause subsumed by 99 during input processing:
  100:[fsimp:fsimp] ~(p(#c-18.E)) | ~(q(#c-20.E)) | 
                    p(_v3211:E) | p(#f-16.E(_v3211:E)) | 
                    q(#c-19.E) | p(#c-21.E)
* kept in sos : weight=11
  101:[fsimp:fsimp:fsimp] 
    p(#f-16.E(_v3249:E)) | q(#c-17.E) | 
    p(_v3249:E) | ~(q(#c-19.E)) | ~(p(_v3250:E))
* kept in sos : weight=13
  102:[fsimp:fsimp] p(#f-16.E(_v3268:E)) | 
                    q(#c-17.E) | p(_v3268:E) | 
                    ~(q(#c-19.E)) | ~(q(#c-20.E)) | 
                    p(#c-21.E)
* kept in sos : weight=11
  103:[fsimp:fsimp:fsimp] 
    ~(p(#c-18.E)) | ~(q(#c-19.E)) | p(_v3297:E) | 
    p(#f-16.E(_v3297:E)) | q(_v3298:E)
-- following clause subsumed by 103 during input processing:
  104:[fsimp] ~(p(#c-18.E)) | ~(q(#c-19.E)) | 
              p(_v3308:E) | p(#f-16.E(_v3308:E)) | 
              q(_v3309:E) | ~(q(#c-20.E)) | 
              p(#c-21.E)
* kept in sos : weight=13
  105:[fsimp:fsimp] p(_v3334:E) | q(#c-17.E) | 
                    ~(p(_v3335:E)) | ~(p(#f-16.E(_v3335:E))) | 
                    q(#c-19.E) | ~(q(_v3336:E))
-- following clause subsumed by 105 during input processing:
  106:[fsimp:fsimp] p(#c-21.E) | q(#c-17.E) | 
                    ~(p(_v3350:E)) | ~(p(#f-16.E(_v3350:E))) | 
                    q(#c-19.E) | ~(q(#c-20.E))
* kept in sos : weight=17
  107:[] ~(p(#c-18.E)) | ~(q(_v3357:E)) | 
         ~(p(_v3358:E)) | ~(p(#f-16.E(_v3358:E))) | 
         q(#c-19.E) | ~(q(_v3359:E)) | ~(p(_v3356:E)) | 
         q(_v3360:E)
* kept in sos : weight=17
  108:[] ~(p(#c-18.E)) | ~(q(_v3413:E)) | 
         ~(p(_v3414:E)) | ~(p(#f-16.E(_v3414:E))) | 
         q(#c-19.E) | ~(q(_v3415:E)) | ~(q(#c-20.E)) | 
         p(#c-21.E)
* kept in sos : weight=11
  109:[fsimp:fsimp:fsimp] 
    p(_v3462:E) | q(#c-17.E) | ~(p(_v3461:E)) | 
    ~(p(#f-16.E(_v3461:E))) | ~(q(#c-19.E))
-- following clause subsumed by 109 during input processing:
  110:[fsimp:fsimp] p(#c-21.E) | q(#c-17.E) | 
                    ~(p(_v3475:E)) | ~(p(#f-16.E(_v3475:E))) | 
                    ~(q(#c-19.E)) | ~(q(#c-20.E))
* kept in sos : weight=17
  111:[] ~(p(#c-18.E)) | ~(q(_v3483:E)) | 
         ~(p(_v3484:E)) | ~(p(#f-16.E(_v3484:E))) | 
         q(_v3482:E) | ~(q(#c-19.E)) | ~(p(_v3481:E)) | 
         q(_v3485:E)
* kept in sos : weight=17
  112:[] ~(p(#c-18.E)) | ~(q(_v3540:E)) | 
         ~(p(_v3541:E)) | ~(p(#f-16.E(_v3541:E))) | 
         q(_v3539:E) | ~(q(#c-19.E)) | ~(q(#c-20.E)) | 
         p(#c-21.E)
* kept in sos : weight=18
  113:[] p(_v3561:E) | q(#c-17.E) | p(_v3562:E) | 
         p(#f-16.E(_v3562:E)) | q(_v3563:E) | 
         q(#f-22.E(_v3563:E)) | p(#c-23.E) | 
         q(_v3564:E)
* kept in sos : weight=18
  114:[] p(_v3623:E) | q(#c-17.E) | p(_v3624:E) | 
         p(#f-16.E(_v3624:E)) | q(_v3625:E) | 
         q(#f-22.E(_v3625:E)) | ~(p(_v3622:E)) | 
         ~(q(#c-24.E))
* kept in sos : weight=16
  115:[fsimp] ~(p(#c-18.E)) | ~(q(_v3667:E)) | 
              p(_v3666:E) | p(#f-16.E(_v3666:E)) | 
              q(_v3665:E) | q(#f-22.E(_v3665:E)) | 
              p(#c-23.E)
* kept in sos : weight=14
  116:[fsimp:fsimp] ~(p(#c-18.E)) | ~(q(#c-24.E)) | 
                    p(_v3690:E) | p(#f-16.E(_v3690:E)) | 
                    q(_v3691:E) | q(#f-22.E(_v3691:E))
* kept in sos : weight=14
  117:[fsimp:fsimp] p(#f-16.E(_v3717:E)) | 
                    q(#c-17.E) | p(_v3717:E) | 
                    ~(q(_v3716:E)) | ~(q(#f-22.E(_v3716:E))) | 
                    p(#c-23.E)
* kept in sos : weight=16
  118:[fsimp] p(#f-16.E(_v3741:E)) | q(#c-17.E) | 
              p(_v3741:E) | ~(q(_v3742:E)) | 
              ~(q(#f-22.E(_v3742:E))) | 
              ~(p(_v3740:E)) | ~(q(#c-24.E))
* kept in sos : weight=16
  119:[fsimp] ~(p(#c-18.E)) | ~(q(#f-22.E(_v3768:E))) | 
              p(_v3767:E) | p(#f-16.E(_v3767:E)) | 
              ~(q(_v3768:E)) | p(#c-23.E) | 
              q(_v3769:E)
* kept in sos : weight=14
  120:[fsimp:fsimp] ~(p(#c-18.E)) | ~(q(#f-22.E(_v3805:E))) | 
                    p(_v3806:E) | p(#f-16.E(_v3806:E)) | 
                    ~(q(_v3805:E)) | ~(q(#c-24.E))
* kept in sos : weight=18
  121:[] p(_v3814:E) | q(#c-17.E) | ~(p(_v3815:E)) | 
         ~(p(#f-16.E(_v3815:E))) | q(_v3816:E) | 
         q(#f-22.E(_v3816:E)) | p(#c-23.E) | 
         q(_v3817:E)
* kept in sos : weight=18
  122:[] p(_v3855:E) | q(#c-17.E) | ~(p(_v3856:E)) | 
         ~(p(#f-16.E(_v3856:E))) | q(_v3857:E) | 
         q(#f-22.E(_v3857:E)) | ~(p(_v3854:E)) | 
         ~(q(#c-24.E))
* kept in sos : weight=18
  123:[] ~(p(#c-18.E)) | ~(q(_v3881:E)) | 
         ~(p(_v3882:E)) | ~(p(#f-16.E(_v3882:E))) | 
         q(_v3883:E) | q(#f-22.E(_v3883:E)) | 
         p(#c-23.E) | q(_v3884:E)
* kept in sos : weight=18
  124:[] ~(p(#c-18.E)) | ~(q(_v3909:E)) | 
         ~(p(_v3910:E)) | ~(p(#f-16.E(_v3910:E))) | 
         q(_v3911:E) | q(#f-22.E(_v3911:E)) | 
         ~(p(_v3908:E)) | ~(q(#c-24.E))
* kept in sos : weight=14
  125:[fsimp:fsimp] p(#c-23.E) | q(#c-17.E) | 
                    ~(p(_v3961:E)) | ~(p(#f-16.E(_v3961:E))) | 
                    ~(q(_v3962:E)) | ~(q(#f-22.E(_v3962:E)))
* kept in sos : weight=16
  126:[fsimp] p(_v3976:E) | q(#c-17.E) | 
              ~(p(_v3975:E)) | ~(p(#f-16.E(_v3975:E))) | 
              ~(q(_v3974:E)) | ~(q(#f-22.E(_v3974:E))) | 
              ~(q(#c-24.E))
* kept in sos : weight=18
  127:[] ~(p(#c-18.E)) | ~(q(_v3986:E)) | 
         ~(p(_v3987:E)) | ~(p(#f-16.E(_v3987:E))) | 
         ~(q(_v3988:E)) | ~(q(#f-22.E(_v3988:E))) | 
         p(#c-23.E) | q(_v3989:E)
* kept in sos : weight=18
  128:[] ~(p(#c-18.E)) | ~(q(_v4016:E)) | 
         ~(p(_v4017:E)) | ~(p(#f-16.E(_v4017:E))) | 
         ~(q(_v4018:E)) | ~(q(#f-22.E(_v4018:E))) | 
         ~(p(_v4015:E)) | ~(q(#c-24.E))
-- 726 backsubsumes 7.
-- 727 backsubsumes 726.
-- 727 backsubsumes 5.
-- 739 backsubsumes 6.
-- 739 backsubsumes 738.
 

** end process input.

 
** Starting PigNose _____________________
 
#1(weight=8):
  50:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-10.E) | ~(p(#c-6.E)) | q(#c-4.E) | 
    ~(q(#c-12.E))
#2(weight=8):
  63:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(#c-5.E)) | ~(q(#c-11.E)) | 
    q(#c-12.E)
#3(weight=8):
  65:[fsimp:fsimp:fsimp:fsimp] 
    p(_v2326:E) | ~(q(_v2327:E)) | ~(p(#c-13.E)) | 
    q(#c-19.E)
#4(weight=8):
  69:[fsimp:fsimp:fsimp:fsimp] 
    p(_v2415:E) | ~(q(#c-19.E)) | ~(p(#c-13.E)) | 
    q(_v2416:E)
#5(weight=8):
  73:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(_v2506:E)) | ~(p(_v2505:E)) | 
    q(#c-19.E)
#6(weight=8):
  77:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(#c-19.E)) | ~(p(_v2596:E)) | 
    q(_v2597:E)
#7(weight=8):
  3304:[binary:69,65,fsimp:fsimp] 
    ~(p(#c-13.E)) | ~(q(_v13936:E)) | p(_v13935:E) | 
    q(_v13937:E)
#8(weight=8):
  3352:[binary:77,73,fsimp:fsimp] 
    ~(p(_v14025:E)) | ~(q(_v14026:E)) | 
    p(#c-13.E) | q(_v14027:E)
#9(weight=8):
  3426:[binary:3352,3304,fsimp:fsimp] 
    q(_v14218:E) | p(_v14219:E) | ~(q(_v14217:E)) | 
    ~(p(_v14220:E))
#10(weight=9):
  859:[factor:17] p(#f-1.E(#c-10.E)) | ~(q(_v4934:E)) | 
                  p(#c-10.E) | q(#c-12.E)
#11(weight=6):
  3451:[binary:859,3426,fsimp:fsimp:fsimp] 
    ~(q(_v14331:E)) | p(#c-10.E) | q(#c-12.E)
#12(weight=6):
  3473:[binary:3451,3426,fsimp:fsimp] 
    ~(q(_v14391:E)) | p(_v14390:E) | q(#c-12.E)
#13(weight=9):
  860:[factor:18] p(#f-1.E(#c-10.E)) | ~(q(#c-12.E)) | 
                  p(#c-10.E) | q(_v4938:E)
#14(weight=6):
  3491:[binary:860,3426,fsimp:fsimp:fsimp] 
    ~(q(#c-12.E)) | p(#c-10.E) | q(_v14464:E)
#15(weight=6):
  3517:[binary:3491,3473,fsimp] 
    p(#c-10.E) | ~(q(_v14529:E)) | q(_v14530:E)
#16(weight=6):
  3528:[binary:3517,3426,fsimp:fsimp] 
    ~(q(_v14573:E)) | p(_v14572:E) | q(_v14574:E)
#17(weight=9):
  915:[factor:33,fsimp:fsimp:fsimp] 
    p(_v5257:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
    q(#f-7.E(#c-4.E))
#18(weight=6):
  3558:[binary:915,3528,fsimp:fsimp] 
    q(#c-4.E) | p(_v14655:E) | ~(p(#c-6.E))
#19(weight=6):
  3561:[binary:3558,3528,fsimp] 
    q(_v14662:E) | p(_v14661:E) | ~(p(#c-6.E))
#20(weight=9):
  955:[factor:35,fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(_v5508:E)) | q(#c-4.E) | 
    q(#f-7.E(#c-4.E))
#21(weight=6):
  3592:[binary:955,3528,fsimp:fsimp] 
    q(#c-4.E) | p(#c-6.E) | ~(p(_v14730:E))
#22(weight=6):
  3595:[binary:3592,3528,fsimp] 
    q(_v14737:E) | p(#c-6.E) | ~(p(_v14738:E))
#23(weight=6):
  3611:[binary:3595,3561,fsimp] 
    p(_v14773:E) | q(_v14772:E) | ~(p(_v14774:E))
#24(weight=9):
  1012:[factor:86] p(_v5700:E) | ~(q(#f-22.E(#c-24.E))) | 
                   ~(p(#c-13.E)) | ~(q(#c-24.E))
#25(weight=6):
  3631:[binary:1012,3611,fsimp:fsimp] 
    ~(p(#c-13.E)) | p(_v14832:E) | ~(q(#c-24.E))
#26(weight=4):
  3657:[binary:3631,3611,fsimp:fsimp] 
    ~(p(#c-13.E)) | p(_v14896:E)
#27(weight=9):
  1042:[factor:94] p(#c-13.E) | ~(q(#f-22.E(#c-24.E))) | 
                   ~(p(_v5803:E)) | ~(q(#c-24.E))
#28(weight=6):
  3672:[binary:1042,3611,fsimp:fsimp] 
    ~(p(_v14926:E)) | p(#c-13.E) | ~(q(#c-24.E))
#29(weight=4):
  3701:[binary:3672,3611,fsimp:fsimp] 
    ~(p(_v14987:E)) | p(#c-13.E)
#30(weight=4):
  3711:[binary:3701,3657] 
    p(_v15000:E) | ~(p(_v15001:E))
#31(weight=9):
  1045:[factor:107,fsimp:fsimp:fsimp] 
    ~(p(#c-18.E)) | ~(q(_v5870:E)) | ~(p(#f-16.E(#c-18.E))) | 
    q(#c-19.E)
#32(weight=6):
  3725:[binary:1045,3711,fsimp] 
    ~(p(#c-18.E)) | q(#c-19.E) | ~(q(_v15031:E))
#33(weight=4):
  3735:[binary:3725,3528,fsimp:fsimp] 
    q(#c-19.E) | ~(q(_v15056:E))
#34(weight=9):
  1085:[factor:111,fsimp:fsimp:fsimp] 
    ~(p(#c-18.E)) | ~(q(#c-19.E)) | ~(p(#f-16.E(#c-18.E))) | 
    q(_v6123:E)
#35(weight=6):
  3758:[binary:1085,3711,fsimp] 
    ~(p(#c-18.E)) | q(_v15091:E) | ~(q(#c-19.E))
#36(weight=4):
  3769:[binary:3758,3528,fsimp:fsimp] 
    q(_v15115:E) | ~(q(#c-19.E))
#37(weight=4):
  3784:[binary:3769,3735] 
    ~(q(_v15125:E)) | q(_v15126:E)
#38(weight=10):
  1311:[factor:744] p(#c-9.E) | ~(q(#f-7.E(#c-8.E))) | 
                    p(#f-1.E(#c-9.E)) | 
                    ~(q(#c-8.E))
#39(weight=7):
  3790:[binary:1311,3784,fsimp] 
    ~(q(#c-8.E)) | p(#f-1.E(#c-9.E)) | p(#c-9.E)
#40(weight=4):
  3797:[binary:3790,3711,fsimp] 
    p(#c-9.E) | ~(q(#c-8.E))
#41(weight=4):
  3801:[binary:3797,3711] 
    p(_v15145:E) | ~(q(#c-8.E))
#42(weight=4):
  3804:[binary:3801,3784] 
    ~(q(_v15148:E)) | p(_v15149:E)
#43(weight=10):
  1314:[factor:783,fsimp:fsimp] 
    q(#c-3.E) | ~(p(#c-2.E)) | ~(p(#f-1.E(#c-2.E))) | 
    q(#f-7.E(#c-3.E))
#44(weight=7):
  3814:[binary:1314,3711,fsimp] 
    ~(p(#c-2.E)) | q(#f-7.E(#c-3.E)) | q(#c-3.E)
#45(weight=4):
  3822:[binary:3814,3784,fsimp] 
    q(#c-3.E) | ~(p(#c-2.E))
#46(weight=4):
  3828:[binary:3822,3784] 
    q(_v15175:E) | ~(p(#c-2.E))
#47(weight=4):
  3834:[binary:3828,3711] 
    ~(p(_v15182:E)) | q(_v15183:E)
#48(weight=10):
  1927:[factor:1122] 
    p(#f-16.E(#c-23.E)) | q(#c-17.E) | p(#c-23.E) | 
    q(#f-22.E(#c-17.E))
#49(weight=7):
  3839:[binary:1927,3834,fsimp] 
    q(#f-22.E(#c-17.E)) | p(#c-23.E) | q(#c-17.E)
#50(weight=4):
  3855:[binary:3839,3804,fsimp] 
    p(#c-23.E) | q(#c-17.E)
#51(weight=2):
  3866:[binary:3855,3834,fsimp] 
    q(#c-17.E)
#52(weight=2):
  3872:[binary:3866,3804] 
    p(_v15225:E)
#53(weight=2):
  3873:[binary:3866,3784] 
    q(_v15226:E)
#54(weight=10):
  2052:[factor:1233] 
    ~(p(#c-18.E)) | ~(q(#f-22.E(#c-24.E))) | 
    ~(p(#f-16.E(#c-18.E))) | ~(q(#c-24.E))
 
** EMPTY CLAUSE__________________________
 
  3874:[binary:2052,3872,unit-del:3873,3872,3873] 
    
 
** PROOF ________________________________
 
  6:[] p(_v718:E) | ~(q(_v719:E)) | p(_v720:E) | 
       p(#f-1.E(_v720:E)) | ~(q(_v721:E)) | 
       ~(q(#f-7.E(_v721:E))) | ~(q(#c-8.E)) | 
       p(#c-9.E)
  11:[] q(#c-3.E) | ~(p(#c-2.E)) | ~(p(_v861:E)) | 
        ~(p(#f-1.E(_v861:E))) | q(_v862:E) | 
        q(#f-7.E(_v862:E)) | ~(p(_v860:E)) | 
        q(_v863:E)
  17:[fsimp:fsimp:fsimp] 
    p(#f-1.E(_v1095:E)) | ~(q(_v1094:E)) | 
    p(_v1095:E) | q(#c-12.E) | p(#c-10.E)
  18:[fsimp:fsimp:fsimp] 
    p(#f-1.E(_v1142:E)) | ~(q(#c-12.E)) | 
    p(_v1142:E) | q(_v1141:E) | p(#c-10.E)
  33:[] p(_v1487:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
        p(_v1488:E) | q(_v1489:E) | q(#f-7.E(_v1489:E)) | 
        ~(p(_v1486:E)) | q(_v1490:E)
  35:[] p(#c-6.E) | ~(p(_v1571:E)) | q(#c-4.E) | 
        p(_v1572:E) | q(_v1573:E) | q(#f-7.E(_v1573:E)) | 
        ~(p(_v1570:E)) | q(_v1574:E)
  65:[fsimp:fsimp:fsimp:fsimp] 
    p(_v2326:E) | ~(q(_v2327:E)) | ~(p(#c-13.E)) | 
    q(#c-19.E)
  69:[fsimp:fsimp:fsimp:fsimp] 
    p(_v2415:E) | ~(q(#c-19.E)) | ~(p(#c-13.E)) | 
    q(_v2416:E)
  73:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(_v2506:E)) | ~(p(_v2505:E)) | 
    q(#c-19.E)
  77:[fsimp:fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(#c-19.E)) | ~(p(_v2596:E)) | 
    q(_v2597:E)
  86:[fsimp:fsimp:fsimp] 
    p(_v2850:E) | ~(q(#f-22.E(_v2849:E))) | 
    ~(p(#c-13.E)) | ~(q(_v2849:E)) | ~(q(#c-24.E))
  94:[fsimp:fsimp:fsimp] 
    p(#c-13.E) | ~(q(#f-22.E(_v3084:E))) | 
    ~(p(_v3085:E)) | ~(q(_v3084:E)) | ~(q(#c-24.E))
  107:[] ~(p(#c-18.E)) | ~(q(_v3357:E)) | 
         ~(p(_v3358:E)) | ~(p(#f-16.E(_v3358:E))) | 
         q(#c-19.E) | ~(q(_v3359:E)) | ~(p(_v3356:E)) | 
         q(_v3360:E)
  111:[] ~(p(#c-18.E)) | ~(q(_v3483:E)) | 
         ~(p(_v3484:E)) | ~(p(#f-16.E(_v3484:E))) | 
         q(_v3482:E) | ~(q(#c-19.E)) | ~(p(_v3481:E)) | 
         q(_v3485:E)
  113:[] p(_v3561:E) | q(#c-17.E) | p(_v3562:E) | 
         p(#f-16.E(_v3562:E)) | q(_v3563:E) | 
         q(#f-22.E(_v3563:E)) | p(#c-23.E) | 
         q(_v3564:E)
  128:[] ~(p(#c-18.E)) | ~(q(_v4016:E)) | 
         ~(p(_v4017:E)) | ~(p(#f-16.E(_v4017:E))) | 
         ~(q(_v4018:E)) | ~(q(#f-22.E(_v4018:E))) | 
         ~(p(_v4015:E)) | ~(q(#c-24.E))
  744:[factor:6,fsimp:fsimp] 
    p(#c-9.E) | ~(q(#f-7.E(_v4536:E))) | 
    p(#f-1.E(#c-9.E)) | ~(q(_v4536:E)) | 
    ~(q(#c-8.E))
  783:[factor:11] q(#c-3.E) | ~(p(#c-2.E)) | 
                  ~(p(_v4606:E)) | ~(p(#f-1.E(_v4606:E))) | 
                  q(#f-7.E(#c-3.E)) | ~(p(_v4605:E)) | 
                  q(_v4607:E)
  859:[factor:17] p(#f-1.E(#c-10.E)) | ~(q(_v4934:E)) | 
                  p(#c-10.E) | q(#c-12.E)
  860:[factor:18] p(#f-1.E(#c-10.E)) | ~(q(#c-12.E)) | 
                  p(#c-10.E) | q(_v4938:E)
  915:[factor:33,fsimp:fsimp:fsimp] 
    p(_v5257:E) | ~(p(#c-6.E)) | q(#c-4.E) | 
    q(#f-7.E(#c-4.E))
  955:[factor:35,fsimp:fsimp:fsimp] 
    p(#c-6.E) | ~(p(_v5508:E)) | q(#c-4.E) | 
    q(#f-7.E(#c-4.E))
  1012:[factor:86] p(_v5700:E) | ~(q(#f-22.E(#c-24.E))) | 
                   ~(p(#c-13.E)) | ~(q(#c-24.E))
  1042:[factor:94] p(#c-13.E) | ~(q(#f-22.E(#c-24.E))) | 
                   ~(p(_v5803:E)) | ~(q(#c-24.E))
  1045:[factor:107,fsimp:fsimp:fsimp] 
    ~(p(#c-18.E)) | ~(q(_v5870:E)) | ~(p(#f-16.E(#c-18.E))) | 
    q(#c-19.E)
  1085:[factor:111,fsimp:fsimp:fsimp] 
    ~(p(#c-18.E)) | ~(q(#c-19.E)) | ~(p(#f-16.E(#c-18.E))) | 
    q(_v6123:E)
  1122:[factor:113,fsimp:fsimp] 
    p(#f-16.E(_v6439:E)) | q(#c-17.E) | 
    p(_v6439:E) | q(#f-22.E(#c-17.E)) | 
    p(#c-23.E)
  1233:[factor:128,fsimp:fsimp] 
    ~(p(#c-18.E)) | ~(q(#f-22.E(_v7048:E))) | 
    ~(p(#f-16.E(#c-18.E))) | ~(q(_v7048:E)) | 
    ~(q(#c-24.E))
  1311:[factor:744] p(#c-9.E) | ~(q(#f-7.E(#c-8.E))) | 
                    p(#f-1.E(#c-9.E)) | 
                    ~(q(#c-8.E))
  1314:[factor:783,fsimp:fsimp] 
    q(#c-3.E) | ~(p(#c-2.E)) | ~(p(#f-1.E(#c-2.E))) | 
    q(#f-7.E(#c-3.E))
  1927:[factor:1122] 
    p(#f-16.E(#c-23.E)) | q(#c-17.E) | p(#c-23.E) | 
    q(#f-22.E(#c-17.E))
  2052:[factor:1233] 
    ~(p(#c-18.E)) | ~(q(#f-22.E(#c-24.E))) | 
    ~(p(#f-16.E(#c-18.E))) | ~(q(#c-24.E))
  3304:[binary:69,65,fsimp:fsimp] 
    ~(p(#c-13.E)) | ~(q(_v13936:E)) | p(_v13935:E) | 
    q(_v13937:E)
  3352:[binary:77,73,fsimp:fsimp] 
    ~(p(_v14025:E)) | ~(q(_v14026:E)) | 
    p(#c-13.E) | q(_v14027:E)
  3426:[binary:3352,3304,fsimp:fsimp] 
    q(_v14218:E) | p(_v14219:E) | ~(q(_v14217:E)) | 
    ~(p(_v14220:E))
  3451:[binary:859,3426,fsimp:fsimp:fsimp] 
    ~(q(_v14331:E)) | p(#c-10.E) | q(#c-12.E)
  3473:[binary:3451,3426,fsimp:fsimp] 
    ~(q(_v14391:E)) | p(_v14390:E) | q(#c-12.E)
  3491:[binary:860,3426,fsimp:fsimp:fsimp] 
    ~(q(#c-12.E)) | p(#c-10.E) | q(_v14464:E)
  3517:[binary:3491,3473,fsimp] 
    p(#c-10.E) | ~(q(_v14529:E)) | q(_v14530:E)
  3528:[binary:3517,3426,fsimp:fsimp] 
    ~(q(_v14573:E)) | p(_v14572:E) | q(_v14574:E)
  3558:[binary:915,3528,fsimp:fsimp] 
    q(#c-4.E) | p(_v14655:E) | ~(p(#c-6.E))
  3561:[binary:3558,3528,fsimp] 
    q(_v14662:E) | p(_v14661:E) | ~(p(#c-6.E))
  3592:[binary:955,3528,fsimp:fsimp] 
    q(#c-4.E) | p(#c-6.E) | ~(p(_v14730:E))
  3595:[binary:3592,3528,fsimp] 
    q(_v14737:E) | p(#c-6.E) | ~(p(_v14738:E))
  3611:[binary:3595,3561,fsimp] 
    p(_v14773:E) | q(_v14772:E) | ~(p(_v14774:E))
  3631:[binary:1012,3611,fsimp:fsimp] 
    ~(p(#c-13.E)) | p(_v14832:E) | ~(q(#c-24.E))
  3657:[binary:3631,3611,fsimp:fsimp] 
    ~(p(#c-13.E)) | p(_v14896:E)
  3672:[binary:1042,3611,fsimp:fsimp] 
    ~(p(_v14926:E)) | p(#c-13.E) | ~(q(#c-24.E))
  3701:[binary:3672,3611,fsimp:fsimp] 
    ~(p(_v14987:E)) | p(#c-13.E)
  3711:[binary:3701,3657] 
    p(_v15000:E) | ~(p(_v15001:E))
  3725:[binary:1045,3711,fsimp] 
    ~(p(#c-18.E)) | q(#c-19.E) | ~(q(_v15031:E))
  3735:[binary:3725,3528,fsimp:fsimp] 
    q(#c-19.E) | ~(q(_v15056:E))
  3758:[binary:1085,3711,fsimp] 
    ~(p(#c-18.E)) | q(_v15091:E) | ~(q(#c-19.E))
  3769:[binary:3758,3528,fsimp:fsimp] 
    q(_v15115:E) | ~(q(#c-19.E))
  3784:[binary:3769,3735] 
    ~(q(_v15125:E)) | q(_v15126:E)
  3790:[binary:1311,3784,fsimp] 
    ~(q(#c-8.E)) | p(#f-1.E(#c-9.E)) | p(#c-9.E)
  3797:[binary:3790,3711,fsimp] 
    p(#c-9.E) | ~(q(#c-8.E))
  3801:[binary:3797,3711] 
    p(_v15145:E) | ~(q(#c-8.E))
  3804:[binary:3801,3784] 
    ~(q(_v15148:E)) | p(_v15149:E)
  3814:[binary:1314,3711,fsimp] 
    ~(p(#c-2.E)) | q(#f-7.E(#c-3.E)) | q(#c-3.E)
  3822:[binary:3814,3784,fsimp] 
    q(#c-3.E) | ~(p(#c-2.E))
  3828:[binary:3822,3784] 
    q(_v15175:E) | ~(p(#c-2.E))
  3834:[binary:3828,3711] 
    ~(p(_v15182:E)) | q(_v15183:E)
  3839:[binary:1927,3834,fsimp] 
    q(#f-22.E(#c-17.E)) | p(#c-23.E) | q(#c-17.E)
  3855:[binary:3839,3804,fsimp] 
    p(#c-23.E) | q(#c-17.E)
  3866:[binary:3855,3834,fsimp] 
    q(#c-17.E)
  3872:[binary:3866,3804] 
    p(_v15225:E)
  3873:[binary:3866,3784] 
    q(_v15226:E)
  3874:[binary:2052,3872,unit-del:3873,3872,3873] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........54  |
|  clauses generated        .....1,485  |
|  clauses kept             .......786  |
|  clauses forward subsumed .......720  |
|  clauses back subsumed    .......700  |
+---------------------------------------+
(total run time 12.630 sec)
\end{verbatim}
    }
\item 上のログを見て, 検査仕様に定めらていた以下の項目が
  確認できた.
  \begin{itemize}
    \item binary resolution を用いた証明過程：
      \begin{itemize}
      \item 証明に成功している. 
      \item 導出節や, 証明木を見ると, 推論には指定通り binary resolution
        が用いられている.
      \item unit deletion や, factoring が有効となっている.
        導出節の履歴欄を見ると, fsimp, factor, unit-del があり,
        実際にただしく使われている事が分かる.
      \end{itemize}
    \item 情報表示：
      \begin{itemize}
      \item 処理状況(今度のフェーズを実行しているか), が適切に
        表示されている.
      \item usable および, sos 節集合の一覧が表示されている.
        またそれらに対する初期の入力節処理の内容が表示されている.
      \item 推論過程では, 処理対象となっている given clause が表示
        されている. 付加的情報として, 節の重みも表示されている.
      \item 終了条件となった空節の発見についてのメッセージが適切に
        表示されている.
      \end{itemize}
    \item 証明木の表示：
      \begin{itemize}
      \item 見出しと併せて, 証明木が正しく表示されている
      \item 表示は節の導出履歴にしたがって古いものから新しいものの順に
        正しく表示されている.
      \end{itemize}
    \item 統計情報の表示：
      \begin{itemize}
      \item 見出しとともに, システムの収集した統計情報が表示されている.
        表示のレベルは, 既定値のパラメータに従い簡略したものである.
      \end{itemize}
  \end{itemize}
\end{enumerate}

\subsection{Hyper Resolution}
\label{sec:hyper-res}
\subsubsection{検査内容}
ここでは, Hyper resolution を推論規則として用いた場合の
システム動作の検証を行う.
ここでは, 自動モードによる適切な推論規則の選択についても
検査する. また, Demodulation 処理についても検査を行う.

\begin{enumerate}
\item Hyper resolution を推論規則として用いるような
  スクリプトを用意し, システムで実行する.
  実行モードは自動モードとし, この時に適切に hyper resolution
  が選ばれている事を確認する.
  \begin{itemize}
  \item 自動モードの動作：
    \begin{itemize}
    \item 正しく入力節の特性を分析し, 適切な推論規則を
      選択していること.
    \end{itemize}
  \item hyper resolution の動作：
    \begin{itemize}
    \item 自動モードで hyper resolution が推論ルールとして
      選択されており, 実際にこれを用いた推論が実行されている事.
    \item 結果として反駁に成功していること.
    \end{itemize}
  \item Demodulation の動作：
    \begin{itemize}
    \item demodulation 処理,
      back demodulation 処理が適切に実行されていること.
    \end{itemize}
  \item 統計情報の表示機能:
    \begin{itemize}
    \item 詳細な統計情報表示を指示した場合に, それにしたがった
      統計情報が表示されていること.
    \end{itemize}
  \end{itemize}
\end{enumerate}
\subsubsection{テストデータと手順}
\label{sec:hyper-res-data}
\begin{enumerate}
\item 下に示すモジュール宣言, スクリプトを書き込んだファイル
  ``hyper-res.mod'' を用意する.
  {\small
\begin{verbatim}
**>
**> Hyper Resolution 検査
**> Otter3.0.5 の例題を CafeOBJ へ変換したもの．
**> 

module! WANG
{ 
  protecting (FOPL-CLAUSE)
  [ E ]

  ops m b k : -> E
  pred p : E E
  ops f g : E -> E

  vars x y z v v1 : E

  ax y = m | p(y,m) | v1 = m | v1 = y | ~ p(y,v1) | ~ p(v1,y).
  ax y = b | ~ p(y,b) | v = b | v = y | ~ p(y,v) | ~ p(v,y).
  ax y = k | y = m | y = b | ~ p(y,k).
  ax y = m | ~ p(y,m) | ~(f(y) = m) .
  ax y = m | ~ p(y,m) | ~(f(y) = y) .
  ax y = m | ~ p(y,m) | p(y,f(y)).
  ax y = m | ~ p(y,m) | p(f(y),y).
  ax y = b | ~ p(y,b) | ~(g(y) = b) .
  ax y = b | p(y,b) | ~(g(y) = y) .
  ax y = b | p(y,b) | p(y,g(y)).
  ax y = b | p(y,b) | p(g(y),y).
  ax y = k | ~(y = m) | p(y,k).
  ax y = k | ~(y = b) | p(y,k).
  ax x = x .
  ax ~(x = y) | y = x .
  ax ~(x = y) | ~(y = z) | x = z .
  ax ~(x = y) | ~ p(x,z) | p(y,z).
  ax ~(x = y) | ~ p(z,x) | p(z,y).
  ax ~(x = y) | f(x) = f(y).
  ax ~(x = y) | g(x) = g(y).
  **

  ax ~(m = b).
  ax ~(b = k).
  ax ~(k = m).
}

**> オプションのリセット
option reset
**> auto モードで実行する．
flag (auto,on)
**> 詳細な統計情報を印字するように設定する．
param (stats-level,4)

open WANG
**> 反駁エンジンの起動
resolve .
close
--
eof
\end{verbatim}
    }
\item 上で示したファイルをシステムにロードし, 結果を見る.
  このとき, 以下の点について検査を行う：
  \begin{itemize}
  \item auto(自動) モードの動作：\\
    上の例題の場合, 以下のように推論ルールが選択されて
    いなければならない：
    \begin{enumerate}
    \item hyper resolution を用いる
    \item unit-deletion, factor 機能を用いる
    \item demodulation 機能を用いる
    \item paramodulation は用いられない
    \end{enumerate}
  \item hyper resolution の動作:\\
    推論に実際に hyper resolution が使われており, 正しく
    実行されていること. 結果として反駁に成功していること.
  \item demodulatoin の動作:\\
    推論中に demodulation 処理が正しく実行されており
    導出節の履歴にそれが反映されていること.
  \item 統計情報表示:\\
    詳細な統計情報が表示されていること.
  \end{itemize}
\end{enumerate}
\subsubsection{実行結果}
\begin{enumerate}
\item 第\ref{sec:hyper-res-data}節で示されたファイル ``hyper-res.mod''
  をシステムにロードした. 結果は下の通りである：
  {\small
\begin{verbatim}
CafeOBJ> processing input : ./hyper-res.mod
**> 
**> Hyper Resolution 検査
**> Otter3.0.5 の例題を CafeOBJ へ変換したもの．
**> 
-- defining module! WANG........._.......................* done.
**> オプションのリセット
**> auto モードで実行する．
-- setting flag "auto" to "on"
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
**> 詳細な統計情報を印字するように設定する．
-- setting parameter "stats-level" to 4.
-- opening module WANG.. done.
**> 反駁エンジンの起動
[Properties of input clauses]:
   propositional  = no
   horn           = no
   equality       = yes
   symmetry       = yes
   max literals   = 6
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
   dependent: flag(hyper-res, on)
   dependent: flag(unit-deletion, on)
   dependent: flag(factor, on)
-- Paramodulation is disabled, because there is a clause
   for symmetry of equality.
   dependent: flag(para-from, off)
   dependent: flag(para-into, off)
 
** start input processing.

 
** USABLE _______________________________
 
  1:[] _v4:E = m | p(_v4:E,m) | _v3:E = m | _v3:E = _v4:E | 
       ~(p(_v4:E,_v3:E)) | ~(p(_v3:E,_v4:E))
  2:[] _v8:E = b | ~(p(_v8:E,b)) | _v7:E = b | _v7:E = _v8:E | 
       ~(p(_v8:E,_v7:E)) | ~(p(_v7:E,_v8:E))
  3:[] _v10:E = k | _v10:E = m | _v10:E = b | ~(p(_v10:E,k))
  4:[] _v12:E = m | ~(p(_v12:E,m)) | ~(f(_v12:E) = m)
  5:[] _v14:E = m | ~(p(_v14:E,m)) | ~(f(_v14:E) = _v14)
  6:[] _v16:E = m | ~(p(_v16:E,m)) | p(_v16:E,f(_v16))
  7:[] _v18:E = m | ~(p(_v18:E,m)) | p(f(_v18:E),_v18)
  8:[] _v20:E = b | ~(p(_v20:E,b)) | ~(g(_v20:E) = b)
  9:[] _v22:E = b | p(_v22:E,b) | ~(g(_v22:E) = _v22)
  12:[] _v28:E = k | ~(_v28:E = m) | p(_v28:E,k)
  13:[] _v30:E = k | ~(_v30:E = b) | p(_v30:E,k)
  15:[] ~(_v36:E = _v35:E) | _v35:E = _v36:E
  16:[] ~(_v41:E = _v40:E) | ~(_v40:E = _v42:E) | _v41:E = _v42:E
  17:[] ~(_v46:E = _v47:E) | ~(p(_v46:E,_v48:E)) | p(_v47:E,
                                                     _v48:E)
  18:[] ~(_v52:E = _v54:E) | ~(p(_v53:E,_v52:E)) | p(_v53:E,
                                                     _v54:E)
  19:[] ~(_v57:E = _v58:E) | f(_v57:E) = f(_v58:E)
  20:[] ~(_v61:E = _v62:E) | g(_v61:E) = g(_v62:E)
  21:[] ~(m = b)
  22:[] ~(b = k)
  23:[] ~(k = m)
 
 process usable:
* kept in usable : weight=18
  1:[] _v66:E = m | p(_v66:E,m) | _v65:E = m | _v65:E = _v66:E | 
       ~(p(_v66:E,_v65:E)) | ~(p(_v65:E,_v66:E))
* kept in usable : weight=18
  2:[] _v81:E = b | ~(p(_v81:E,b)) | _v80:E = b | _v80:E = _v81:E | 
       ~(p(_v81:E,_v80:E)) | ~(p(_v80:E,_v81:E))
* kept in usable : weight=12
  3:[] _v99:E = k | _v99:E = m | _v99:E = b | ~(p(_v99:E,k))
* kept in usable : weight=10
  4:[] _v101:E = m | ~(p(_v101:E,m)) | ~(f(_v101:E) = m)
* kept in usable : weight=10
  5:[] _v103:E = m | ~(p(_v103:E,m)) | ~(f(_v103:E) = _v103)
* kept in usable : weight=10
  6:[] _v105:E = m | ~(p(_v105:E,m)) | p(_v105:E,f(_v105))
* kept in usable : weight=10
  7:[] _v107:E = m | ~(p(_v107:E,m)) | p(f(_v107:E),_v107)
* kept in usable : weight=10
  8:[] _v109:E = b | ~(p(_v109:E,b)) | ~(g(_v109:E) = b)
* kept in usable : weight=10
  9:[] _v111:E = b | p(_v111:E,b) | ~(g(_v111:E) = _v111)
* kept in usable : weight=9
  12:[] _v113:E = k | ~(_v113:E = m) | p(_v113:E,k)
* kept in usable : weight=9
  13:[] _v115:E = k | ~(_v115:E = b) | p(_v115:E,k)
* kept in usable : weight=6
  15:[] ~(_v119:E = _v118:E) | _v118:E = _v119:E
* kept in usable : weight=9
  16:[] ~(_v124:E = _v123:E) | ~(_v123:E = _v125:E) | _v124:E 
                                                      = _v125:E
* kept in usable : weight=9
  17:[] ~(_v133:E = _v134:E) | ~(p(_v133:E,_v135:E)) | p(_v134:E,
                                                         _v135:E)
* kept in usable : weight=9
  18:[] ~(_v139:E = _v141:E) | ~(p(_v140:E,_v139:E)) | p(_v140:E,
                                                         _v141:E)
* kept in usable : weight=8
  19:[] ~(_v144:E = _v145:E) | f(_v144:E) = f(_v145:E)
* kept in usable : weight=8
  20:[] ~(_v148:E = _v149:E) | g(_v148:E) = g(_v149:E)
* kept in usable : weight=3
  21:[] ~(m = b)
* kept in usable : weight=3
  22:[flip] ~(k = b)
* kept in usable : weight=3
  23:[flip] ~(m = k)
 
** SOS __________________________________
 
  10:[] _v24:E = b | p(_v24:E,b) | p(_v24:E,g(_v24))
  11:[] _v26:E = b | p(_v26:E,b) | p(g(_v26:E),_v26)
  14:[] _v32:E = _v32
 
 process sos:
* kept in sos : weight=10
  10:[] _v224:E = b | p(_v224:E,b) | p(_v224:E,g(_v224))
* kept in sos : weight=10
  11:[] _v226:E = b | p(_v226:E,b) | p(g(_v226:E),_v226)
* kept in sos : weight=3
  14:[] _v228:E = _v228
-- following clause subsumed by 14 during input processing:
  121:[copy:14,flip] _v230:E = _v230
-- 14 backsubsumes 70.
-- 14 backsubsumes 69.
-- 14 backsubsumes 68.
-- 14 backsubsumes 57.
-- 14 backsubsumes 55.
 

** end process input.

 
** Starting PigNose _____________________
 
#1(weight=10):
  10:[] _v224:E = b | p(_v224:E,b) | p(_v224:E,g(_v224))
#2(weight=3):
  14:[] _v228:E = _v228
#3(weight=3):
  236:[hyper:14,13,unit-del:22] 
    p(b,k)
#4(weight=3):
  237:[hyper:14,12,unit-del:23] 
    p(m,k)
#5(weight=7):
  249:[hyper:236,1,10,unit-del:22,21,23,22] 
    p(k,g(k)) | p(k,m)
#6(weight=10):
  11:[] _v226:E = b | p(_v226:E,b) | p(g(_v226:E),_v226)
#7(weight=4):
  271:[hyper:249,2,10,237,unit-del:23,21,22,22,fsimp] 
    p(k,g(k))
#8(weight=7):
  487:[hyper:11,1,236,unit-del:22,22,23,21] 
    p(b,m) | p(g(k),k)
#9(weight=7):
  499:[hyper:11,1,236,unit-del:22,22,21,23] 
    p(k,m) | p(g(k),k)
#10(weight=4):
  709:[hyper:499,2,11,237,unit-del:23,21,22,22,fsimp] 
    p(g(k),k)
#11(weight=20):
  392:[hyper:11,2,11,10,fsimp:fsimp:fsimp:fsimp] 
    p(g(g(_v323:E)),g(_v323)) | g(_v323:E) = b | g(_v323:E) 
                                                 = _v323 | _v323:E 
                                                           = 
                                                           b | 
    p(_v323:E,b)
#12(weight=11):
  739:[hyper:499,1,271,unit-del:23,fsimp] 
    p(k,m) | g(k) = m | g(k) = k
#13(weight=12):
  747:[hyper:709,3] g(k) = b | g(k) = m | g(k) = k
#14(weight=11):
  1455:[hyper:747,18,271] g(k) = k | g(k) = m | p(k,b)
#15(weight=8):
  1522:[hyper:1455,8,747,unit-del:22,fsimp:fsimp] 
    g(k) = k | g(k) = m
#16(weight=13):
  507:[hyper:11,7,unit-del:21] 
    g(m) = m | p(f(g(m)),g(m)) | p(m,b)
#17(weight=7):
  1583:[hyper:1522,18,271] g(k) = m | p(k,k)
#18(weight=7):
  1595:[hyper:1522,9,unit-del:22] 
    p(k,b) | g(k) = m
#19(weight=7):
  1600:[hyper:1522,18,271] g(k) = k | p(k,m)
#20(weight=7):
  1736:[hyper:1595,1,236,unit-del:22,23,21] 
    p(b,m) | g(k) = m
#21(weight=13):
  508:[hyper:11,6,unit-del:21] 
    g(m) = m | p(g(m),f(g(m))) | p(m,b)
#22(weight=7):
  1737:[hyper:1595,1,236,unit-del:22,21,23] 
    p(k,m) | g(k) = m
#23(weight=3):
  1971:[back-demod:1965,1600,unit-del:23] 
    p(k,m)
#24(weight=4):
  1965:[hyper:1737,2,1595,237,unit-del:23,21,22,fsimp] 
    g(k) = m
#25(weight=4):
  1982:[back-demod:1965,756,unit-del:21,23] 
    p(g(m),m)
#26(weight=20):
  560:[hyper:11,2,10,10,fsimp:fsimp:fsimp:fsimp] 
    p(_v418:E,b) | _v418:E = b | g(_v418:E) = _v418 | g(_v418:E) 
                                                      = b | 
    p(g(_v418:E),g(g(_v418)))
#27(weight=4):
  1983:[back-demod:1965,762,unit-del:21,23] 
    p(m,g(m))
#28(weight=4):
  2002:[back-demod:1965,1740,unit-del:23] 
    p(f(k),k)
#29(weight=4):
  2003:[back-demod:1965,1741,unit-del:23] 
    p(k,f(k))
#30(weight=10):
  2007:[back-demod:1965,1751,unit-del:23] 
    g(m) = m | p(f(g(m)),g(m))
#31(weight=20):
  608:[hyper:11,1,10,fsimp:fsimp] 
    p(_v441:E,b) | _v441:E = b | g(_v441:E) = _v441 | g(_v441:E) 
                                                      = m | 
    p(_v441:E,m) | _v441:E = m
#32(weight=10):
  2010:[back-demod:1965,1928,unit-del:23] 
    p(g(m),f(g(m))) | g(m) = m
#33(weight=12):
  3318:[hyper:2002,3] f(k) = b | f(k) = m | f(k) = k
#34(weight=8):
  5561:[hyper:3318,4,1971,unit-del:23] 
    f(k) = b | f(k) = k
#35(weight=3):
  5632:[back-demod:5630,2003] p(k,b)
 
** EMPTY CLAUSE__________________________
 
  5725:[hyper:5632,2,1971,237,unit-del:23,21,22] 
    
 
** PROOF ________________________________
 
  1:[] _v66:E = m | p(_v66:E,m) | _v65:E = m | _v65:E = _v66:E | 
       ~(p(_v66:E,_v65:E)) | ~(p(_v65:E,_v66:E))
  2:[] _v81:E = b | ~(p(_v81:E,b)) | _v80:E = b | _v80:E = _v81:E | 
       ~(p(_v81:E,_v80:E)) | ~(p(_v80:E,_v81:E))
  3:[] _v99:E = k | _v99:E = m | _v99:E = b | ~(p(_v99:E,k))
  4:[] _v101:E = m | ~(p(_v101:E,m)) | ~(f(_v101:E) = m)
  5:[] _v103:E = m | ~(p(_v103:E,m)) | ~(f(_v103:E) = _v103)
  6:[] _v105:E = m | ~(p(_v105:E,m)) | p(_v105:E,f(_v105))
  7:[] _v107:E = m | ~(p(_v107:E,m)) | p(f(_v107:E),_v107)
  8:[] _v109:E = b | ~(p(_v109:E,b)) | ~(g(_v109:E) = b)
  9:[] _v111:E = b | p(_v111:E,b) | ~(g(_v111:E) = _v111)
  10:[] _v224:E = b | p(_v224:E,b) | p(_v224:E,g(_v224))
  11:[] _v226:E = b | p(_v226:E,b) | p(g(_v226:E),_v226)
  12:[] _v113:E = k | ~(_v113:E = m) | p(_v113:E,k)
  13:[] _v115:E = k | ~(_v115:E = b) | p(_v115:E,k)
  14:[] _v228:E = _v228
  18:[] ~(_v139:E = _v141:E) | ~(p(_v140:E,_v139:E)) | p(_v140:E,
                                                         _v141:E)
  21:[] ~(m = b)
  22:[flip] ~(k = b)
  23:[flip] ~(m = k)
  236:[hyper:14,13,unit-del:22] 
    p(b,k)
  237:[hyper:14,12,unit-del:23] 
    p(m,k)
  249:[hyper:236,1,10,unit-del:22,21,23,22] 
    p(k,g(k)) | p(k,m)
  271:[hyper:249,2,10,237,unit-del:23,21,22,22,fsimp:back-demod:1965] 
    p(k,m)
  499:[hyper:11,1,236,unit-del:22,22,21,23] 
    p(k,m) | p(g(k),k)
  709:[hyper:499,2,11,237,unit-del:23,21,22,22,fsimp:back-demod:1965] 
    p(m,k)
  747:[hyper:709,3,back-demod:1965] 
    m = b | m = m | m = k
  1455:[hyper:747,18,271] g(k) = k | g(k) = m | p(k,b)
  1522:[hyper:1455,8,747,unit-del:22,fsimp:fsimp:back-demod:1965] 
    m = k | m = m
  1595:[hyper:1522,9,unit-del:22,back-demod:1965] 
    p(k,b) | m = m
  1600:[hyper:1522,18,271,back-demod:1965] 
    m = k | p(k,m)
  1737:[hyper:1595,1,236,unit-del:22,21,23,back-demod:1965] 
    p(k,m) | m = m
  1740:[hyper:1600,7,unit-del:23,back-demod:1965] 
    p(f(k),k) | m = k
  1741:[hyper:1600,6,unit-del:23,back-demod:1965] 
    p(k,f(k)) | m = k
  1965:[hyper:1737,2,1595,237,unit-del:23,21,22,fsimp] 
    g(k) = m
  1971:[back-demod:1965,1600,unit-del:23] 
    p(k,m)
  2002:[back-demod:1965,1740,unit-del:23,back-demod:5630] 
    p(b,k)
  2003:[back-demod:1965,1741,unit-del:23,back-demod:5630] 
    p(k,b)
  3318:[hyper:2002,3,back-demod:5630] 
    b = b | b = m | b = k
  5561:[hyper:3318,4,1971,unit-del:23,back-demod:5630] 
    b = b | b = k
  5630:[hyper:5561,5,1971,unit-del:23] 
    f(k) = b
  5632:[back-demod:5630,2003] p(k,b)
  5725:[hyper:5632,2,1971,237,unit-del:23,21,22] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........35  |
|  clauses generated        .....1,271  |
|    binary-res generated   .........0  |
|    hyper-res generated    .....1,230  |
|    factors generated      ........41  |
|  demod rewrites           .......534  |
|  clauses wt,lit.sk delete .........0  |
|  tautologies deleted      .........5  |
|  clauses forward subsumed .....1,172  |
|    (subsumed by sos)      .......287  |
|  unit deletions           .....2,229  |
|  factor simplifications   .....3,081  |
|  clauses kept             .......202  |
|  new demodulators         .........2  |
|  empty clauses            .........1  |
|  clauses back demodulated ........85  |
|  clauses back subsumed    ........45  |
|  usable size              ........37  |
|  sos size                 ........42  |
|  demodulators size        .........2  |
+---------------------------------------+
(total run time 2.660 sec)
\end{verbatim}
    }
\item 上の実行結果は検査仕様で期待された通りである：
  \begin{itemize}
  \item auto モードの動作 
    \begin{itemize}
    \item hyper resolition, factoring, unit deletion 処理が
      選択されている.
    \item paramodulation は抑制されている.
    \item demodulation 機能が選択されている.
    \end{itemize}
  \item hyper resolution の動作:\\
    実際に hyper resolution が用いられ, ログを見ると正しく実行
    されている. また, 結果は反駁に成功し, 証明木が印字されている.
  \item demodulation の動作：\\
    demodulation が実行されている. 導出履歴にもその旨記載がある.
    また, ログを見る事によって正しく動作していることが確認できる.
  \item 統計情報の表示:\\
    詳細な統計情報がパラメータの指示にしたがって, 正しく表示されている.
  \end{itemize}
\end{enumerate}

\subsection{Paramodulation}
\label{sec:paramod}
ここでは paramodulation を推論ルールとして用いたシステム動作の
検査を行う. 検査は自動モードを用いて行い, 推論ルールとして
paramodulation が選択されることで, 自動モードの動作検証も
併せて実行する.

\subsubsection{検査内容}
\begin{enumerate}
\item Paramodulation だけを用いて証明できる問題を用意する.
\item これをシステムにかけ, paramodulation 機能が正しく実現されて
  いるか否かを検査する.
\item 推論ルールの選択には auto (自動モード) を用い,
  正しく paramodulation が選択されるか否かを判定する.
\item demodulation 機能が有効とされ, 正しく機能しているか否かを
  検査する.
\end{enumerate}

\subsubsection{テストデータと手順}
\label{sec:paramod-data}
\begin{enumerate}
\item 次のような内容のファイル ``paramod.mod'' を用意する.
  {\small
\begin{verbatim}
**>
**> Paramodulation の検査
**>
--  Robbins algebra
-- 
--  If a Robbins algebra has an element c such that x+c=c,
--  then it is Boolean.
-- 
--  Commutativity, associativity, and Huntington's axiom 
--  axiomatize Boolean algebra.

module! ROBBINS (E :: TRIV)
{
  op _+_ : Elt Elt -> Elt { r-assoc }
  op n : Elt -> Elt
  vars x y z : Elt
  eq x + y = y + x .
  eq (x + y) + z = x + (y + z) .
  eq  n(n(x + y) + n(x + n(y))) = x . -- Robbins axiom
}

**> オプションの初期化
option reset

**> auto モードで実行
flag(auto,on)
flag(universal-symmetry, on)

open ROBBINS
protecting (FOPL-CLAUSE)

ops A B C : -> Elt .

**> 仮定 --- exists a 1
--> eq x + C = C .
eq x + C = C .

**> 証明したい文
--> goal n(A + n(B)) + n(n(A) + n(B)) = B .
goal n(A + n(B)) + n(n(A) + n(B)) = B .

**> 反駁エンジンを起動
resolve .
close
** 
eof
\end{verbatim}
    }
\item 上で示したファイルをシステムにロードし, 結果のログを調べる.
  このとき以下の項目に付いて検査する：
  \begin{itemize}
  \item auto(自動)モードの動作：\\
    この問題を構文的に分析すると(解けるならば) paramodulation のみで
    すむ問題であることが分かる. したがって推論規則は paramodulation のみが
    選択されなければならない.
    ただし, demodulation 機能は有効となるはずである.
  \item paramodulation の動作:\\
    推論に実際に paramodulation が使用され, 正しく動作していること.
  \item demodulation の動作:\\
    demodulation 機能が使用され, 正しく動作していること.
  \end{itemize}
\end{enumerate}

\subsubsection{実行結果}
\begin{enumerate}
\item 第\ref{sec:paramod-data}節で示されたファイル ``paramod.mod'' を
  システムにロードした. 結果は下の通りである.
  {\small
\begin{verbatim}
CafeOBJ> in paramod
processing input : ./paramod.mod
**> 
**> Paramodulation の検査
**> 
-- defining module! ROBBINS_*_*...._...* done.
**> オプションの初期化
**> auto モードで実行
-- setting flag "auto" to "on"
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
-- setting flag "universal-symmetry" to "on"
-- opening module ROBBINS(E).. done.
**> 仮定 --- exists a 1
--> eq x + C = C ._
**> 証明したい文
--> goal n(A + n(B)) + n(n(A) + n(B)) = B .
**> 反駁エンジンを起動*
[Properties of input clauses]:
   propositional  = no
   horn           = yes
   equality       = yes
   symmetry       = no
   max literals   = 1
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
 
** start input processing.

 
** USABLE _______________________________
 
  5:[] ~(n(A + n(B)) + n(n(A) + n(B)) = B)
 
 process usable:
* kept in usable : weight=14
  5:[] ~(n(A + n(B)) + n(n(A) + n(B)) = B)
 
** SOS __________________________________
 
  6:[] Univ319 = Univ319
  1:[] _v4:Elt + _v3:Elt = _v3 + _v4
  2:[] (_v8:Elt + _v9:Elt) + _v10:Elt = _v8 + (_v9 + _v10)
  3:[] n(n(_v14:Elt + _v13:Elt) + n(_v14 + n(_v13))) = _v14
  4:[] _v16:Elt + C = C
 
 process sos:
* kept in sos : weight=3
  6:[] _v18 = _v18
* kept in sos : weight=7
  1:[] _v22:Elt + _v21:Elt = _v21 + _v22
* kept in sos : weight=11
  2:[] (_v26:Elt + _v27:Elt) + _v28:Elt = _v26 + (_v27 + _v28)
* kept in sos : weight=13
  3:[] n(n(_v32:Elt + _v31:Elt) + n(_v32 + n(_v31))) = _v32
* kept in sos : weight=5
  4:[] _v34:Elt + C = C
-- following clause subsumed by 6 during input processing:
  13:[copy:6,flip] _v36 = _v36
-- following clause subsumed by 1 during input processing:
  14:[copy:1,flip] _v40:Elt + _v39:Elt = _v39 + _v40
* starting back demodulation with 2.
* starting back demodulation with 3.
* starting back demodulation with 4.
 
** DEMODULATORS _________________________
 
  (2) (_v26:Elt + _v27:Elt) + _v28:Elt --> _v26:Elt + (_v27:Elt 
                                                       + _v28:Elt)
  (3) n(n(_v32:Elt + _v31:Elt) + n(_v32 + n(_v31))) --> _v32:Elt
  (4) _v34:Elt + C --> C
 

** end process input.

 
** Starting PigNose _____________________
 
#1(weight=3):
  6:[] _v18 = _v18
#2(weight=5):
  4:[] _v34:Elt + C = C
#3(weight=7):
  1:[] _v22:Elt + _v21:Elt = _v21 + _v22
#4(weight=5):
  15:[para-into:1,4,flip] C + _v41:Elt = C
#5(weight=11):
  2:[] (_v26:Elt + _v27:Elt) + _v28:Elt = _v26 + (_v27 + _v28)
#6(weight=13):
  3:[] n(n(_v32:Elt + _v31:Elt) + n(_v32 + n(_v31))) = _v32
#7(weight=8):
  36:[para-into:3,15,demod:15] 
    n(n(C) + n(C)) = C
#8(weight=11):
  27:[para-into:2,1,demod:2] _v55:Elt + (_v54:Elt + _v56:Elt) 
                             = _v54 + (_v55 + _v56)
#9(weight=11):
  29:[para-into:2,1] _v61:Elt + (_v59:Elt + _v60:Elt) = _v59 
                                                        + (_v60 
                                                           + 
                                                           _v61)
#10(weight=11):
  32:[copy:29,flip] _v74:Elt + (_v75:Elt + _v73:Elt) = _v73 
                                                       + (_v74 
                                                          + 
                                                          _v75)
#11(weight=14):
  16:[para-from:1,5] ~(n(n(B) + A) + n(n(A) + n(B)) = B)
#12(weight=11):
  38:[para-into:3,4] n(n(C) + n(_v87:Elt + n(C))) = _v87
#13(weight=11):
  61:[para-into:27,1,demod:2] _v134:Elt + (_v136:Elt + _v135:Elt) 
                              = _v134 + (_v135 + _v136)
#14(weight=11):
  75:[para-into:29,1] _v194:Elt + (_v193:Elt + _v192:Elt) = 
                      _v192 + (_v193 + _v194)
#15(weight=11):
  124:[para-into:38,1] n(n(C) + n(n(C) + _v361:Elt)) = _v361
#16(weight=14):
  17:[para-from:1,5] ~(n(A + n(B)) + n(n(B) + n(A)) = B)
#17(weight=11):
  127:[para-into:38,1] n(n(_v363:Elt + n(C)) + n(C)) = _v363
#18(weight=5):
  232:[back-demod:230,36] n(n(C)) = C
#19(weight=5):
  233:[back-demod:230,38,demod:227] 
    n(n(_v651:Elt)) = _v651
 
** UNIT CONFLICT_________________________
 
  255:[binary:254,6] 
 
** PROOF ________________________________
 
  1:[] _v22:Elt + _v21:Elt = _v21 + _v22
  2:[] (_v26:Elt + _v27:Elt) + _v28:Elt = _v26 + (_v27 + _v28)
  3:[back-demod:250] n(n(_v32:Elt)) = _v32
  4:[] _v34:Elt + C = C
  5:[] ~(n(A + n(B)) + n(n(A) + n(B)) = B)
  6:[] _v18 = _v18
  15:[para-into:1,4,flip] C + _v41:Elt = C
  16:[para-from:1,5] ~(n(n(B) + A) + n(n(A) + n(B)) = B)
  36:[para-into:3,15,demod:15,back-demod:230] 
    n(n(C)) = C
  38:[para-into:3,4,back-demod:230] 
    n(n(_v87:Elt + n(C))) = _v87
  51:[para-from:36,3,demod:4,back-demod:219] 
    _v109:Elt + n(C) = _v109
  118:[para-into:16,1,back-demod:250] 
    ~(n(n(B)) = B)
  127:[para-into:38,1] n(n(_v363:Elt + n(C)) + n(C)) = _v363
  219:[para-into:127,2] n(n(_v636:Elt + (_v637:Elt + n(C))) 
                          + n(C)) = _v636 + _v637
  227:[back-demod:219,51] _v644:Elt + n(C) = _v644
  230:[para-from:127,3,demod:227,4] 
    n(n(C) + _v648:Elt) = n(_v648)
  233:[back-demod:230,38,demod:227] 
    n(n(_v651:Elt)) = _v651
  250:[para-into:233,3,flip] n(_v684:Elt + _v685:Elt) + n(_v684 
                                                          + 
                                                          n(_v685)) 
                             = n(_v684)
  254:[back-demod:250,118,demod:233] 
    ~(B = B)
  255:[binary:254,6] 
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........19  |
|  clauses generated        .......182  |
|  clauses kept             ........80  |
|  clauses forward subsumed .......148  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.440 sec)
\end{verbatim}
    }
\item 上の結果を見ると, 検査使用で期待されている項目が全て満足されている.
  \begin{itemize}
  \item auto モードの動作:\\
    入力節の構文的性質が正しく分析され, 推論規則として paramodulation
    のみが選択されている.
    また, 等式が含まれる事により, demodulation 機能が有効とされている.
  \item paramodulation の動作:\\
    ログを見ると, 実際に paramodulation が使用されており,
    正しく実行されている事が分かる. 
    また, 反駁に成功している.
  \item demodulation の動作:\\
    ログを見ると, 実際に demoduation が機能しており,
    正しく実行されていることが分かる.
  \end{itemize}
\end{enumerate}

\subsection{総合試験}
\label{sec:total-test}
複数の推論ルールを組み合わせなければ解けない問題を対象とし,
システムの総合的な動作を検査する.
なお, 第\ref{sec:spec-test}部の仕様検証システム, および
第\ref{sec:model-check}部のモデル検査システムにおける
定理証明過程は, 反駁システムの機能をトータルに使用している
ため, そこにおける検査は反駁システムの総合試験の意味も持つ.

\subsubsection{検査内容}
\begin{itemize}
\item 複数の推論規則を用いれば解ける問題を
  用意し, これを反駁システムを用いて解く.
\item 結果として反駁に成功することを確認する.
\end{itemize}

\subsubsection{テストデータと手順}
\label{sec:total-data}
\begin{itemize}
\item 下に示す内容のファイル ``total.mod'' を用意する.
  {\small
\begin{verbatim}
**>
**> 検証システム総合検査
**> cache coherence problem by A.Mori (amori@jaist.ac.jp)
**>

**> データを定義したモジュール
module* DATA
{
  [ Index Data ]
}

**> システム状態を示すフラグを定義したモジュール
module! FLAG
{
  [Flag]
  ops invalid vex dirty shared : -> Flag
  -- vex == valid exclusive
}

**> Cache のプロトコルを定義したモジュール
**>
module* PROTOCOL
{
  protecting (BOOL + DATA + FLAG)
  *[Protocol]*
  bop flag  : Index Protocol -> Flag    -- cache state
  bop cdata : Index Protocol -> Data    -- cache value
  bop mdata : Protocol -> Data         -- memory value
  bop read  : Index Protocol -> Protocol
  bop write : Index Data Protocol -> Protocol
  op init   : -> Protocol

  vars I J K : Index
  vars M N : Data
  var P : Protocol
  -- initial state
  eq flag(I, init) = invalid .
  -- write
  eq cdata(I, write(I,M,P)) = M .
  ceq cdata(J,write(I,M,P)) = cdata(J,P) if not(I == J) .
  eq flag(J, write(J,M,P)) = dirty .
    -- invalidation
  ceq flag(J, write(I,M,P)) = invalid if not(I == J) .
  eq mdata(write(I,M,P)) = mdata(P) .
  -- read
    -- read hit
  bceq read(I,P) = P if not(flag(I,P) == invalid) .
    -- if there is a dirty copy Cj then
    -- Cj provides the missig block.
  eq cdata(I, read(I, write(J,M,P))) = M . 
  eq mdata(read(I, write(J,M,P))) = mdata(P) .
  ceq flag(I,read(I,write(J,M,P))) = shared if not(I == J) .
  ceq flag(J,read(I,write(J,M,P))) = shared if not(I == J) .
    -- if there is a clean copy Cj then
  ceq cdata(I,read(I,read(J,P))) = cdata(J,read(J,P)) if not(I == J) .
    -- Cj provides the missing block
  ceq flag(I,read(I,read(J,P))) = shared if not(I == J) .
  ceq flag(J,read(I,read(J,P))) = shared if not(I == J) .
  -- independence
  beq read(I,read(I,P)) = read(I,P) .
  ceq flag(I,read(J,read(K,P))) = flag(I, read(K,P))
      if not(I == J) and not(I == K) .
  ceq cdata(I,read(J,P)) = cdata(I,P) if not(I == J) .
  eq mdata(read(I,P)) = mdata(P) .
  -- if there is no cached copy (i.e., only in initial state)
  eq cdata(I,read(I,init)) = mdata(init) .
  eq flag(I,read(I,init)) = vex .
  eq mdata(read(I,init)) = mdata(init) .
}

**> Cache のプロトコルに関して, 保証すべき性質 P を
**> 表現するモジュール.
**> P の意味は, cache X において, インデクス I と J で
**> さされるポイントの状態がともに shared ならば,
**> それらのデータ値が等しい, というものである.
**> 以下では, この性質がシステム状態の変化によらず,
**> 常に保証される事を証明する.

module PROOF
{
  protecting (PROTOCOL)
  protecting (FOPL-CLAUSE)

  ** definition of invariant:
  -- use P(X) as macro like manner by using "#dfine" command:
  pred P : Protocol .         -- the predicate for invariant.
  #define P(X:Protocol)
     ::= \A[I:Index, J:Index] flag(I,X) = shared & flag(J,X) = shared
         -> cdata(I,X) = cdata(J,X) .
}

**> ========
**> 証明開始
**> ========
**> there are 3 goals.
--> (1) P must be satisfied at the initial sate:
-->     P(init) .
--> (2,3) also after applying read and write oprations.
-->    \A[S:Protocol]\A[I:Index] P(S) -> P(read(I,S)) .
-->    \A[S:Protocol]\A[I:Index, M:Data] P(S) -> P(write(I,M,S)) .
**> (1)

**> preset pignose option flags & parameters
option reset
flag (auto,on)
flag (universal-symmetry,on)
flag (dist-const,on)
flag (print-stats,on)
flag (randomize-sos,off)
param (max-weight,14)
flag (quiet,on)

**> save the option-set as `ccp-quiet-set'
save-option ccp-quiet-set

**> another option set.
option reset
flag (auto,on)
flag (universal-symmetry,on)
flag (dist-const,on)
flag (randomize-sos,off)
param (max-weight,14)
save-option ccp-set

**> we use ccp-set options
option = ccp-set

open PROOF

**> show P(init)
goal P(init) .
resolve .
close
**

open PROOF
**> show P(X) is invariant w.r.t. read operation.
--> goal \A[S:Protocol]\A[I:Index] P(S) -> P(read(I,S)) .
goal \A[S:Protocol]\A[I:Index] P(read(I,S)) .
** it's safe to reset options because some parameters may
** have been changed during the previous run in automatic manner
** (max-weight, for example).
** use preset option set `ccp-set'.
option = ccp-set
resolve .
close

open PROOF
**> show P(X) is invariant w.r.t. write operation.
-->  goal \A[S:Protocol]\A[I:Index, M:Data] P(S) -> P(write(I,M,S)) .
goal \A[S:Protocol]\A[I:Index, M:Data] P(write(I,M,S)) .
option = ccp-set
resolve .
close

**
eof
\end{verbatim}
    }
\item 上の実行結果は, 全ての証明において成功でおわらなければならない.
   上で示したファイルをシステムにロードし, 結果を検査する.
\end{itemize}
\subsubsection{実行結果}
\begin{itemize}
\item 第\ref{sec:total-data}節で示されたファイル ``total.mod'' を
  システムにロードした.
  結果のログを下に示す：
  {\small
\begin{verbatim}
CafeOBJ> in total
processing input : ./total.mod
**> 
**> 検証システム総合検査
**> cache coherence problem by A.Mori (amori@jaist.ac.jp)
**> 
**> データを定義したモジュール
-- defining module* DATA.._* done.
**> システム状態を示すフラグを定義したモジュール
-- defining module! FLAG....._* done.
**> Cache のプロトコルを定義したモジュール
**> 
-- defining module* PROTOCOL_*..........._.....................*
** system failed to prove =*= is a congruence of PROTOCOL done.
**> Cache のプロトコルに関して, 保証すべき性質 P を
**> 表現するモジュール.
**> P の意味は, cache X において, インデクス I と J で
**> さされるポイントの状態がともに shared ならば,
**> それらのデータ値が等しい, というものである.
**> 以下では, この性質がシステム状態の変化によらず,
**> 常に保証される事を証明する.
-- defining module PROOF..._._* done.
**> ========
**> 証明開始
**> ========
**> there are 3 goals.
--> (1) P must be satisfied at the initial sate:
-->     P(init) .
--> (2,3) also after applying read and write oprations.
-->    \A[S:Protocol]\A[I:Index] P(S) -> P(read(I,S)) .
-->    \A[S:Protocol]\A[I:Index, M:Data] P(S) -> P(write(I,M,S)) .
**> (1)
**> preset pignose option flags & parameters
-- setting flag "auto" to "on"
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
-- setting flag "universal-symmetry" to "on"
-- setting flag "dist-const" to "on"
-- setting flag "print-stats" to "on"
-- setting flag "randomize-sos" to "off"
-- setting parameter "max-weight" to 14.
-- setting flag "quiet" to "on"
   dependent: flag(print-message, off)
**> save the option-set as `ccp-quiet-set'
**> another option set.
-- setting flag "auto" to "on"
   dependent: flag(auto1, on)
   dependent: flag(process-input, on)
   dependent: flag(print-kept, off)
   dependent: flag(print-new-demod, off)
   dependent: flag(print-back-demod, off)
   dependent: flag(print-back-sub, off)
   dependent: flag(control-memory, on)
   dependent: param(max-sos, 500).
   dependent: param(pick-given-ratio, 4).
   dependent: param(max-seconds, 3600).
-- setting flag "universal-symmetry" to "on"
-- setting flag "dist-const" to "on"
-- setting flag "randomize-sos" to "off"
-- setting parameter "max-weight" to 14.
-- saving options to ccp-set.
**> we use ccp-set options
-- restoring options from ccp-set
-- opening module PROOF.. done.
**> show P(init)*_*
[Properties of input clauses]:
   propositional  = no
   horn           = no
   equality       = yes
   symmetry       = no
   max literals   = 3
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
   dependent: flag(hyper-res, on)
   dependent: flag(unit-deletion, on)
   dependent: flag(factor, on)
 
** start input processing.

 
** USABLE _______________________________
 
  3:[] ~(cdata(#c-2.Index,init) = cdata(#c-1.Index,
                                        init))
 
 process usable:
* kept in usable : weight=7
  3:[] ~(cdata(#c-2.Index,init) = cdata(#c-1.Index,
                                        init))
 
** SOS __________________________________
 
  25:[] Univ319 = Univ319
  1:[] flag(#c-2.Index,init) = shared
  2:[] flag(#c-1.Index,init) = shared
  4:[] flag(_v2:Index,init) = invalid
  5:[] cdata(_v7:Index,write(_v7,_v8:Data,_v6:Protocol)) 
       = _v8
  6:[] _v13:Index = _v15:Index | cdata(_v15:Index,
                                       write(_v13:Index,
                                             _v14:Data,
                                             _v16:Protocol)) 
                                 = cdata(_v15,
                                         _v16)
  7:[] flag(_v21:Index,write(_v21,_v22:Data,
                             _v20:Protocol)) 
       = dirty
  8:[] _v28:Index = _v30:Index | flag(_v30:Index,
                                      write(_v28:Index,
                                            _v29:Data,
                                            _v27:Protocol)) 
                                 = invalid
  9:[] mdata(write(_v34:Index,_v35:Data,_v36:Protocol)) 
       = mdata(_v36)
  10:[] flag(_v39:Index,_v40:Protocol) = invalid | 
        read(_v39:Index,_v40:Protocol) = _v40
  11:[] cdata(_v47:Index,read(_v47,write(_v46:Index,
                                         _v48:Data,
                                         _v45:Protocol))) 
        = _v48
  12:[] mdata(read(_v55:Index,write(_v53:Index,
                                    _v54:Data,
                                    _v56:Protocol))) 
        = mdata(_v56)
  13:[] _v64:Index = _v62:Index | flag(_v64:Index,
                                       read(_v64,
                                            write(_v62:Index,
                                                  _v63:Data,
                                                  _v61:Protocol))) 
                                  = shared
  14:[] _v72:Index = _v70:Index | flag(_v70:Index,
                                       read(_v72:Index,
                                            write(_v70,
                                                  _v71:Data,
                                                  _v69:Protocol))) 
                                  = shared
  15:[] _v76:Index = _v77:Index | cdata(_v76:Index,
                                        read(_v76,
                                             read(_v77:Index,
                                                  _v78:Protocol))) 
                                  = cdata(_v77,
                                          read(_v77,
                                               _v78))
  16:[] _v84:Index = _v83:Index | flag(_v84:Index,
                                       read(_v84,
                                            read(_v83:Index,
                                                 _v82:Protocol))) 
                                  = shared
  17:[] _v90:Index = _v89:Index | flag(_v89:Index,
                                       read(_v90:Index,
                                            read(_v89,
                                                 _v88:Protocol))) 
                                  = shared
  18:[] read(_v93:Index,read(_v93,_v94:Protocol)) 
        = read(_v93,_v94)
  19:[] _v100:Index = _v99:Index | _v100:Index 
                                   = _v101:Index | 
        flag(_v100:Index,read(_v99:Index,read(_v101:Index,
                                              _v102:Protocol))) 
        = flag(_v100,read(_v101,_v102))
  20:[] _v107:Index = _v106:Index | cdata(_v107:Index,
                                          read(_v106:Index,
                                               _v108:Protocol)) 
                                    = cdata(_v107,
                                            _v108)
  21:[] mdata(read(_v111:Index,_v112:Protocol)) 
        = mdata(_v112)
  22:[] cdata(_v114:Index,read(_v114,init)) 
        = mdata(init)
  23:[] flag(_v116:Index,read(_v116,init)) = 
        vex
  24:[] mdata(read(_v118:Index,init)) = mdata(init)
 
 process sos:
* kept in sos : weight=3
  25:[] _v120 = _v120
* kept in sos : weight=5
  1:[] flag(#c-2.Index,init) = shared
* kept in sos : weight=5
  2:[] flag(#c-1.Index,init) = shared
* kept in sos : weight=5
  4:[] flag(_v122:Index,init) = invalid
* kept in sos : weight=8
  5:[] cdata(_v127:Index,write(_v127,_v128:Data,
                               _v126:Protocol)) 
       = _v128
* kept in sos : weight=13
  6:[] _v133:Index = _v135:Index | cdata(_v135:Index,
                                         write(_v133:Index,
                                               _v134:Data,
                                               _v136:Protocol)) 
                                   = cdata(_v135,
                                           _v136)
* kept in sos : weight=8
  7:[] flag(_v141:Index,write(_v141,_v142:Data,
                              _v140:Protocol)) 
       = dirty
* kept in sos : weight=11
  8:[] _v148:Index = _v150:Index | flag(_v150:Index,
                                        write(_v148:Index,
                                              _v149:Data,
                                              _v147:Protocol)) 
                                   = invalid
* kept in sos : weight=8
  9:[] mdata(write(_v154:Index,_v155:Data,_v156:Protocol)) 
       = mdata(_v156)
* kept in sos : weight=10
  10:[] flag(_v159:Index,_v160:Protocol) = invalid | 
        read(_v159:Index,_v160:Protocol) = _v160
* kept in sos : weight=10
  11:[] cdata(_v167:Index,read(_v167,write(_v166:Index,
                                           _v168:Data,
                                           _v165:Protocol))) 
        = _v168
* kept in sos : weight=10
  12:[] mdata(read(_v175:Index,write(_v173:Index,
                                     _v174:Data,
                                     _v176:Protocol))) 
        = mdata(_v176)
* kept in sos : weight=13
  13:[] _v184:Index = _v182:Index | flag(_v184:Index,
                                         read(_v184,
                                              write(_v182:Index,
                                                    _v183:Data,
                                                    _v181:Protocol))) 
                                    = shared
* kept in sos : weight=13
  14:[] _v192:Index = _v190:Index | flag(_v190:Index,
                                         read(_v192:Index,
                                              write(_v190,
                                                    _v191:Data,
                                                    _v189:Protocol))) 
                                    = shared
* kept in sos : weight=16
  15:[] _v196:Index = _v197:Index | cdata(_v196:Index,
                                          read(_v196,
                                               read(_v197:Index,
                                                    _v198:Protocol))) 
                                    = cdata(_v197,
                                            read(_v197,
                                                 _v198))
* kept in sos : weight=12
  16:[] _v204:Index = _v203:Index | flag(_v204:Index,
                                         read(_v204,
                                              read(_v203:Index,
                                                   _v202:Protocol))) 
                                    = shared
* kept in sos : weight=12
  17:[] _v210:Index = _v209:Index | flag(_v209:Index,
                                         read(_v210:Index,
                                              read(_v209,
                                                   _v208:Protocol))) 
                                    = shared
* kept in sos : weight=9
  18:[] read(_v213:Index,read(_v213,_v214:Protocol)) 
        = read(_v213,_v214)
* kept in sos : weight=19
  19:[] _v220:Index = _v219:Index | _v220:Index 
                                    = _v221:Index | 
        flag(_v220:Index,read(_v219:Index,read(_v221:Index,
                                               _v222:Protocol))) 
        = flag(_v220,read(_v221,_v222))
* kept in sos : weight=12
  20:[] _v234:Index = _v233:Index | cdata(_v234:Index,
                                          read(_v233:Index,
                                               _v235:Protocol)) 
                                    = cdata(_v234,
                                            _v235)
* kept in sos : weight=7
  21:[] mdata(read(_v238:Index,_v239:Protocol)) 
        = mdata(_v239)
* kept in sos : weight=8
  22:[] cdata(_v241:Index,read(_v241,init)) 
        = mdata(init)
* kept in sos : weight=7
  23:[] flag(_v243:Index,read(_v243,init)) = 
        vex
-- following clause subsumed by 25 during input processing:
  24:[demod:21] mdata(init) = mdata(init)
-- following clause subsumed by 25 during input processing:
  52:[copy:25,flip] _v247 = _v247
* starting back demodulation with 1.
* starting back demodulation with 2.
* starting back demodulation with 4.
* back demodulating 1 with 4
* kept in sos : weight=0
  53:[back-demod:4,1,dconst] 
    
 
** EMPTY CLAUSE__________________________
 
  53:[back-demod:4,1,dconst] 
    
 
** PROOF ________________________________
 
  1:[back-demod:4] invalid = shared
  4:[] flag(_v122:Index,init) = invalid
  53:[back-demod:4,1,dconst] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            .........0  |
|  clauses generated        .........0  |
|  clauses kept             ........24  |
|  clauses forward subsumed .........2  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.280 sec)
-- opening module PROOF.. done.
**> show P(X) is invariant w.r.t. read operation.
--> goal \A[S:Protocol]\A[I:Index] P(S) -> P(read(I,S)) .
-- restoring options from ccp-set*_*
[Properties of input clauses]:
   propositional  = no
   horn           = no
   equality       = yes
   symmetry       = no
   max literals   = 3
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
   dependent: flag(hyper-res, on)
   dependent: flag(unit-deletion, on)
   dependent: flag(factor, on)
 
** start input processing.

 
** USABLE _______________________________
 
  3:[] ~(cdata(#c-2.Index,read(#c-3.Index,#c-1.Protocol)) 
         = cdata(#c-1.Index,read(#c-3.Index,
                                 #c-1.Protocol)))
 
 process usable:
* kept in usable : weight=11
  3:[] ~(cdata(#c-2.Index,read(#c-3.Index,#c-1.Protocol)) 
         = cdata(#c-1.Index,read(#c-3.Index,
                                 #c-1.Protocol)))
 
** SOS __________________________________
 
  25:[] Univ321 = Univ321
  1:[] flag(#c-2.Index,read(#c-3.Index,#c-1.Protocol)) 
       = shared
  2:[] flag(#c-1.Index,read(#c-3.Index,#c-1.Protocol)) 
       = shared
  4:[] flag(_v2:Index,init) = invalid
  5:[] cdata(_v7:Index,write(_v7,_v8:Data,_v6:Protocol)) 
       = _v8
  6:[] _v13:Index = _v15:Index | cdata(_v15:Index,
                                       write(_v13:Index,
                                             _v14:Data,
                                             _v16:Protocol)) 
                                 = cdata(_v15,
                                         _v16)
  7:[] flag(_v21:Index,write(_v21,_v22:Data,
                             _v20:Protocol)) 
       = dirty
  8:[] _v28:Index = _v30:Index | flag(_v30:Index,
                                      write(_v28:Index,
                                            _v29:Data,
                                            _v27:Protocol)) 
                                 = invalid
  9:[] mdata(write(_v34:Index,_v35:Data,_v36:Protocol)) 
       = mdata(_v36)
  10:[] flag(_v39:Index,_v40:Protocol) = invalid | 
        read(_v39:Index,_v40:Protocol) = _v40
  11:[] cdata(_v47:Index,read(_v47,write(_v46:Index,
                                         _v48:Data,
                                         _v45:Protocol))) 
        = _v48
  12:[] mdata(read(_v55:Index,write(_v53:Index,
                                    _v54:Data,
                                    _v56:Protocol))) 
        = mdata(_v56)
  13:[] _v64:Index = _v62:Index | flag(_v64:Index,
                                       read(_v64,
                                            write(_v62:Index,
                                                  _v63:Data,
                                                  _v61:Protocol))) 
                                  = shared
  14:[] _v72:Index = _v70:Index | flag(_v70:Index,
                                       read(_v72:Index,
                                            write(_v70,
                                                  _v71:Data,
                                                  _v69:Protocol))) 
                                  = shared
  15:[] _v76:Index = _v77:Index | cdata(_v76:Index,
                                        read(_v76,
                                             read(_v77:Index,
                                                  _v78:Protocol))) 
                                  = cdata(_v77,
                                          read(_v77,
                                               _v78))
  16:[] _v84:Index = _v83:Index | flag(_v84:Index,
                                       read(_v84,
                                            read(_v83:Index,
                                                 _v82:Protocol))) 
                                  = shared
  17:[] _v90:Index = _v89:Index | flag(_v89:Index,
                                       read(_v90:Index,
                                            read(_v89,
                                                 _v88:Protocol))) 
                                  = shared
  18:[] read(_v93:Index,read(_v93,_v94:Protocol)) 
        = read(_v93,_v94)
  19:[] _v100:Index = _v99:Index | _v100:Index 
                                   = _v101:Index | 
        flag(_v100:Index,read(_v99:Index,read(_v101:Index,
                                              _v102:Protocol))) 
        = flag(_v100,read(_v101,_v102))
  20:[] _v107:Index = _v106:Index | cdata(_v107:Index,
                                          read(_v106:Index,
                                               _v108:Protocol)) 
                                    = cdata(_v107,
                                            _v108)
  21:[] mdata(read(_v111:Index,_v112:Protocol)) 
        = mdata(_v112)
  22:[] cdata(_v114:Index,read(_v114,init)) 
        = mdata(init)
  23:[] flag(_v116:Index,read(_v116,init)) = 
        vex
  24:[] mdata(read(_v118:Index,init)) = mdata(init)
 
 process sos:
* kept in sos : weight=3
  25:[] _v120 = _v120
* kept in sos : weight=7
  1:[] flag(#c-2.Index,read(#c-3.Index,#c-1.Protocol)) 
       = shared
* kept in sos : weight=7
  2:[] flag(#c-1.Index,read(#c-3.Index,#c-1.Protocol)) 
       = shared
* kept in sos : weight=5
  4:[] flag(_v122:Index,init) = invalid
* kept in sos : weight=8
  5:[] cdata(_v127:Index,write(_v127,_v128:Data,
                               _v126:Protocol)) 
       = _v128
* kept in sos : weight=13
  6:[] _v133:Index = _v135:Index | cdata(_v135:Index,
                                         write(_v133:Index,
                                               _v134:Data,
                                               _v136:Protocol)) 
                                   = cdata(_v135,
                                           _v136)
* kept in sos : weight=8
  7:[] flag(_v141:Index,write(_v141,_v142:Data,
                              _v140:Protocol)) 
       = dirty
* kept in sos : weight=11
  8:[] _v148:Index = _v150:Index | flag(_v150:Index,
                                        write(_v148:Index,
                                              _v149:Data,
                                              _v147:Protocol)) 
                                   = invalid
* kept in sos : weight=8
  9:[] mdata(write(_v154:Index,_v155:Data,_v156:Protocol)) 
       = mdata(_v156)
* kept in sos : weight=10
  10:[] flag(_v159:Index,_v160:Protocol) = invalid | 
        read(_v159:Index,_v160:Protocol) = _v160
* kept in sos : weight=10
  11:[] cdata(_v167:Index,read(_v167,write(_v166:Index,
                                           _v168:Data,
                                           _v165:Protocol))) 
        = _v168
* kept in sos : weight=10
  12:[] mdata(read(_v175:Index,write(_v173:Index,
                                     _v174:Data,
                                     _v176:Protocol))) 
        = mdata(_v176)
* kept in sos : weight=13
  13:[] _v184:Index = _v182:Index | flag(_v184:Index,
                                         read(_v184,
                                              write(_v182:Index,
                                                    _v183:Data,
                                                    _v181:Protocol))) 
                                    = shared
* kept in sos : weight=13
  14:[] _v192:Index = _v190:Index | flag(_v190:Index,
                                         read(_v192:Index,
                                              write(_v190,
                                                    _v191:Data,
                                                    _v189:Protocol))) 
                                    = shared
* kept in sos : weight=16
  15:[] _v196:Index = _v197:Index | cdata(_v196:Index,
                                          read(_v196,
                                               read(_v197:Index,
                                                    _v198:Protocol))) 
                                    = cdata(_v197,
                                            read(_v197,
                                                 _v198))
* kept in sos : weight=12
  16:[] _v204:Index = _v203:Index | flag(_v204:Index,
                                         read(_v204,
                                              read(_v203:Index,
                                                   _v202:Protocol))) 
                                    = shared
* kept in sos : weight=12
  17:[] _v210:Index = _v209:Index | flag(_v209:Index,
                                         read(_v210:Index,
                                              read(_v209,
                                                   _v208:Protocol))) 
                                    = shared
* kept in sos : weight=9
  18:[] read(_v213:Index,read(_v213,_v214:Protocol)) 
        = read(_v213,_v214)
* kept in sos : weight=19
  19:[] _v220:Index = _v219:Index | _v220:Index 
                                    = _v221:Index | 
        flag(_v220:Index,read(_v219:Index,read(_v221:Index,
                                               _v222:Protocol))) 
        = flag(_v220,read(_v221,_v222))
* kept in sos : weight=12
  20:[] _v234:Index = _v233:Index | cdata(_v234:Index,
                                          read(_v233:Index,
                                               _v235:Protocol)) 
                                    = cdata(_v234,
                                            _v235)
* kept in sos : weight=7
  21:[] mdata(read(_v238:Index,_v239:Protocol)) 
        = mdata(_v239)
* kept in sos : weight=8
  22:[] cdata(_v241:Index,read(_v241,init)) 
        = mdata(init)
* kept in sos : weight=7
  23:[] flag(_v243:Index,read(_v243,init)) = 
        vex
-- following clause subsumed by 25 during input processing:
  24:[demod:21] mdata(init) = mdata(init)
-- following clause subsumed by 25 during input processing:
  52:[copy:25,flip] _v247 = _v247
* starting back demodulation with 1.
* starting back demodulation with 2.
* starting back demodulation with 4.
* starting back demodulation with 5.
* starting back demodulation with 7.
* starting back demodulation with 9.
* starting back demodulation with 11.
* starting back demodulation with 12.
* starting back demodulation with 18.
* starting back demodulation with 21.
* back demodulating 12 with 21
-- following clause subsumed by 25 during input processing:
  54:[back-demod:21,12,demod:9] 
    mdata(_v263:Protocol) = mdata(_v263)
* starting back demodulation with 22.
* starting back demodulation with 23.
 
** DEMODULATORS _________________________
 
  (1) flag(#c-2.Index,read(#c-3.Index,#c-1.Protocol))
       --> shared
  (2) flag(#c-1.Index,read(#c-3.Index,#c-1.Protocol))
       --> shared
  (4) flag(_v122:Index,init) --> invalid
  (5) cdata(_v127:Index,write(_v127,_v128:Data,
                              _v126:Protocol))
       --> _v128:Data
  (7) flag(_v141:Index,write(_v141,_v142:Data,
                             _v140:Protocol))
       --> dirty
  (9) mdata(write(_v154:Index,_v155:Data,_v156:Protocol))
       --> mdata(_v156:Protocol)
  (11) cdata(_v167:Index,read(_v167,write(_v166:Index,
                                          _v168:Data,
                                          _v165:Protocol)))
       --> _v168:Data
  (18) read(_v213:Index,read(_v213,_v214:Protocol))
       --> read(_v213:Index,_v214:Protocol)
  (21) mdata(read(_v238:Index,_v239:Protocol))
       --> mdata(_v239:Protocol)
  (22) cdata(_v241:Index,read(_v241,init)) --> 
      mdata(init)
  (23) flag(_v243:Index,read(_v243,init)) --> 
      vex
 

** end process input.

 
** Starting PigNose _____________________
 
#1(weight=3):
  25:[] _v120 = _v120
#2(weight=5):
  4:[] flag(_v122:Index,init) = invalid
#3(weight=7):
  1:[] flag(#c-2.Index,read(#c-3.Index,#c-1.Protocol)) 
       = shared
#4(weight=7):
  2:[] flag(#c-1.Index,read(#c-3.Index,#c-1.Protocol)) 
       = shared
#5(weight=7):
  21:[] mdata(read(_v238:Index,_v239:Protocol)) 
        = mdata(_v239)
#6(weight=8):
  5:[] cdata(_v127:Index,write(_v127,_v128:Data,
                               _v126:Protocol)) 
       = _v128
#7(weight=7):
  23:[] flag(_v243:Index,read(_v243,init)) = 
        vex
#8(weight=8):
  7:[] flag(_v141:Index,write(_v141,_v142:Data,
                              _v140:Protocol)) 
       = dirty
#9(weight=8):
  9:[] mdata(write(_v154:Index,_v155:Data,_v156:Protocol)) 
       = mdata(_v156)
#10(weight=8):
  22:[] cdata(_v241:Index,read(_v241,init)) 
        = mdata(init)
#11(weight=13):
  6:[] _v133:Index = _v135:Index | cdata(_v135:Index,
                                         write(_v133:Index,
                                               _v134:Data,
                                               _v136:Protocol)) 
                                   = cdata(_v135,
                                           _v136)
#12(weight=9):
  18:[] read(_v213:Index,read(_v213,_v214:Protocol)) 
        = read(_v213,_v214)
#13(weight=10):
  10:[] flag(_v159:Index,_v160:Protocol) = invalid | 
        read(_v159:Index,_v160:Protocol) = _v160
#14(weight=9):
  70:[para-into:10,2,dconst] 
    read(#c-1.Index,read(#c-3.Index,#c-1.Protocol)) 
    = read(#c-3.Index,#c-1.Protocol)
#15(weight=9):
  71:[para-into:10,1,dconst] 
    read(#c-2.Index,read(#c-3.Index,#c-1.Protocol)) 
    = read(#c-3.Index,#c-1.Protocol)
#16(weight=11):
  8:[] _v148:Index = _v150:Index | flag(_v150:Index,
                                        write(_v148:Index,
                                              _v149:Data,
                                              _v147:Protocol)) 
                                   = invalid
#17(weight=10):
  11:[] cdata(_v167:Index,read(_v167,write(_v166:Index,
                                           _v168:Data,
                                           _v165:Protocol))) 
        = _v168
#18(weight=10):
  81:[para-from:10,1] flag(#c-2.Index,#c-1.Protocol) 
                      = shared | flag(#c-3.Index,
                                      #c-1.Protocol) 
                                 = invalid
#19(weight=10):
  82:[para-from:10,2] flag(#c-1.Index,#c-1.Protocol) 
                      = shared | flag(#c-3.Index,
                                      #c-1.Protocol) 
                                 = invalid
#20(weight=10):
  116:[para-into:81,10,dconst] 
    flag(#c-3.Index,#c-1.Protocol) = invalid | 
    read(#c-2.Index,#c-1.Protocol) = #c-1.Protocol
#21(weight=13):
  13:[] _v184:Index = _v182:Index | flag(_v184:Index,
                                         read(_v184,
                                              write(_v182:Index,
                                                    _v183:Data,
                                                    _v181:Protocol))) 
                                    = shared
#22(weight=10):
  120:[para-into:82,10,dconst] 
    flag(#c-3.Index,#c-1.Protocol) = invalid | 
    read(#c-1.Index,#c-1.Protocol) = #c-1.Protocol
#23(weight=11):
  68:[para-into:10,7,dconst] 
    read(_v303:Index,write(_v303,_v302:Data,
                           _v304:Protocol)) 
    = write(_v303,_v302,_v304)
#24(weight=12):
  16:[] _v204:Index = _v203:Index | flag(_v204:Index,
                                         read(_v204,
                                              read(_v203:Index,
                                                   _v202:Protocol))) 
                                    = shared
#25(weight=12):
  17:[] _v210:Index = _v209:Index | flag(_v209:Index,
                                         read(_v210:Index,
                                              read(_v209,
                                                   _v208:Protocol))) 
                                    = shared
#26(weight=13):
  14:[] _v192:Index = _v190:Index | flag(_v190:Index,
                                         read(_v192:Index,
                                              write(_v190,
                                                    _v191:Data,
                                                    _v189:Protocol))) 
                                    = shared
#27(weight=10):
  217:[para-into:17,71,flip] 
    #c-3.Index = #c-2.Index | flag(#c-3.Index,
                                   read(#c-3.Index,
                                        #c-1.Protocol)) 
                              = shared
#28(weight=10):
  218:[para-into:17,70,flip] 
    #c-3.Index = #c-1.Index | flag(#c-3.Index,
                                   read(#c-3.Index,
                                        #c-1.Protocol)) 
                              = shared
#29(weight=10):
  289:[para-into:218,217,fsimp] 
    #c-2.Index = #c-1.Index | flag(#c-3.Index,
                                   read(#c-3.Index,
                                        #c-1.Protocol)) 
                              = shared
#30(weight=7):
  323:[para-from:289,3,unit-del:25] 
    flag(#c-3.Index,read(#c-3.Index,#c-1.Protocol)) 
    = shared
#31(weight=16):
  15:[] _v196:Index = _v197:Index | cdata(_v196:Index,
                                          read(_v196,
                                               read(_v197:Index,
                                                    _v198:Protocol))) 
                                    = cdata(_v197,
                                            read(_v197,
                                                 _v198))
#32(weight=10):
  340:[para-into:323,10] 
    flag(#c-3.Index,#c-1.Protocol) = shared | 
    flag(#c-3.Index,#c-1.Protocol) = invalid
#33(weight=11):
  247:[para-into:14,10,demod:7,dconst] 
    _v616:Index = _v614:Index | flag(_v616:Index,
                                     write(_v614:Index,
                                           _v615:Data,
                                           _v613:Protocol)) 
                                = invalid
#34(weight=12):
  20:[] _v234:Index = _v233:Index | cdata(_v234:Index,
                                          read(_v233:Index,
                                               _v235:Protocol)) 
                                    = cdata(_v234,
                                            _v235)
#35(weight=12):
  89:[para-into:70,10,flip] 
    read(#c-3.Index,#c-1.Protocol) = read(#c-1.Index,
                                          #c-1.Protocol) | 
    flag(#c-3.Index,#c-1.Protocol) = invalid
#36(weight=19):
  19:[] _v220:Index = _v219:Index | _v220:Index 
                                    = _v221:Index | 
        flag(_v220:Index,read(_v219:Index,read(_v221:Index,
                                               _v222:Protocol))) 
        = flag(_v220,read(_v221,_v222))
#37(weight=12):
  94:[para-into:71,10,flip] 
    read(#c-3.Index,#c-1.Protocol) = read(#c-2.Index,
                                          #c-1.Protocol) | 
    flag(#c-3.Index,#c-1.Protocol) = invalid
#38(weight=12):
  179:[para-into:16,71] 
    _v474:Index = #c-2.Index | flag(_v474:Index,
                                    read(_v474,
                                         read(#c-3.Index,
                                              #c-1.Protocol))) 
                               = shared
#39(weight=12):
  180:[para-into:16,70] 
    _v475:Index = #c-1.Index | flag(_v475:Index,
                                    read(_v475,
                                         read(#c-3.Index,
                                              #c-1.Protocol))) 
                               = shared
#40(weight=12):
  213:[para-into:17,71] 
    _v544:Index = #c-2.Index | flag(#c-2.Index,
                                    read(_v544:Index,
                                         read(#c-3.Index,
                                              #c-1.Protocol))) 
                               = shared
#41(weight=14):
  80:[para-from:10,3,flip] 
    ~(cdata(#c-1.Index,read(#c-3.Index,#c-1.Protocol)) 
      = cdata(#c-2.Index,#c-1.Protocol)) | flag(#c-3.Index,
                                                #c-1.Protocol) 
                                           = 
                                           invalid
#42(weight=12):
  214:[para-into:17,70] 
    _v545:Index = #c-1.Index | flag(#c-1.Index,
                                    read(_v545:Index,
                                         read(#c-3.Index,
                                              #c-1.Protocol))) 
                               = shared
#43(weight=12):
  466:[para-from:20,3,flip:flip] 
    ~(cdata(#c-1.Index,read(#c-3.Index,#c-1.Protocol)) 
      = cdata(#c-2.Index,#c-1.Protocol)) | #c-3.Index 
                                           = 
                                           #c-2.Index
#44(weight=12):
  481:[para-from:89,1] 
    flag(#c-2.Index,read(#c-1.Index,#c-1.Protocol)) 
    = shared | flag(#c-3.Index,#c-1.Protocol) 
               = invalid
#45(weight=12):
  482:[para-from:89,2] 
    flag(#c-1.Index,read(#c-1.Index,#c-1.Protocol)) 
    = shared | flag(#c-3.Index,#c-1.Protocol) 
               = invalid
#46(weight=13):
  275:[para-into:217,10] 
    #c-3.Index = #c-2.Index | flag(#c-3.Index,
                                   #c-1.Protocol) 
                              = shared | flag(#c-3.Index,
                                              #c-1.Protocol) 
                                         = invalid
#47(weight=12):
  491:[para-from:89,323] 
    flag(#c-3.Index,read(#c-1.Index,#c-1.Protocol)) 
    = shared | flag(#c-3.Index,#c-1.Protocol) 
               = invalid
#48(weight=12):
  595:[para-into:94,89,fsimp] 
    read(#c-2.Index,#c-1.Protocol) = read(#c-1.Index,
                                          #c-1.Protocol) | 
    flag(#c-3.Index,#c-1.Protocol) = invalid
#49(weight=12):
  608:[para-from:94,1] 
    flag(#c-2.Index,read(#c-2.Index,#c-1.Protocol)) 
    = shared | flag(#c-3.Index,#c-1.Protocol) 
               = invalid
#50(weight=12):
  609:[para-from:94,2] 
    flag(#c-1.Index,read(#c-2.Index,#c-1.Protocol)) 
    = shared | flag(#c-3.Index,#c-1.Protocol) 
               = invalid
#51(weight=13):
  295:[para-into:218,10] 
    #c-3.Index = #c-1.Index | flag(#c-3.Index,
                                   #c-1.Protocol) 
                              = shared | flag(#c-3.Index,
                                              #c-1.Protocol) 
                                         = invalid
#52(weight=12):
  618:[para-from:94,323] 
    flag(#c-3.Index,read(#c-2.Index,#c-1.Protocol)) 
    = shared | flag(#c-3.Index,#c-1.Protocol) 
               = invalid
#53(weight=12):
  795:[para-into:80,10,fsimp] 
    ~(cdata(#c-2.Index,#c-1.Protocol) = cdata(#c-1.Index,
                                              #c-1.Protocol)) | 
    flag(#c-3.Index,#c-1.Protocol) = invalid
#54(weight=13):
  319:[para-into:289,10] 
    #c-2.Index = #c-1.Index | flag(#c-3.Index,
                                   #c-1.Protocol) 
                              = shared | flag(#c-3.Index,
                                              #c-1.Protocol) 
                                         = invalid
#55(weight=13):
  878:[para-into:466,20,flip:flip] 
    ~(cdata(#c-2.Index,#c-1.Protocol) = cdata(#c-1.Index,
                                              #c-1.Protocol)) | 
    #c-3.Index = #c-2.Index | #c-3.Index = #c-1.Index
#56(weight=14):
  350:[para-into:15,71,flip:flip] 
    #c-3.Index = #c-2.Index | cdata(#c-3.Index,
                                    read(#c-3.Index,
                                         #c-1.Protocol)) 
                              = cdata(#c-2.Index,
                                      read(#c-3.Index,
                                           #c-1.Protocol))
#57(weight=10):
  1714:[para-into:350,878,unit-del:3,fsimp] 
    #c-3.Index = #c-2.Index | ~(cdata(#c-2.Index,
                                      #c-1.Protocol) 
                                = cdata(#c-1.Index,
                                        #c-1.Protocol))
#58(weight=12):
  1828:[para-from:1714,795,fsimp] 
    ~(cdata(#c-2.Index,#c-1.Protocol) = cdata(#c-1.Index,
                                              #c-1.Protocol)) | 
    flag(#c-2.Index,#c-1.Protocol) = invalid
#59(weight=14):
  351:[para-into:15,70,flip:flip] 
    #c-3.Index = #c-1.Index | cdata(#c-3.Index,
                                    read(#c-3.Index,
                                         #c-1.Protocol)) 
                              = cdata(#c-1.Index,
                                      read(#c-3.Index,
                                           #c-1.Protocol))
#60(weight=6):
  1872:[para-into:351,350,unit-del:3] 
    #c-3.Index = #c-2.Index | #c-3.Index = #c-1.Index
#61(weight=14):
  1789:[para-from:1714,1] 
    flag(#c-2.Index,read(#c-2.Index,#c-1.Protocol)) 
    = shared | ~(cdata(#c-2.Index,#c-1.Protocol) 
                 = cdata(#c-1.Index,#c-1.Protocol))
#62(weight=3):
  2002:[para-from:1872,351,unit-del:3,fsimp] 
    #c-3.Index = #c-1.Index
#63(weight=3):
  2098:[back-demod:2002,350,unit-del:2077,flip] 
    #c-2.Index = #c-1.Index
#64(weight=5):
  2114:[back-demod:2002,795,demod:2098,unit-del:25] 
    flag(#c-1.Index,#c-1.Protocol) = invalid
#65(weight=7):
  2078:[back-demod:2002,1] 
    flag(#c-2.Index,read(#c-1.Index,#c-1.Protocol)) 
    = shared
#66(weight=14):
  1790:[para-from:1714,2] 
    flag(#c-1.Index,read(#c-2.Index,#c-1.Protocol)) 
    = shared | ~(cdata(#c-2.Index,#c-1.Protocol) 
                 = cdata(#c-1.Index,#c-1.Protocol))
#67(weight=7):
  2079:[back-demod:2002,2] 
    flag(#c-1.Index,read(#c-1.Index,#c-1.Protocol)) 
    = shared
#68(weight=9):
  2081:[back-demod:2002,71] 
    read(#c-2.Index,read(#c-1.Index,#c-1.Protocol)) 
    = read(#c-1.Index,#c-1.Protocol)
#69(weight=10):
  2009:[para-from:1872,1,demod:2002,flip] 
    flag(#c-2.Index,read(#c-1.Index,#c-1.Protocol)) 
    = shared | #c-2.Index = #c-1.Index
#70(weight=10):
  2010:[para-from:1872,2,demod:2002,flip] 
    flag(#c-1.Index,read(#c-1.Index,#c-1.Protocol)) 
    = shared | #c-2.Index = #c-1.Index
#71(weight=14):
  2008:[para-from:1872,3,demod:2002,flip] 
    ~(cdata(#c-2.Index,read(#c-1.Index,#c-1.Protocol)) 
      = cdata(#c-1.Index,read(#c-1.Index,#c-1.Protocol))) | 
    #c-2.Index = #c-1.Index
#72(weight=10):
  2070:[para-from:1872,1714,demod:2002,fsimp] 
    #c-2.Index = #c-1.Index | ~(cdata(#c-2.Index,
                                      #c-1.Protocol) 
                                = cdata(#c-1.Index,
                                        #c-1.Protocol))
#73(weight=10):
  2083:[back-demod:2002,81] 
    flag(#c-2.Index,#c-1.Protocol) = shared | 
    flag(#c-1.Index,#c-1.Protocol) = invalid
#74(weight=10):
  2084:[back-demod:2002,82] 
    flag(#c-1.Index,#c-1.Protocol) = shared | 
    flag(#c-1.Index,#c-1.Protocol) = invalid
#75(weight=10):
  2087:[back-demod:2002,116] 
    flag(#c-1.Index,#c-1.Protocol) = invalid | 
    read(#c-2.Index,#c-1.Protocol) = #c-1.Protocol
#76(weight=12):
  2012:[para-from:1872,71,demod:2002,flip] 
    read(#c-2.Index,read(#c-1.Index,#c-1.Protocol)) 
    = read(#c-1.Index,#c-1.Protocol) | #c-2.Index 
                                       = #c-1.Index
#77(weight=11):
  2077:[back-demod:2002,3] 
    ~(cdata(#c-2.Index,read(#c-1.Index,#c-1.Protocol)) 
      = cdata(#c-1.Index,read(#c-1.Index,#c-1.Protocol)))
 
** EMPTY CLAUSE__________________________
 
  2384:[para-into:2077,2070,demod:2098,unit-del:25,25] 
    
 
** PROOF ________________________________
 
  1:[back-demod:2002] flag(#c-2.Index,read(#c-1.Index,
                                           #c-1.Protocol)) 
                      = shared
  2:[back-demod:2002] flag(#c-1.Index,read(#c-1.Index,
                                           #c-1.Protocol)) 
                      = shared
  3:[back-demod:2002] ~(cdata(#c-2.Index,read(#c-1.Index,
                                              #c-1.Protocol)) 
                        = cdata(#c-1.Index,read(#c-1.Index,
                                                #c-1.Protocol)))
  10:[] flag(_v159:Index,_v160:Protocol) = invalid | 
        read(_v159:Index,_v160:Protocol) = _v160
  15:[] _v196:Index = _v197:Index | cdata(_v196:Index,
                                          read(_v196,
                                               read(_v197:Index,
                                                    _v198:Protocol))) 
                                    = cdata(_v197,
                                            read(_v197,
                                                 _v198))
  20:[] _v234:Index = _v233:Index | cdata(_v234:Index,
                                          read(_v233:Index,
                                               _v235:Protocol)) 
                                    = cdata(_v234,
                                            _v235)
  25:[] _v120 = _v120
  70:[para-into:10,2,dconst:back-demod:2002] 
    read(#c-1.Index,read(#c-1.Index,#c-1.Protocol)) 
    = read(#c-1.Index,#c-1.Protocol)
  71:[para-into:10,1,dconst:back-demod:2002] 
    read(#c-2.Index,read(#c-1.Index,#c-1.Protocol)) 
    = read(#c-1.Index,#c-1.Protocol)
  350:[para-into:15,71,flip:flip:back-demod:2002] 
    #c-1.Index = #c-2.Index | cdata(#c-1.Index,
                                    read(#c-1.Index,
                                         #c-1.Protocol)) 
                              = cdata(#c-2.Index,
                                      read(#c-1.Index,
                                           #c-1.Protocol))
  351:[para-into:15,70,flip:flip:back-demod:2002] 
    #c-1.Index = #c-1.Index | cdata(#c-1.Index,
                                    read(#c-1.Index,
                                         #c-1.Protocol)) 
                              = cdata(#c-1.Index,
                                      read(#c-1.Index,
                                           #c-1.Protocol))
  466:[para-from:20,3,flip:flip:back-demod:2002] 
    ~(cdata(#c-1.Index,read(#c-1.Index,#c-1.Protocol)) 
      = cdata(#c-2.Index,#c-1.Protocol)) | #c-1.Index 
                                           = 
                                           #c-2.Index
  878:[para-into:466,20,flip:flip:back-demod:2002] 
    ~(cdata(#c-2.Index,#c-1.Protocol) = cdata(#c-1.Index,
                                              #c-1.Protocol)) | 
    #c-1.Index = #c-2.Index | #c-1.Index = #c-1.Index
  1714:[para-into:350,878,unit-del:3,fsimp:back-demod:2002] 
    #c-1.Index = #c-2.Index | ~(cdata(#c-2.Index,
                                      #c-1.Protocol) 
                                = cdata(#c-1.Index,
                                        #c-1.Protocol))
  1872:[para-into:351,350,unit-del:3,back-demod:2002] 
    #c-1.Index = #c-2.Index | #c-1.Index = #c-1.Index
  2002:[para-from:1872,351,unit-del:3,fsimp] 
    #c-3.Index = #c-1.Index
  2070:[para-from:1872,1714,demod:2002,fsimp] 
    #c-2.Index = #c-1.Index | ~(cdata(#c-2.Index,
                                      #c-1.Protocol) 
                                = cdata(#c-1.Index,
                                        #c-1.Protocol))
  2077:[back-demod:2002,3] 
    ~(cdata(#c-2.Index,read(#c-1.Index,#c-1.Protocol)) 
      = cdata(#c-1.Index,read(#c-1.Index,#c-1.Protocol)))
  2098:[back-demod:2002,350,unit-del:2077,flip] 
    #c-2.Index = #c-1.Index
  2384:[para-into:2077,2070,demod:2098,unit-del:25,25] 
    
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........77  |
|  clauses generated        .....2,023  |
|  clauses kept             .......123  |
|  clauses forward subsumed .......334  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 1.820 sec)
-- opening module PROOF.. done.
**> show P(X) is invariant w.r.t. write operation.
-->  goal \A[S:Protocol]\A[I:Index, M:Data] P(S) -> P(write(I,M,S)) .
-- restoring options from ccp-set*_*
[Properties of input clauses]:
   propositional  = no
   horn           = no
   equality       = yes
   symmetry       = no
   max literals   = 3
[selected strategy]:
   dependent: flag(kb, on)
   dependent: flag(para-from, on)
   dependent: flag(para-into, on)
   dependent: flag(para-from-right, off)
   dependent: flag(para-into-right, off)
   dependent: flag(para-from-vars, on)
   dependent: flag(eq-units-both-ways, on)
   dependent: flag(dynamic-demod-all, on)
   dependent: flag(dynamic-demod, on)
   dependent: flag(order-eq, on)
   dependent: flag(back-demod, on)
   dependent: flag(lrpo, on)
   dependent: flag(hyper-res, on)
   dependent: flag(unit-deletion, on)
   dependent: flag(factor, on)
 
** start input processing.

 
** USABLE _______________________________
 
  3:[] ~(cdata(#c-2.Index,write(#c-3.Index,#c-1.Data,
                                #c-1.Protocol)) 
         = cdata(#c-1.Index,write(#c-3.Index,
                                  #c-1.Data,
                                  #c-1.Protocol)))
 
 process usable:
* kept in usable : weight=13
  3:[] ~(cdata(#c-2.Index,write(#c-3.Index,#c-1.Data,
                                #c-1.Protocol)) 
         = cdata(#c-1.Index,write(#c-3.Index,
                                  #c-1.Data,
                                  #c-1.Protocol)))
 
** SOS __________________________________
 
  25:[] Univ323 = Univ323
  1:[] flag(#c-2.Index,write(#c-3.Index,#c-1.Data,
                             #c-1.Protocol)) 
       = shared
  2:[] flag(#c-1.Index,write(#c-3.Index,#c-1.Data,
                             #c-1.Protocol)) 
       = shared
  4:[] flag(_v2:Index,init) = invalid
  5:[] cdata(_v7:Index,write(_v7,_v8:Data,_v6:Protocol)) 
       = _v8
  6:[] _v13:Index = _v15:Index | cdata(_v15:Index,
                                       write(_v13:Index,
                                             _v14:Data,
                                             _v16:Protocol)) 
                                 = cdata(_v15,
                                         _v16)
  7:[] flag(_v21:Index,write(_v21,_v22:Data,
                             _v20:Protocol)) 
       = dirty
  8:[] _v28:Index = _v30:Index | flag(_v30:Index,
                                      write(_v28:Index,
                                            _v29:Data,
                                            _v27:Protocol)) 
                                 = invalid
  9:[] mdata(write(_v34:Index,_v35:Data,_v36:Protocol)) 
       = mdata(_v36)
  10:[] flag(_v39:Index,_v40:Protocol) = invalid | 
        read(_v39:Index,_v40:Protocol) = _v40
  11:[] cdata(_v47:Index,read(_v47,write(_v46:Index,
                                         _v48:Data,
                                         _v45:Protocol))) 
        = _v48
  12:[] mdata(read(_v55:Index,write(_v53:Index,
                                    _v54:Data,
                                    _v56:Protocol))) 
        = mdata(_v56)
  13:[] _v64:Index = _v62:Index | flag(_v64:Index,
                                       read(_v64,
                                            write(_v62:Index,
                                                  _v63:Data,
                                                  _v61:Protocol))) 
                                  = shared
  14:[] _v72:Index = _v70:Index | flag(_v70:Index,
                                       read(_v72:Index,
                                            write(_v70,
                                                  _v71:Data,
                                                  _v69:Protocol))) 
                                  = shared
  15:[] _v76:Index = _v77:Index | cdata(_v76:Index,
                                        read(_v76,
                                             read(_v77:Index,
                                                  _v78:Protocol))) 
                                  = cdata(_v77,
                                          read(_v77,
                                               _v78))
  16:[] _v84:Index = _v83:Index | flag(_v84:Index,
                                       read(_v84,
                                            read(_v83:Index,
                                                 _v82:Protocol))) 
                                  = shared
  17:[] _v90:Index = _v89:Index | flag(_v89:Index,
                                       read(_v90:Index,
                                            read(_v89,
                                                 _v88:Protocol))) 
                                  = shared
  18:[] read(_v93:Index,read(_v93,_v94:Protocol)) 
        = read(_v93,_v94)
  19:[] _v100:Index = _v99:Index | _v100:Index 
                                   = _v101:Index | 
        flag(_v100:Index,read(_v99:Index,read(_v101:Index,
                                              _v102:Protocol))) 
        = flag(_v100,read(_v101,_v102))
  20:[] _v107:Index = _v106:Index | cdata(_v107:Index,
                                          read(_v106:Index,
                                               _v108:Protocol)) 
                                    = cdata(_v107,
                                            _v108)
  21:[] mdata(read(_v111:Index,_v112:Protocol)) 
        = mdata(_v112)
  22:[] cdata(_v114:Index,read(_v114,init)) 
        = mdata(init)
  23:[] flag(_v116:Index,read(_v116,init)) = 
        vex
  24:[] mdata(read(_v118:Index,init)) = mdata(init)
 
 process sos:
* kept in sos : weight=3
  25:[] _v120 = _v120
* kept in sos : weight=8
  1:[] flag(#c-2.Index,write(#c-3.Index,#c-1.Data,
                             #c-1.Protocol)) 
       = shared
* kept in sos : weight=8
  2:[] flag(#c-1.Index,write(#c-3.Index,#c-1.Data,
                             #c-1.Protocol)) 
       = shared
* kept in sos : weight=5
  4:[] flag(_v122:Index,init) = invalid
* kept in sos : weight=8
  5:[] cdata(_v127:Index,write(_v127,_v128:Data,
                               _v126:Protocol)) 
       = _v128
* kept in sos : weight=13
  6:[] _v133:Index = _v135:Index | cdata(_v135:Index,
                                         write(_v133:Index,
                                               _v134:Data,
                                               _v136:Protocol)) 
                                   = cdata(_v135,
                                           _v136)
* kept in sos : weight=8
  7:[] flag(_v141:Index,write(_v141,_v142:Data,
                              _v140:Protocol)) 
       = dirty
* kept in sos : weight=11
  8:[] _v148:Index = _v150:Index | flag(_v150:Index,
                                        write(_v148:Index,
                                              _v149:Data,
                                              _v147:Protocol)) 
                                   = invalid
* kept in sos : weight=8
  9:[] mdata(write(_v154:Index,_v155:Data,_v156:Protocol)) 
       = mdata(_v156)
* kept in sos : weight=10
  10:[] flag(_v159:Index,_v160:Protocol) = invalid | 
        read(_v159:Index,_v160:Protocol) = _v160
* kept in sos : weight=10
  11:[] cdata(_v167:Index,read(_v167,write(_v166:Index,
                                           _v168:Data,
                                           _v165:Protocol))) 
        = _v168
* kept in sos : weight=10
  12:[] mdata(read(_v175:Index,write(_v173:Index,
                                     _v174:Data,
                                     _v176:Protocol))) 
        = mdata(_v176)
* kept in sos : weight=13
  13:[] _v184:Index = _v182:Index | flag(_v184:Index,
                                         read(_v184,
                                              write(_v182:Index,
                                                    _v183:Data,
                                                    _v181:Protocol))) 
                                    = shared
* kept in sos : weight=13
  14:[] _v192:Index = _v190:Index | flag(_v190:Index,
                                         read(_v192:Index,
                                              write(_v190,
                                                    _v191:Data,
                                                    _v189:Protocol))) 
                                    = shared
* kept in sos : weight=16
  15:[] _v196:Index = _v197:Index | cdata(_v196:Index,
                                          read(_v196,
                                               read(_v197:Index,
                                                    _v198:Protocol))) 
                                    = cdata(_v197,
                                            read(_v197,
                                                 _v198))
* kept in sos : weight=12
  16:[] _v204:Index = _v203:Index | flag(_v204:Index,
                                         read(_v204,
                                              read(_v203:Index,
                                                   _v202:Protocol))) 
                                    = shared
* kept in sos : weight=12
  17:[] _v210:Index = _v209:Index | flag(_v209:Index,
                                         read(_v210:Index,
                                              read(_v209,
                                                   _v208:Protocol))) 
                                    = shared
* kept in sos : weight=9
  18:[] read(_v213:Index,read(_v213,_v214:Protocol)) 
        = read(_v213,_v214)
* kept in sos : weight=19
  19:[] _v220:Index = _v219:Index | _v220:Index 
                                    = _v221:Index | 
        flag(_v220:Index,read(_v219:Index,read(_v221:Index,
                                               _v222:Protocol))) 
        = flag(_v220,read(_v221,_v222))
* kept in sos : weight=12
  20:[] _v234:Index = _v233:Index | cdata(_v234:Index,
                                          read(_v233:Index,
                                               _v235:Protocol)) 
                                    = cdata(_v234,
                                            _v235)
* kept in sos : weight=7
  21:[] mdata(read(_v238:Index,_v239:Protocol)) 
        = mdata(_v239)
* kept in sos : weight=8
  22:[] cdata(_v241:Index,read(_v241,init)) 
        = mdata(init)
* kept in sos : weight=7
  23:[] flag(_v243:Index,read(_v243,init)) = 
        vex
-- following clause subsumed by 25 during input processing:
  24:[demod:21] mdata(init) = mdata(init)
-- following clause subsumed by 25 during input processing:
  52:[copy:25,flip] _v247 = _v247
* starting back demodulation with 1.
* starting back demodulation with 2.
* starting back demodulation with 4.
* starting back demodulation with 5.
* starting back demodulation with 7.
* starting back demodulation with 9.
* starting back demodulation with 11.
* starting back demodulation with 12.
* starting back demodulation with 18.
* starting back demodulation with 21.
* back demodulating 12 with 21
-- following clause subsumed by 25 during input processing:
  54:[back-demod:21,12,demod:9] 
    mdata(_v263:Protocol) = mdata(_v263)
* starting back demodulation with 22.
* starting back demodulation with 23.
 
** DEMODULATORS _________________________
 
  (1) flag(#c-2.Index,write(#c-3.Index,#c-1.Data,
                            #c-1.Protocol)) --> 
      shared
  (2) flag(#c-1.Index,write(#c-3.Index,#c-1.Data,
                            #c-1.Protocol)) --> 
      shared
  (4) flag(_v122:Index,init) --> invalid
  (5) cdata(_v127:Index,write(_v127,_v128:Data,
                              _v126:Protocol))
       --> _v128:Data
  (7) flag(_v141:Index,write(_v141,_v142:Data,
                             _v140:Protocol))
       --> dirty
  (9) mdata(write(_v154:Index,_v155:Data,_v156:Protocol))
       --> mdata(_v156:Protocol)
  (11) cdata(_v167:Index,read(_v167,write(_v166:Index,
                                          _v168:Data,
                                          _v165:Protocol)))
       --> _v168:Data
  (18) read(_v213:Index,read(_v213,_v214:Protocol))
       --> read(_v213:Index,_v214:Protocol)
  (21) mdata(read(_v238:Index,_v239:Protocol))
       --> mdata(_v239:Protocol)
  (22) cdata(_v241:Index,read(_v241,init)) --> 
      mdata(init)
  (23) flag(_v243:Index,read(_v243,init)) --> 
      vex
 

** end process input.

 
** Starting PigNose _____________________
 
#1(weight=3):
  25:[] _v120 = _v120
#2(weight=5):
  4:[] flag(_v122:Index,init) = invalid
#3(weight=7):
  21:[] mdata(read(_v238:Index,_v239:Protocol)) 
        = mdata(_v239)
#4(weight=7):
  23:[] flag(_v243:Index,read(_v243,init)) = 
        vex
#5(weight=8):
  1:[] flag(#c-2.Index,write(#c-3.Index,#c-1.Data,
                             #c-1.Protocol)) 
       = shared
#6(weight=8):
  2:[] flag(#c-1.Index,write(#c-3.Index,#c-1.Data,
                             #c-1.Protocol)) 
       = shared
#7(weight=8):
  5:[] cdata(_v127:Index,write(_v127,_v128:Data,
                               _v126:Protocol)) 
       = _v128
#8(weight=8):
  7:[] flag(_v141:Index,write(_v141,_v142:Data,
                              _v140:Protocol)) 
       = dirty
#9(weight=8):
  9:[] mdata(write(_v154:Index,_v155:Data,_v156:Protocol)) 
       = mdata(_v156)
#10(weight=8):
  22:[] cdata(_v241:Index,read(_v241,init)) 
        = mdata(init)
#11(weight=13):
  6:[] _v133:Index = _v135:Index | cdata(_v135:Index,
                                         write(_v133:Index,
                                               _v134:Data,
                                               _v136:Protocol)) 
                                   = cdata(_v135,
                                           _v136)
#12(weight=9):
  18:[] read(_v213:Index,read(_v213,_v214:Protocol)) 
        = read(_v213,_v214)
#13(weight=10):
  10:[] flag(_v159:Index,_v160:Protocol) = invalid | 
        read(_v159:Index,_v160:Protocol) = _v160
#14(weight=10):
  11:[] cdata(_v167:Index,read(_v167,write(_v166:Index,
                                           _v168:Data,
                                           _v165:Protocol))) 
        = _v168
#15(weight=11):
  8:[] _v148:Index = _v150:Index | flag(_v150:Index,
                                        write(_v148:Index,
                                              _v149:Data,
                                              _v147:Protocol)) 
                                   = invalid
 
** UNIT CONFLICT_________________________
 
  93:[binary:92,25] 
 
** PROOF ________________________________
 
  1:[] flag(#c-2.Index,write(#c-3.Index,#c-1.Data,
                             #c-1.Protocol)) 
       = shared
  2:[] flag(#c-1.Index,write(#c-3.Index,#c-1.Data,
                             #c-1.Protocol)) 
       = shared
  3:[back-demod:90] ~(cdata(#c-2.Index,write(#c-1.Index,
                                             #c-1.Data,
                                             #c-1.Protocol)) 
                      = cdata(#c-1.Index,write(#c-1.Index,
                                               #c-1.Data,
                                               #c-1.Protocol)))
  5:[] cdata(_v127:Index,write(_v127,_v128:Data,
                               _v126:Protocol)) 
       = _v128
  8:[] _v148:Index = _v150:Index | flag(_v150:Index,
                                        write(_v148:Index,
                                              _v149:Data,
                                              _v147:Protocol)) 
                                   = invalid
  25:[] _v120 = _v120
  90:[para-into:8,2,dconst] 
    #c-3.Index = #c-1.Index
  91:[para-into:8,1,demod:90,dconst:flip] 
    #c-2.Index = #c-1.Index
  92:[back-demod:90,3,demod:91,5] 
    ~(#c-1.Data = #c-1.Data)
  93:[binary:92,25] 
 
** ______________________________________
 

** Search stopped due to max-proofs option.
 
** PigNose statistics ------------------+
|  clauses given            ........15  |
|  clauses generated        ........33  |
|  clauses kept             ........31  |
|  clauses forward subsumed ........18  |
|  clauses back subsumed    .........0  |
+---------------------------------------+
(total run time 0.300 sec)
\end{verbatim}
    }
\item 結果は期待通り, すべて反駁に成功している.
  ログ内容を確認することにより, 推論内容も正しいことがわかる.
\end{itemize}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
