%$Id: engine.tex,v 1.1.1.1 2003-06-19 08:27:05 sawada Exp $
%\documentclass[11pt]{jarticle}
\documentclass[a4paper,11pt]{jarticle}
\usepackage[dvips]{epsfig}
\usepackage{proof}
\setlength{\textwidth}{5.5in}
\setlength{\textheight}{9in}
\setlength{\hoffset}{-.25in}
\setlength{\voffset}{-1.0in}
\setlength{\parskip}{.1in}
%%%%%%%%%%
\begin{document}
% 表紙
\pagenumbering{roman}
\addtocounter{page}{1}
\begin{titlepage}
\hspace*{3.8in}
\parbox{3in}{開放型分散環境での \\ ソフトウェア部品検証システムの \\研究開発}
\vspace{1in}
\begin{center}
{\LARGE\bf 検証推論システム基本・構成設計書} \\
{\Large\bf 反駁システム\\ 仕様検証システム \\ モデル検査システム}
\end{center}
\vspace{2in}
\date{\today}
\end{titlepage}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part*{本書の構成}

本書は「開放型分散環境でのソフトウェア部品検証システムの研究開発」
プロジェクトにおける，検証推論システム -- 反駁システム(反駁エンジン),
仕様検証システム，モデル検査システムの，基本仕様・構成設計書である．

全体は5部構成となっており，第I部でシステム全体の構成と各サブシステム機能の
概要を述べる．第II部で，全てのサブシステムに共通した，
CafeOBJ システムのコマンドインタプリタに対する拡張について述べる．
第III部で反駁システム，第IV部で仕様検証システム，最後の第V部で
モデル検査システムの仕様を定める．

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 目次
\tableofcontents
\newpage
\pagenumbering{arabic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{システム構成}

\section{システムの概要と構成}
\label{sec:abstract-all}

プロジェクトの目的を具体的な実験システムの構築という観点から見ると,
ネットワーク上での開放型分散環境において，
\begin{itemize}
\item (要求仕様に対する検証が可能な)
  ソフトウェア部品・サービスに対する検索エンジンと, 
\item 部品やサービスを組み合わせたシステム全体の振舞に関する検証エンジン
\end{itemize}
を実現し, これを統合したシステムの研究開発を行うことである．

開放型分散環境での部品やサービスは分散オブジェクトとして捉えることが
出来る. その機能/動作の表現には入出力のデータ(型)および, 
動的な振る舞い(状態遷移)の記述が必要となる.
この場合, インタフェースの表現には, 
現在一般的に広く使用されている
IDLのベースとなっている概念, 標示(シグニチャ)が有効である.
動作に関しては, それがうまく表現できるだけではなく, 
検証を行う必要があることから, なんらかの形式的な論理体系が必要であり,
しかも, 効率良く計算機上で形式的証明が実行出来るようなものでなければ
ならない. 

上のような要件を提供する枠組として, 一般に振る舞い論理と総称される
形式表現が適切である. 
部品やサービスの仕様の記述にはこのような論理的枠組を提供する形式仕様言語を用いる.
このような言語の一つに，隠蔽代数に基づく振る舞い仕様の記述を可能としている 
CafeOBJ がある. 
CafeOBJ は単にオブジェクトの振る舞いの記述にとどまらず,
強力なデータ型定義の機能, また高度な仕様のモジュール化機能を
備えているため表現能力に優れ, 既存の IDL などによる記述を, 容易に
マッピングすることが可能である. また, 実働する処理系がフリーで
入手できる. このことからシステムの実装には, CafeOBJ の処理系(インタプリタ)を
ベースとする.

統合されたシステムには部品のデータベースとしてリポジトリがあり,
各リポジトリに CafeOBJ 言語で記述した隠蔽代数による部品の振る舞い仕様を
登録しておくことで, 部品毎の機能に基づいた検索を可能にする.
この場合, 部品の検索・検証を行う上で基本的となるのが，
\begin{enumerate}
\item[(1)] シグニチャ・マッチング --- 仕様の構文的検索
\item[(2)] 仕様の振舞詳細化検証
\item[(3)] 振舞モデル検査法を用いた統合システム検査
\end{enumerate}
である．

本書で機能および構成仕様を与える\textbf{検証推論システム}は，これらの
基本要素となる機能を CafeOBJ インタプリタを拡張することで提供するものである．
上の (1) と (2) の機能は，併せて \textbf{仕様検証システム} として
構成される．(3) の機能は \textbf{モデル検査システム} が提供する．
これら2つのシステムの核として，\textbf{反駁システム} がある．
仕様検証およびモデル検査の両者とも，基本的には定理証明を行うものである．
このシステムでは隠蔽代数を扱うため，状態空間の遷移に関しての証明が
行わなければならない．そのため，状態空間を述語論理で表現する方法をとり，
したがって定理証明は，(等号付きの)一階述語論理における定理証明となる．
反駁システムは，このための定理証明系であり，システムの中心は反駁システム
の提供する，resolution に基づいた反駁エンジンである．
図~\ref{fig:bigpink-arch} にシステムの構成を示す．

{\sloppy
\begin{figure}[htb]
  \begin{center}
%    \epsfxsize=0.8\textwidth
    \epsfbox{bigpink-arch.eps}
    \caption{検証推論システムの構成}
    \label{fig:bigpink-arch}
  \end{center}
\end{figure}
}

図~\ref{fig:bigpink-arch} で, \textbf{Refinement Check System} とあるのが
仕様検証システム, \textbf{Model Check System} とあるのが モデル検査システム,
また, \textbf{Refutation System} となっているのが, 反駁システムである.
これらのシステムの機能は, (拡張された) CafeOBJ インタプリタへのコマンド
として外部へ提供される. したがって, CafeOBJ のコマンドインタプリタが
新規のコマンドあるいは構文によって拡張される. 図で \textbf{Extended Command
Interpreter} とあるのが, この拡張されたコマンドインタプリタである.
外部の利用者やシステムは, このコマンドインタプリタを通じてこれらのシステムの
機能を利用することになる.

\section{仕様検証システムの概要}
\label{sec:refine-check-abstract}

仕様検証システムは，ある部品の仕様が与えられた時に，それが要求仕様を
満足するものかどうかを形式的に検証するものである．

システム全体の文脈で言うと，
最初は，要求仕様 $R$ と合致するような部品の仕様 $P$ を
探索することから始まる．この時にシグニチャマッチングを利用して，
要求仕様に構文的に合致しないような部品仕様をふるいに掛けて払い落すことが出来る．
シグニチャマッチングは，マッチングが成功すると，
$R$ から $P$ への仕様射 $M$ を生成する．
仕様検証システムではこの $M$ を利用し，要求仕様 $R$ の公理を
$P$ へ写像して，それが $R$ で満足されるものかどうかを検査する．
これは，反駁エンジンを利用して，検査対象とする公理の否定が
反駁されるかどうかを調べることで可能である．

通常部品の仕様は部品の実装やあるいはシ実際のシステムに関連つけられている事が
多いと考えられ，そのため振舞仕様として与えられると考えられる．
従って公理の充足性の検証は，振舞等式の検証も含まれなければならない．
この場合は，振舞の状態空間の遷移に関しての双帰納法による定理証明となる．
このような場合は，次章のモデル検査システムの機能も利用することになる．
いずれの場合も，核となる定理証明には，反駁システム(反駁エンジン)が用いられる．

\section{モデル検査システムの概要}
\label{sec:model-check-abstract}

モデル検査は，部品の組合せで構成されたシステムに関する
安全性や，データの整合性等のさまざまな性質を網羅的に検査するものである．
このようなシステム全体の動的な性質を構成部品の仕様から演繹的に導くことは
出来ない．従って前述の仕様検証システムでは不足である．

モデル検査では，このための検証プロセスを述語計算における繰り返し演算で
浮動点を求めることとして定式化する．この計算に反駁システムが利用出来る．

\section{反駁システムの概要}
\label{sec:refutation-abstract}

既に上の説明で触れられている通り，反駁システムは仕様検証や
モデル検査の際に実行される定理証明の核となるエンジンとして機能するものである．

エンジンは，等号を含む一階述語論理系における，resolution をベースとした
反駁方式による定理証明システムである．
対象とする問題の複雑性や，実験/研究のためのシステムの柔軟さの必要性を考えた場合，
相当程度の能力のある，しかも細かな調整がある程度可能な証明系であることが望ましい.
そこで，定理証明の分野では既に長年の実績が
あり，既に評価の定まっている自動証明システム 
{{\sc Otter}}\cite{otter} の機能仕様をベースとして仕様を定めた．
エンジンの中核部分は，基本的に {{\sc Otter}} のそれのサブセットとなっている．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\part{CafeOBJ コマンドインタプリタの拡張}
\label{sec:ext-interpreter}

第I部で述べた通り，システムの機能は新規のコマンドによって外部に提供され，
そのため CafeOBJ システムのコマンドインタプリタを拡張することになる．
ここでは, CafeOBJ のコマンドインタプリタの拡張方法について述べる.

\section{CafeOBJ コマンドインタプリタの構成と動作}
\label{sec:cafeobj-command-interpreter}

現状の CafeOBJ のコマンドインタプリタの構成を図~\ref{fig:command-arch}に示す．
次章でこの図を参照しつつ, コマンドインタプリタの動作を説明する.

\begin{figure}[htbp]
  \begin{center}
    \epsfbox{command-arch.eps}
    \caption{CafeOBJ コマンドインタプリタの構成}
    \label{fig:command-arch}
  \end{center}
\end{figure}

コマンドインタプリタは外部からのコマンド文字列
(図~\ref{fig:command-arch} の \textbf{Input strings given by user}) を
読み込み, 以下に述べるような処理を実行する：

\begin{enumerate}
\item 構文解析

  コマンドの構文表(図の \textbf{Command syntax table})を参照し,
  与えられた文字列の構文解析を実行する.

\item 抽象構文木(ADT)の作成

  構文解析の結果として, 抽象構文木 (ADT) を作成する(図で \textbf{ADT instance} 
  とあるのが, 作成された抽象構文木である)．
  この作成には, あらかじめ各構文に対応して用意されている ADT の構造定義
  (図の \textbf{ADT definitions}) を参照する.

\item 汎用のADT評価器の起動

  作成された ADT に対応する処理を実行するために, 汎用のADT評価器
  (図の \textbf{Generic ADT evaluator})を起動する. 
  各 ADT はコマンドの引数の内容とともに, その評価関数の
  名前も保持している. 汎用のADT評価器は, それを参照して
  対応する評価関数(図の \textbf{ADT evaluators} を起動する.
  
\end{enumerate}

\section{コマンドインタプリタの拡張}
\label{sec:extending-command-interpreter}

前章で説明したことから, コマンドインタプリタを拡張とは,
具体的には以下の作業となる：

\begin{description}
\item[コマンドの構文表への登録]
  拡張したいコマンドの構文を定義し, それを CafeOBJ インタプリタの
  構文表へ登録しておく. 
\item[ADT の定義]
  コマンドに対応した ADT を定義する. 
  これは CafeOBJ に組み込みの, 構文定義機能を使用する.
  この機能は \verb|defterm| という名前のマクロとして提供されており,
  これを利用してADTの定義を行う.

  ADTの定義は, 具体的には構造体(レコード構造)の定義であり,
  先に述べた ADT のインスタンスとは, 対応する構造体の
  インスタンスに他ならない.
  このインスタンスのスロットをアクセスすることによって,
  実際に入力されたコマンド列に対応した等を得る事が出来る.

  ADT の定義を行う \verb|defterm| は次のようにして使用する：
\begin{verbatim}
  (defterm 名前 (%script)
    :visible (引数-1 .... 引数-n)
    :eval 評価関数名)
\end{verbatim}
  ``名前'' には, コマンドに対応した適当な名前を指定する.
  ``引数-1'' から ``引数-n'' は個々のコマンドの引数を
  納めるスロットにつける名前である.

\item[ADT 評価関数の定義]
  コマンドのADTに対応した評価関数を用意する.
  関数の名前は, 上記の ADT の定義で与えた評価関数名にする.

  評価関数は ADT のインスタンスを引数と受け取るようなもので
  なければならない.
\end{description}

実際の作業にあたっては, 既に存在する CafeOBJ のコマンド群の
実装を見る事によって, 上のような枠組は容易に構築出来るはず
である.

以降で, 新規のコマンドの仕様を与える場合は,
上で述べた \verb|defterm| による, ADT の定義も併せて示す
こととする.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\part{反駁システム}
\label{sec:intro-refutation-engine}

第III部では「仕様検証システム」および「モデル検査システム」から
定理証明エンジンとして用いられる\textbf{反駁システム}
の基本仕様ならびに構成仕様を記述する. 

既に第~\ref{sec:refutation-abstract} 章で述べた通り，
反駁システムは，等号を含む一階述語論理の上での定理証明システムであり，
resolution に基づいた反駁エンジンを提供するものである．
このことから，本書では，反駁システムを「反駁エンジン」あるいは，単に「エンジン」
と呼ぶ事がある．

本章の構成は以下の通りである. まずはじめに, エンジンの機能の概要を
述べる．CafeOBJ インタプリタへの組込み方法についてもここで定義される.
次に, エンジンの構成と各サブシステムの機能の概要を定義する.
以降で, 定められたそれぞれのサブシステムに関して内部構造と機能の詳細な
定義を行うが, それに先だって基本的な共通データ構造を定義し,
ついで各サブシステムについて, 基本仕様ならびに構成の定義を併せて行う.

\section{反駁システムの機能}
\label{sec:func-abst}
システム全体におけるエンジンの位置づけは既に述べた．
ここでは，CafeOBJ インタプリタとの関係を明らかにし, 
その基本的な機能について定める. 

\subsection{機能概要}
\label{sec:engine-function}

反駁エンジンは resolution calculus に基づく定理証明エンジンであり, 
CafeOBJ インタプリタに組込みとなる. 
その基本機能は,
\begin{itemize}
\item CafeOBJ モジュールで宣言される公理を, 等号を含む一階述語論理(以降
  \textbf{FOPL} と呼ぶ)の論理式とみなし,  
\item そのモジュールの文脈において, 与えられた述語が論理的帰結となるかど
  うかを反駁法によって証明する.
\end{itemize}
というものである.
利用者は, 述語の記述に際して, 直接 FOPL レベルの論理式を使用することがで
きる. 
反駁エンジンを組み込んだインタプリタは, 通常の CafeOBJ インタプリタとし
てなんら変わる事無く使用できる. エンジンの機能は新規の言語要素，コマンド
群として提供される．

CafeOBJモジュールの等式集合は, horn 節の集合とみなされ(システムが自動
的に節形式に変化する), resolution 原理をベースとした定理証明を実行する
(CafeOBJ モジュールをどのように解釈するかは, 後の節で説明する.) 
対象とする節の集合は必ずしも horn 節には限定されない. また FOPL の文を直
接記述することが可能で, システムは自動的にこれらを節集合へ変換する．

証明に際しては，次のような推論規則が用意されており，問題に応じてこれらを
組み合わせて使用することが可能である．
\begin{enumerate}
\item binary resolution
\item hyper resolution
\item paramodulation
\end{enumerate}
システムでは自動モードも用意し, システムが対象とする節集合の性質に応じて
適当な推論規則を自動選択する機能も提供する．

\subsection{CafeOBJインタプリタへの組み込み}
\label{sec:embedding}

反駁エンジンは CafeOBJ インタプリタに完全に組み込みとする.
すなわち, モジュールや項等のインタプリタの持つ内部構造を共有する.
利用者から見た場合, 新たに導入される構文やコマンドによって,
従来のインタプリタの持つ機能が拡張されたものと見る事ができる.

利用者の記述する FOPL 文は, CafeOBJ の通常の項によって表現する.
このために FOPL 文のための新たな(組み込み)ソートを導入する.
FOPL 文の構文定義はこの新規ソートを定義した新たな組む込みモジュール
(FOPL-CLAUSE)によって提供し, 利用者はこのモジュールを輸入することによって,
反駁エンジンを利用することができるようにする.

\paragraph{CafeOBJモジュールの解釈}

先に述べた通り, 反駁エンジンは CafeOBJ モジュールの等式を等号を含んだ
一階述語論理(FOPL)の公理とみなす. 従って, CafeOBJ システムの等式をどのよ
うに解釈するのか, という規則が定められていなければならない. また,
CafeOBJ モジュールには等式の他に遷移規則も含まれていたりするが, これは 
通常の FOPL における証明の対象とすることは不可能である. 
従って何らかの制約事項を設ける必要がある. 

まず最初に大前提として,
\begin{itemize}
\item CafeOBJ 組み込みの真偽値のためのソート \textbf{Bool} を,
  FOPL レベルの真偽値を表現するためのソートとして使用する
\end{itemize}
という規定を設ける.
従って, Bool 値の CafeOBJ 項は FOPL の文(述語)と解釈される.
その他の CafeOBJ 項は述語の引数として出現するのでない限り, 正当な式とは
見なされない.

CafeOBJ の(条件付き)等式は, 次のような形をしている.
\begin{verbatim}
        <左辺> = <右辺> if <条件> .
\end{verbatim}

これを FOPL の implication (含意 \verb|->|)
\begin{verbatim}
        <条件> -> <左辺> = <右辺> 
\end{verbatim}
だと思い, 節形式に変換すると
\begin{verbatim}
        ~<条件> | <LHS> = <RHS> 
\end{verbatim}
となる. 従って等式は, horn 節とみなすことができる. ここで, CafeOBJ 等式
の \verb|=| を FOPL の等号 \verb|=| と解釈している事に注意. また,CafeOBJ の
条件部は一般に Bool 値の項であり, したがって組み込みソートの Bool を
FOPL の真偽値のためのソートとしている.  

実際には CafeOBJ モジュールで定義される論理系はハイブリッドで複雑なもの
であり, 全てのケースで上のような単純な解釈を許すものではない. 
このため, CafeOBJ モジュールに対して以下のような制約を課す. 

\begin{enumerate}
\item 遷移規則は使用できない
\item 利用者定義のオペレータが，組み込みソート Bool を引数に持っていてはな
    らない．
\item 振舞等式の = と 通常の = とを区別しない.
\item \verb|if_then_else_fi| は使用できない.
\item メンバシップ述語 (\verb|_:<ソート名>|) は使用できない.
\item 組み込みの等式(Lisp関数で定義されているもの)は resolution に
  用いることはできない．但し，demodulator としては使用できる．
\end{enumerate}

さらに, 以下の組み込み述語はそれぞれ下に示す FOPL の論理結合子に変換され
る：
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{|l|l|}\hline
    CafeOBJ組み込み述語 &           FOPL論理結合子\\\hline\hline
    \verb|_and_| &                 \verb|_&_| (論理積) \\\hline
    \verb|_or_| &                   \verb^_|_^ (論理和) \\\hline
    \verb|not_| &                  \verb|~_| (否定) \\\hline
    \verb|_implies_|  &            \verb|_->_|(含意) \\\hline
    \verb|_and-also_| &            \verb|_&_| (論理積) \\\hline
    \verb|_or-else_| &             \verb^_|_^ (論理和) \\\hline
    \verb|_==_|      &             \verb|_=_| (等号) \\\hline
    \end{tabular}
    \caption{組み込み述語の解釈}
  \end{center}
\end{table}


また, 組み込み xor に関しては,
\begin{verbatim}
    p xor q --> (~p | ~q)&(p | q)
\end{verbatim}
のような変換を行う.

\paragraph{新規組み込みモジュール}

先に FOPL 文の構文を提供する新たな組み込みモジュールを提供する,
と述べた.
あるモジュールの文脈で, 反駁エンジンの機能を利用するには, そのモジュール
が, この FOPL 文の構文を定義した \verb|FOPL-CLAUSE| という新規の組込みモ
ジュールを輸入していること(サブモジュールの一つになっている事)が必要であ
る. 

このモジュールは prelude ファイル fopl.mod で定義され, 
FOPL の論理式の構文が定義されている. また, システムは, FOPL-CLAUSE が輸
入されているモジュールでは, 反駁エンジンで導入された機能が使用できるよう
に実行環境を設定する.

\section{FOPL の構文}
\label{sec:fopl-syntax}

ここでは \verb|FOPL-CLAUSE| で定義される FOPL の構文を示す．FOPL の文は 
CafeOBJ 項で表現される．そのソートは \verb|FoplSentence| と名付け，
また組み込みソート Bool の上位ソートとして宣言する.

\begin{description}
   \item[● FOPL 文のソート]
     \begin{verbatim}
[Bool < FoplSentence]
     \end{verbatim}
\end{description}

このことから了解されるように，Bool の CafeOBJ 項は FOPL の文であり，
Bool 値のオペレータは述語とみなされる．

論理結合子の構文を CafeOBJ のオペレータ宣言で示すと以下のようになる．

\begin{description}
   \item[● 論理和]
     \begin{verbatim}
op _|_ : FoplSentence FoplSentence -> FoplSentence 
         { prec: 107 }
     \end{verbatim}

   \item[● 論理積]
     \begin{verbatim}
op _&_ : FoplSentence FoplSentence -> FoplSentence 
         { prec: 101 }
     \end{verbatim}
     
   \item[● 否定]
     \begin{verbatim}
op ~_ : FoplSentence -> FoplSentence 
        { prec: 0 }
     \end{verbatim}

   \item[● 含意]
     \begin{verbatim}
op _->_ : FoplSentence FoplSentence -> FoplSentence 
          { prec: 120 }
     \end{verbatim}

   \item[● 同値]
     \begin{verbatim}
op _<->_ : FoplSentence FoplSentence -> FoplSentence 
           { prec: 120 }
     \end{verbatim}

   \item[● 等号]
   \begin{verbatim}
op _=_ : FoplSentence FoplSentence -> FoplSentence 
         { prec: 51 }
   \end{verbatim}
\end{description}

次に，限定子に関しては下のように定義する．
\begin{description}
  \item[● 全称限定子(forall)]

  \begin{verbatim}

op \A[_] _ : VarDeclList FoplSentence -> FoplSentence 
             { prec: 125 }
  \end{verbatim}

  \item[● 存在限定子(exists)]

  \begin{verbatim}

op \E[_] _ : VarDeclList FoplSentence -> FoplSentence 
             { prec: 125 }
  \end{verbatim}
\end{description}
ここで, \verb|VarDeclList| は変数名あるいは on-the-fly の変数宣言
($VAR:SORT$ の形の変数宣言 -- $VAR$ は変数名, $SORT$ はソート名である)
をコンマ記号(,)で区切って並べたものである. 

\section{新規構文}
\label{sec:new-construct}

反駁エンジン組み込みに伴い, 以下の新規構文を導入する.

\begin{enumerate}
\item \verb|ax <ラベル> <項> .|

    \verb|ax| は FOPL 文による公理を宣言するものである．
    \verb|<項>| は，ソート \verb|FoplSentence| の項でなければならない．
    \verb|ax| で宣言された公理は，従来の CafeOBJ の
    \verb|red| コマンドや \verb|exec| コマンドで使用される書き換え規則と
    して使う事は\textbf{できない}．

    \verb|<ラベル>| は公理のラベルであり, 通常の CafeOBJ の公理のラベル
    と同じ構文とし, CafeOBJ 公理と同様に省略可能とする.

    <項> の中に自由変数が出現する場合は，それらは暗黙的に
    $\forall$ (\verb|\A[_]|) で束縛されているものと解釈する．

\item \verb|goal <ラベル> <項> .|

    \verb|goal| は \verb|ax| と同様であるが，\verb|<項>| の否定を自動的
    に取るものであり， 

    \begin{verbatim}
        ax ~ <項> 
    \end{verbatim}
    の簡易表記法である．
\end{enumerate}
\verb|ax| と \verb|goal| は従来の CafeOBJ の公理宣言文(等式や遷移規則)
が出現できる場所ならば, どこにでも出現しても良い. 
また, CafeOBJ のモジュール表示コマンド(\verb|show モジュール式|)によって 
モジュール内容が表示される際には, \verb|ax| による FOPL 文も表示される
ようになる. ただし, \verb|goal| による公理宣言の場合は, 表示においては
\verb|ax| に置き換えられて表示されるものとする.

\section{反駁システムの新規コマンド群}
\label{sec:new-commands}
新規コマンドとしては以下のものを導入する.

\begin{description}
\item[flag コマンド]

  反駁エンジンの証明戦略の設定や, エンジンの動作を制御するためのさまざまな
  フラグの設定のためのコマンドである.
  構文は次のとおり． 
\begin{verbatim}
<flagコマンド> :: = flag(<フラグ名>, { on | off })
\end{verbatim}

  第一引数の\verb|<フラグ名>| は設定したいフラグの名前であり，第二引数で
  フラグの on/off を設定する．フラグの種類やその意味については後述する．

  対応する ADTの定義は(第 \ref{sec:extending-command-interpreter}章を参照
  --- 以降同様) は次のように定める：
  \begin{verbatim}
(defterm pn-set-flag (%script)
  :visible (name value)
  :eval eval-pn-set-flag)  
  \end{verbatim}
  \verb|name| はコマンドで指定されたフラグ名，\verb|value| は on または
  off の指定である．
  
\item[param コマンド]

  フラグコマンドと同様に，エンジンの動作を制御するためのパラメータの設定を
  行うためのコマンドである．
\begin{verbatim}
   <paramコマンド> ::= param(<パラメータ名>, <値>)
\end{verbatim}
\verb|<パラメータ名>| は値を設定したいパラメータの名前，\verb|<値>| は設
定したい値であり，整数値を指定する．設定可能な値の範囲は個々のパラメータ
毎に定められている．パラメータの種類や意味については後述する．

対応するADT の定義は次の通りとする：
\begin{verbatim}
(defterm pn-assign (%script)
  :visible (name value)
  :eval eval-pn-assign)
\end{verbatim}
  name はコマンドで指定されたパラメータ名，value は値である．
 
\item[save-option コマンド]

  現在設定されているフラグとパラメータの値を名前を付けて保存するためのコマ
  ンドである．
\begin{verbatim}
   <save-option コマンド> ::= save-option <オプション名>
\end{verbatim}
  指定の \verb|<オプション名>| でフラグとパラメータの現在値を保存する．
  \verb|<オプション名>| は任意の英数文字列．

  対応する ADT の定義は次の通りである：
\begin{verbatim}
(defterm save-option (%script)
  :visible (name)
  :eval pn-eval-save-option)
\end{verbatim}
  name は，コマンドで指定されたオプション名である．

\item[option コマンド]

  フラグやパラメータの値を全て初期値に戻したり，\verb|save-option| コマ
  ンドで以前に保存されているフラグ/パラメータ値を現在値として設定するた
  めのコマンド．
\begin{verbatim}
    option { reset | = <オプション名> }
\end{verbatim}
  \verb|<オプション名>| として \verb|reset| を指定すると，全ての値が初期
  値に再設定される．

  対応する ADT の定義は次の通りとする：
\begin{verbatim}
(defterm pn-option (%script)
  :visible (command &optional name)
  :eval eval-pn-option)
\end{verbatim}  
  command は，コマンドの引数に \verb|reset| が指定された場合は
  \verb|:reset| となり，name は省略される．
  そうでなければ :restore となり，name はコマンド引数で指定された
  オプション名である．

\item[db reset]

  反駁エンジンは, 文脈モジュールで推論を実行するにあたって，さまざまな情
  報を維持し管理する．`\verb|db reset|' はこのデータベースの初期設定を行
  うためのコマンドである．通常は推論実行コマンド `\verb|resolve|' の直前
  でこれを行う必要がある．自動モードで推論を行う場合は不要である．

  対応する ADT の定義は次のとおりとする：
\begin{verbatim}  
(defterm pndb (%script)
  :visible (arg)
  :eval eval-pndb)
\end{verbatim}
  arg は使用されない(無意味).

\item[list コマンド]

  フラグやパラメータ，また推論に用いる節集合(sos や usable -- 後述) の内
  容を表示するためのコマンドである．

\begin{verbatim}
   <listコマンド> ::= list { axiom | sos | usable | flag | param |
                             option }
\end{verbatim}

  それぞれの引数の値に対して表示される内容は次の通り：

  \begin{center}
  \begin{tabular}{|lcl|}\hline
  axiom       &:& 文脈モジュールで宣言されている公理を節形式で印字\\
              &&  あらかじめ，db reset コマンドが実行されている必要がある．\\
   sos        &:& 節集合 SOS に含まれる節\\
   usable      &:& 節集合 Usable に含まれている節\\
   flag        &:& フラグの一覧と現在の設定値\\
   param       &:& パラメータの一覧と現在の設定値\\
   option      &:& save-option コマンドでセーブされたオプション名の一覧\\
   demod      &:& demodulator 一覧 \\\hline
  \end{tabular}
  \end{center}

  このコマンドに対応した ADT の定義は次の通りとする：
\begin{verbatim}
(defterm pn-list (%script)
  :visible (arg)
  :eval eval-pn-list)
\end{verbatim}
arg は list コマンドで指定された引数である．

\item[sos コマンド]

  節集合 SOS を設定するためのコマンド．あらかじめ db reset が実行されて
  いる必要がある．構文は下の通り：

\begin{verbatim}
   <sosコマンド> ::= sos { = | + | - } <節集合>
\end{verbatim}
  第一引数の意味は以下の通り：

  \begin{center}
    \begin{tabular}{|lcl|}\hline
      \verb|=|     
      &:& sos を \verb|<節集合> |で指定された節の集合に設定する\\
      \verb|+|     
      &:& 現在の sos の内容に \verb|<節集合>| で指定された節を加える\\
      \verb|-|     
      &:& 現在の sos から \verb|<節集合>| で指定された節を削除する\\\hline
    \end{tabular}
  \end{center}

  \verb|<節集合>| の構文は下の通り:
\begin{verbatim}
   <節集合> ::= '{' <節指定> { , <節指定> }* '}'
\end{verbatim}

  \verb|<節指定>| は，公理ラベル, 節識別子，あるいは \verb|let| 変数名の
  いずれかである.  公理ラベルは, CafeOBJ の公理宣言で指定された, 公理の
  ラベル. 節識別子はシステムが節を生成する際に与えられるものであり，list
  axioms コマンド等によって知る事ができる．let 変数名が指定された場合は，
  指定の変数に束縛されている項を節形式に変換したものが用いられる．

  節指定の解釈は, 次の規則に従うものとする:
  \begin{enumerate}
  \item 節指定が数字の場合, これは節識別子であると解釈する.
  \item 数字では無い場合, まず公理のラベルであると解釈する.
  \item 2 で該当する公理が一つも無い場合は, let 変数名であると解釈する
    .
  \end{enumerate}
  上のいずれの解釈によっても, 節が見付からない場合はエラーとする.
  節指定として公理のラベルが指定された場合，同じラベルを持った公理が
  複数存在する場合は，それらの公理全てが指定されたものと解釈する．

  特別なラベル(システムで予約されたラベル)として以下のものがある：
  \begin{center}
  \begin{tabular}{|l|l|}\hline
  ラベル名 & 意味 \\\hline
  sos & 公理を暗黙的に sos に入れることを指定する．\\
  demod & 公理を demodulator としてのみ使用することを指定する\\\hline
  \end{tabular}
  \end{center}
  ラベルに sos と指定された場合は，db reset コマンドが発せられる前に
  sos コマンドが実行されていなかった場合に，システムはそのラベルの付いた節を
  自動的に sos 集合へ入れる．

  また，demod と指定された公理は，推論ルールによる
  導出には使用されず，demodulator(書き換え規則) としてのみ使用される．

  SOS 集合は初期には空であり，また db reset を行った時点で空に設定される．
  sos コマンドの実行に伴って，usable 集合の内容が副作用として決められる．
  つまり，list axioms で表示される節から SOS 集合の内容を取り去ったものが
  Usable 集合として設定される．

  このコマンドに対応するADT定義は次の通りとする：
\begin{verbatim}
(defterm sos (%script)
  :visible (operation
            clause-list)
  :eval eval-sos)
\end{verbatim}
        operation は，コマンドの第一引数で指定された動作区分
        (\verb|=|, \verb|+|, \verb|-| の区別), 
        clause-list は第二引数で指定された節集合の指定である．

\item[resolve コマンド]

  反駁エンジンを起動するためのコマンド．

\begin{verbatim}
   <resolveコマンド> ::= resolve {. | <ファイル名>}
\end{verbatim}
  引数が \verb|<ファイル名>| で指定されるファイルへのパス名の場合は，指
  定のファイルへ実行ログが出力．これが `.' (ピリオド記号)の場合は標準出力へ
  ログが出力される．

  このコマンドに対応する ADT は次のように定義する：
\begin{verbatim}
(defterm resolve (%script)
  :visible (arg)
  :eval eval-resolve)
\end{verbatim}
  arg は resolve コマンドの引数である．

\item[clause コマンド]

\begin{verbatim}

    <clauseコマンド> ::= clause <項> .
\end{verbatim}
  \verb|<項>| はソート FoplSentence の項でなければならない．指定の項を節形
  式に変換して印字する．

このコマンドに対応したADT定義は次の通りとする：
\begin{verbatim}
(defterm clause-print (%script)
  :visible (term)
  :eval eval-clause-show)
\end{verbatim}
  term はコマンドの引数の項である．
  
\item[show コマンド]
  従来の CafeOBJ コマンド \verb|show| を拡張したものである.
\begin{verbatim}
    <showコマンド> ::= show <節ID> 
\end{verbatim}
  \verb|<節ID>| で指定される節を印字する．\verb|<節ID>| は節の識別子であり，
  `list axioms' や，`list sos' 等で表示される内容から知ることができる．

  これは従来の CafeOBJ インタプリタの ADT 定義をそのまま利用する．

\end{description}

\newpage
\section{反駁エンジンの構成と動作の概要}
\label{sec:architecture}
本章では反駁エンジンの内部構成と各サブシステムの機能, それらの間の関係について
述べる.

図\ref{fig:pignose-arch} に反駁エンジンの構成を示す．

\begin{figure}[htbp]
  \begin{center}
    \epsfxsize=\textwidth
    \epsfbox{pignose-arch.eps}
    \caption{反駁システムの構成}
    \label{fig:pignose-arch}
  \end{center}
\end{figure}

先に述べた通り, 反駁エンジンは CafeOBJ インタプリタに組み込みのものであり,
利用者あるいは外部のシステムからは, CafeOBJ トップレベルの コマンドインタプリタを
介してその機能が利用される. 従って, CafeOBJ のコマンドインタプリタは,
反駁エンジンへのコマンドを解釈/実行出来るように拡張される. 
図\ref{fig:pignose-arch}で，\textbf{CafeOBJ command iterpreter} とあるのが
この拡張されたコマンドインタプリタである．
また, FOPL 文による公理の宣言を可能にするため, CafeOBJ の構文のうち公理の宣言に
ついても拡張されるため, これに対しても CafeOBJ のコマンドインタプリタが拡張
されることになる(CafeOBJ インタプリタではコマンドインタプリタが CafeOBJ 構文の
解釈も行っている). 

次に反駁システムであるが，その本体の構成は，図で太枠で囲まれた 
\textbf{Refutation System} として示されている．
これは 実際に resolution を行うエンジン本体部分(図の \textbf{Refuation engine}),
エンジンの実行を制御するための設定を行うパラメータやフラグの設定モジュール
(図の \textbf{Setting options}), 
CafeOBJ モジュールで定義された内容を, 
反駁エンジンにかけるための変換を実行するモジュール(図の \textbf{CafeOBJ Axioms
-$>$Clausal Form translation}), その他, 利用者にさまざまな情報を開示するための
ユーティリティ・モジュール(図の \textbf{Printing/messaging utilities})に
大別することが出来る. 

以下で，図\ref{fig:pignose-arch}を参照しつつ，反駁システムの動作の概要を
説明する．既に述べた通り利用者定義のモジュール(図の\textbf{User module})
で推論システムの機能を利用するためには，FOPL 構文を定義したモジュール
(FOPL-CLAUSE) を輸入している必要がある．利用者モジュールで宣言された公理
の集合(図のAxioms)は，推論システムの，公理から節形式への変換モジュール
(CafeBJ Axioms -$>$ Clausal Form Translation) によって，対応する
節の集合(図の Set of clauses)へ変換される．反駁エンジン(Refutation engine)
はこの節集合を対象に resolution を行い，反駁を試みる．推論に使用する
推論ルールの指定や各種の制約パラメータ(図の Flags\& parameters)は，
利用者からコマンドによって設定される．
図の Setting options はこの設定を行うモジュールである．
システムには使用する推論ルールに対応した実行モジュール群(図の 
\textbf{Inference rules}) があり，推論エンジンは現在設定されている
フラグを参照し，適宜この中から必要な実行モジュールを使用して推論を進める．
推論実行中には各種の統計データ(図の Statistics が収集される)．
これは，指定されたさまざまな実行制約にかかわるパラメータ値との照合を
取るのに使われる他，推論エンジンの動作結果を整理して利用者へ提示する際
にも使用される．Printing/messaging utilities は，このような統計情報データ
を表示したり，推論実行時におけるシステムの内部状態(Internal status)を
表示するためのモジュールである．

\section{基本データ構造}
\label{sec:basic-data-structures}
本章では, 反駁エンジンで導入される基本データ構造の仕様を定める.

\subsection{literal}
\label{sec:data-literal}
literal は, 節を構成するリテラルを表現するためのレコード構造
(structure) であり, 下に示す構造を持つ.
\begin{center}
\begin{tabular}{|l|l|l|}\hline
  スロット名 & 初期値 & 内容 \\\hline
  clause     & nil & スロットが含まれる節\\
  atom       & nil & リテラルの内容(項) \\
  sign       & t   & リテラルの正/負     \\
  type       & nil & リテラルの種別 \\
  stat-bits  & 0   & テンポラリなビットフラグ\\\hline
\end{tabular}
\end{center}

\begin{description}
\item[clause]
  スロット \verb:clause: によって, 当該のリテラルが含まれる節を知ることが
  出来る. 節は後述(第 \ref{sec:data-clause}節) のデータ構造 clause で表現
  される. 
\item[atom] ここには, リテラルの内容, つまり述語を表現する項が
  格納される. 項は通常の CafeOBJ 項の内部データ構造である.
\item[sign] 格納値が, 定数 \verb:t: であれば正のリテラル,
  定数 \verb:nil: であれば, 負のリテラルとする.
\item[type] リテラルの種別をあらわすキーワードシンボル. 以下のものを設定
  する： 
  \begin{itemize}
  \item \verb|:po-eq| 正の equality リテラル (アトムが \verb: P = Q: の形式).
  \item \verb|:neg-eq| 負の equality リテラル (アトムが \verb:~(P = Q): の形式).
  \item \verb|:normal-atom| 上記以外のリテラル.
  \end{itemize}
\item[stat-bits] リテラルのテンポラリな状態を表現するための
  ビットフラグである. 以下のものがある：
  \begin{itemize}
  \item ビット0(\#0x1) が on の時, equality リテラルの左右辺が, 順序
    付けによって入れ換えられたものであることをあらわす.
  \item ビット1(\#x02) が on の時, equality リテラルの左右辺の
    順序付けが出来たことをあらわす.
  \end{itemize}
\end{description}

\subsection{clause}
\label{sec:data-clause}
\verb:clause: は節を表現するためのレコード構造である. 下に示す構造を持つ：
\begin{center}
\begin{tabular}{|l|l|l|}\hline
スロット名  & 初期値 & 内容 \\\hline
parents     & nil    & 節の導出情報のリスト\\
literals    & nil    & 節に含まれるリテラルのリスト \\
id          & 0      & 節識別子 \\
pick-weight  & -1    & 節の重み \\
attributes  & nil    & 雑多な情報の assoc リスト \\
axiom       & nil    & 節に対応する公理 \\
container   & nil    & 節を含む節集合種別 \\\hline
\end{tabular}
\end{center}

\begin{description}
\item[parents] 当該の節が, 他の節から導出された場合, どの親から,
  どのような導出規則によって生成されたかを示す導出情報のリストを格納する.
  個々の導出情報はリスト構造であり下の形式とする：
  \begin{verbatim}
  (<導出規則識別子> . <節識別子リスト>)
  \end{verbatim}
  \verb|<導出規則識別子>| は導出規則を表すキーワードシンボルである.
  \verb|<節識別子リスト>| はその導出規則が適用された節の識別子のリストで
  あり, \verb|<導出規則識別子>| によっては空リストの場合もある.
  以下に示すものがある.
  {\small
  \begin{center}
    \begin{tabular}{|l|l|l|}\hline
    \verb|<導出規則識別子>| & 導出規則   & \verb|<節識別子リスト>| \\\hline
    :binary-res-rule & binary resolution & 適用された2つの節識別子\\
    :hyper-res-rule & hyper resolution & 適用された全て節の識別子 \\
    :neg-hyper-res-rule & negative hyper res. & 適用された全て節の識別子 \\
    :para-into-rule & paramodulation into & 適用された2つの節識別子 \\
    :para-from-rule & paramodulation from & 適用された2つの節識別子 \\
    :factor-rule & factoring & 適用された節の識別子 \\
    :factor-simp-rule & factor simplificatoin & 空 \\
    :demod-rule & demodulation & 適用された全ての demodulator\\
    && の節識別子 \\
    :back-demod-rule & back demod. & demodulator と, 適用された節
    \\ && の識別子 \\
    :unit-del-rule & unit-deletion & 適用された全ての \\
    && unit clause の識別子 \\
    :copy-rule & copy & コピーの元になった節の識別子 \\
    :flip-rule & flip\footnote{等式の左右辺の入れ換え} & nil \\
    :back-unit-del-rule & back unit deletion & nil \\ \hline
  \end{tabular}
  \end{center}
  }
\item[literals] 節に含まれるリテラルのリスト. 

\item[id] 節識別子(正の整数). 各節毎にユニークな値が設定される.

\item[pick-weight] 節の重み. sos から次に導出対象となる節を選出する際に
  用いられる. 節の重みとは, 節に含まれる各リテラルの重みを合計したもの
  であり, リテラルの重みとは, リテラルのアトム(atom スロットに格納されて
  いる項) に含まれる, 全ての演算子と変数の数を合計したものである.

\item[attributes] 雑多な情報を association list の形式で格納する.

\item[axiom] CafeOBJ モジュールで宣言されている公理を変換して生成された
  節の場合, この公理が格納される. 推論中に導出された節の場合は
  \verb|nil| となる.

\item[container] 節が所属する節集合を示すキーワードシンボル. 以下のもの
  がある：
  \begin{center}
    \begin{tabular}{|l|l|}\hline
      キーワード & 意味 \\\hline
    \verb|nil| & どの節集合にも所属していない \\
    \verb|:sos| &  sos に所属している \\
    \verb|:usable| & usable に所属している \\\hline
    \end{tabular}
  \end{center}
\end{description}

\paragraph{節の印字表現}

節の印字表現は, 利用者に対するさまざまな情報を与える上で重要である.
節の印字表現は次のように定める：
\begin{verbatim}
  <節識別子> [<節の導出情報>] <リテラルのリスト>
\end{verbatim}
\begin{itemize}
\item \verb|<節識別子>| : id スロットに格納されている節識別子の値.
\item \verb|<節の導出情報>| : parents スロットに格納されている節の導出情報の
  リストを, 導出ルールとそれに関係する節の識別子のリストとともに, 見やすい
  形で整理して印字する.
\item \verb|<リテラルのリスト>| :  literals スロットに含まれるリテラルのアトムを
\begin{verbatim}
  L1 | ... | Ln
\end{verbatim}
  の形式で印字する.
\end{itemize}

\subsection{psystem}
\label{sec:data-psystem}
psystem は, 推論エンジンが使用するデータベースや, 推論エンジンの実行
コンテキストを, 各 CafeOBJ モジュール毎に維持/管理するためのレコード構造
である. psystem は各モジュール毎に一つ用意される.
モジュールから, 対応する psystem をアクセスするため, 
モジュールの内部データ構造のスロット \verb:info: (これは association
list である)に, 
キーワード \verb|:proof-system| によって格納する. 
このため, CafeOBJ インタプリタのモジュールの初期化処理を修正し,
psystem が適切に組み込まれるようにする.

psystem は下に示す構造を持つ.

\begin{center}
\begin{tabular}{|l|l|l|}\hline
  スロット名 & 初期値 & 内容 \\\hline
  module & nil & 対応するモジュール \\
  sos & nil & sos 節集合の内容 \\
  usable & nil & usable 節集合の内容 \\
  axioms & nil & モジュールの公理から得られた節のリスト \\
  demods & nil & モジュールの公理から得られたdemodulator のリスト \\
  clause-hash & nil & 節識別子から節を得るための hash table \\
  demodulators & nil & 演算子から demodulator を得るための hash
  table\\
  clause-counter & 1 & 節識別子カウンタ \\\hline
\end{tabular}
\end{center}

\begin{description}
\item[module] 対応する CafeOBJ モジュールの内部データ構造を格納する.
  これによって, 当該の psystem がどのモジュールに対応したものであるかを
  知る.
\item[sos] sos に割り振られた節の集合を格納する. 節のリストである.
\item[usable] usable に割り振られた節の集合を格納する. 節のリストである.
\item[axioms] 対応する CafeOBJ モジュールの公理集合を変換して得られた
  節の集合を格納する. 節のリストである.
  ここに含まれる節が, sos あるいは usable に振り分けられてそれらの
  集合の初期の内容となり, 反駁エンジンの入力となる. 
  このことから, ここに含まれる節を\textbf{入力節}と呼ぶ.
  
\item[demods] 対応する CafeOBJ モジュールの公理集合を変換して得られた
  demodulator の集合を格納する. demodulator のリストである.
\item[clause-hash] 節識別子をキーとし, 対応する節を内容とするハッシュ
  テーブル. 
\item[demodulators] 演算子をキーとし, その演算子がトップオペレータとなっ
  ている項に適用可能な demodulator のリストを内容とするハッシュテーブル
  .

\item[clause-counter] 各節にユニークな節識別子を割り振るためのカウンタ
  . 節が生成される毎にこのカウンタに格納されている値が節識別子として
  設定され, 次の生成のために値を1つ増やす.
\end{description}


%%
\subsection{clash}
\label{sec:data-clash}

clash は (negative) hyper resolution の際の, unify 可能な節集合を探索
するために用いられるレコード構造であり, 下に示す構造を持つ：

\begin{center}
\begin{tabular}{|l|l|l|}\hline
スロット名 & 初期値 & 内容 \\\hline
literal & nil & 核となるリテラル \\
db      & nil & unify 対象のリテラルを探索する対象となる\\
        &     & データベース \\
subst   & nil & unify で得られた変数置換 \\
clashables & nil & unify 検査の対象となり得るリテラルのリスト \\
found-lit & nil & unify 出来たリテラル \\
prev    & nil & 先の clash \\
next    & nil & 次の clash \\\hline
\end{tabular}
\end{center}

\subsection{paramod}
\label{sec:data-paramod}

paramod は推論規則 paramodulation into (from) の際の paramodulator
を表現するためのレコード構造であり, 下に示す構造を持つ.

\begin{center}
\begin{tabular}{|l|l|l|}\hline
スロット名 & 初期値 & 内容 \\\hline
lhs & nil & paramodulator の左辺 \\
rhs & nil & paramodulator の右辺 \\
literal & nil & paramodulator の元になったリテラル \\\hline
\end{tabular}
\end{center}

\begin{description}
\item[lhs] paramodulator の左辺となる項を格納する.
\item[rhs] paramodulator の右辺となる項を格納する.
\item[literal] 正の equational literal (\verb|P = Q| の形式のリテラル) が
  paramodulator となるが, 当該の paramodulator の元になったリテラルを格納する.
\end{description}

\subsection{demod}
\label{sec:data-demod}

demod は demodulation で使用される書き換え規則(demodulator) を表現するための
レコード構造である. 下に示す構造を持つ：

\begin{center}
  \begin{tabular}{|l|l|l|}\hline
    スロット名 & 初期値 & 内容 \\\hline
    axiom & nil & 書き換え規則 \\
    order & :normal & 左右辺順序の情報 \\
    clause & nil & もとになった節 \\\hline
  \end{tabular}
\end{center}

\begin{description}
\item[axiom] 左辺→右辺 という書き換え規則は, CafeOBJインタプリタの書き換え
  規則の内部データ構造で表現される. ここには当該の demodulator に対応する
  書き換え規則の内部データ構造が格納される.
\item[order] 書き換え規則の左右辺の順序付けを行った結果の情報が, キーワード
  シンボルで格納される. 以下の種類がある：
  \begin{center}
    \begin{tabular}{|l|l|}\hline
      キーワード & 意味 \\\hline
      \verb|:normal| & 問題無く順序つけが出来た \\
      \verb|:order-dep| & 書き換え結果が, 辞書式順あるいは \\
      & rpo (recursive path ordering) \\
      & による順序付けで, 元の項より小さくなければ,\\
      & 書き換え無効とするべきもの\\ \hline
    \end{tabular}
  \end{center}
  \item demodulator は, 単一リテラル節(unit clause)で, そのリテラルが正の
    equality literal であるような節から生成される. ここには当該の
    demodulator の元になった節が格納される.
\end{description}

\subsection{option-set}
\label{sec:data-option-set}

option-set は, 推論エンジンで使用されるフラグやパラメータの設定を
名前を付けて保存するために使用されるレコード構造であり, 下に示す
構造を持つ.

\begin{center}
\begin{tabular}{|l|l|l|}\hline
スロット名 & 初期値 & 内容 \\ \hline
name & " & option-set の名前 \\
flags & nil & 全フラグの値を格納した配列 \\
parameters & nil & 全パラメータの値を格納した配列 \\\hline
\end{tabular}
\end{center}

\begin{description}
\item[name] option-set の名前を文字列で格納する.
\item[flags] フラグの現在値は大域変数 \verb|*pn-control-flags*| に
  束縛されている配列に格納される. この配列のコピーが格納される.
\item[parameters] パラメータの現在値は大域変数 \verb|*pn-parameters*|
  に束縛されている配列に格納されているが, この配列のコピーが格納される.
\end{description}

%%%%%%%%%%%%%%%%%%%
\section{節形式変換}
\label{sec:clausal-form}

CafeOBJ の項/公理の節形式への変換について，基本仕様と構成仕様を定める．
本章の内容は，第\ref{sec:architecture}章で述べたモジュール
CafeOBJ Axioms-$>$ Clausal Form translation に対応するものである．

\subsection{節形式変換の方法}
\label{sec:clausal-form-howto}

反駁エンジンの採用する証明方法は導出原理(resolution principle)を
用いるものであるため, 全ての FOPL 文の集合を\textbf{節形式}(clausal
form)の集合へ変換して扱う必要がある. このための変換は通常行われる
標準形変形の手順を用いる. すなわち, まず以下の手順に従って
連言標準形($ C_1 \land \cdots \land C_n$ の形をした文であり, 各 $C_1$ は
アトムあるいは, アトムが $\lor$ で結合された形 -- $A_1\lor\cdots A_n$)
へ変換する.

\begin{description}
\item[ステップ1] 含意記号 $\rightarrow$ の消去. \\
  論理式中の論理記号は $\land$, $\lor$, 〜, = のみになるようにする.

\item[ステップ2] 否定記号 〜 の位置がえ. \\
  否定記号は基本論理式のみに付くようにする. つまり, 限量子の
  内側へ移動させる.

\item[ステップ3] 変数の標準化.
  閉論理式中の束縛変数をすべて異なったものにする.

\item[ステップ4] 存在限定子 $\exists$ の除去. \\
  Skolem 関数を導入して除去する.

\item[ステップ5] 連言標準形に直す.

\end{description}

このようにして得られた論理式は
\[\forall x_1\forall x_2\cdots\forall x_n[ c_1\land c_2\cdots\land c_n] \]
という形をした閉論理式になっている. 
ここで, 各 $c_i$ は, 原始論理式, あるいは
\[p_1\lor\cdots\lor p_n\]
の形の論理式である. したがって, ここから直ちに, 元の論理式に対応する節のリスト
\[ (c_1, c_2, \cdots , c_n) \]
を得る事が出来る.

以下で仕様を定める節形式変換モジュールは, 基本的にこの手順に
したがって, FOPL 文を節形式に変換し, 節の内部データ構造
(clause 第 \ref{sec:data-clause} 節を参照) を生成するものである.

\subsection{節形式変換モジュール}
\label{sec:clausal-trans}

本節では, CafeOBj 項で表現された FOPL 文を節形式へ変換するための
プログラムモジュールの仕様を定める.



以下で説明するルーチン群は, 全てあるモジュール文脈のもとで
動作する. 
すなわち, 対象とする CafeOBJ モジュールが定められ, その文脈の
もとで処理を行う. 
多くの処理では, 文脈は引数として psystem データ構造
(第 ~\ref{sec:data-psystem} 節を参照) を取ることによって得る.
(psystem の module スロットを参照することにより, 文脈モジュール
を知ることが出来る). 

\subsubsection{主処理: formula→clause-1}
\label{sec:formula->clause-1}

formula\verb:->:clause-1 は, 節形式変換の主関数である. 

\begin{description}
\item[入力] \verb|sentence psys &optional axiom|\hfill
  \begin{itemize}
  \item sentence : CafeOBJ 項(FOPL文)
  \item psys     : 文脈となる psystem
  \item axiom    : 対応する公理．sentence が ax あるいは，goal 宣言に
                   よるものである場合，その公理を与える．
  \end{itemize}
\item[出力]\hfill
  \begin{itemize}
    \item sentence は破壊的に変更される.
    \item 戻り値として, 入力 sentence を変換して得られた節の
      リストを返す.
  \end{itemize}
\item[処理]\hfill
  \begin{enumerate}
  \item sentence を conjunctive normal form (連言標準形) へ
    変換する. この処理は, 連言標準形変換を行う cnf(第\ref{sec:cnf}節を参照)
    によって実行する.

  \item 連言標準形に変換された sentence から節のリストを得る.
    この処理は, cnf-to-list(第\ref{sec:cnf-to-list}節を参照)によって実行する. 

  \item 得られた節のリストに含まれる各々の節について, 
    変数をユニークなものにする. 

  \item もし, 引数 axiom が与えられていたら, 各節の axiom スロットに
    引数の axiom をセットする.

  \item 得られた節のリストを戻り値として返す.
  \end{enumerate}
\end{description}
  
\subsubsection{連言標準形変換: cnf}
\label{sec:cnf}
cnf は一般の FOPL を連言標準形へ変換する. すなわち,
第~\ref{sec:clausal-form-howto}節で概要を述べた, 標準形変換処理を
実行するものであり, 節形式変換の主要部分の処理を行う.

\begin{description}
\item[入力] \verb|sentence psys|
  \begin{itemize}
    \item sentence : FOPL 文
    \item psys : 実行文脈となる psystem
  \end{itemize}
\item[出力]
  \begin{itemize}
  \item sentence が, 連言標準系に破壊的に変更される.
  \item 連言標準形に変換された sentence を戻り値として返す.
  \end{itemize}
\item[処理]
  \begin{enumerate}
  \item setence に含まれる自由変数を全て全称限定子で束縛する.
  \item 含意(→) と \verb|<->| (同値) を消去し, 〜(否定)を量限定子の内側へ
    移動する.
    \begin{itemize}
      \item 含意は次の変換によって消去する.
\begin{verbatim}
   A -> B    ---> ~ A | B
   ~(A -> B) ---> ~(~A | B)
\end{verbatim}
      \item 同値記号は次の変換によって消去する.
\begin{verbatim}
   A <-> B -----> (~A | B) & (~B | A)
   ~(A <-> B) --> ~(A | B) & (~A | ~B)
\end{verbatim}
      \item 否定記号を内側へ移動する場合, 次の変換規則を用いる：
\begin{verbatim}
   ~ \A[..] P  ---> \E[..] ~P
   ~ \E[..] P  ---> \A[..] ~P
   ~~P         ---> P
   ~(A & B)    ---> ~A | ~B
   ~(A | B)    ---> ~A & ~B
\end{verbatim}
    \end{itemize}
    \item Skolem 関数を導入し, 存在限定子を除去する.
      これは次の手順で行う.
      \begin{enumerate}
      \item $M[x_1,\cdots,x_n]$ を変数 $x_1,\cdots , x_n$ をパラメータ
        とする任意の論理式とする.
      \item $Q_1,\cdots, Q_i$ を \verb:\A: または \verb:\E: としたとき,
        \[ Q_1[x_1]\cdots Q_n[x_n]M[x1,\cdots,x_n] \]
        で, $Q_i$ が存在記号 \verb:\E: であれば, $i$ より左側にある
        (小さい) $Q_j(i < j)$ で, $Q_j$ が存在記号\verb:\A: である変数の
        全てを $x_i1, \cdots , x_ik$ とするとき,
        新たな関数記号 $f_i$ を導入し, 
        \[x_i = f_i(xi1,\cdots, xik)\]
        として, M に現れる $x_i$ を全て $f_i$ で置き換える. 
      \item $Q_i[x_i]$ を取り除く. 
      \item 以上の処理を, 全ての $i = 1,\cdots, n$ に対して順序行う.
      \item 但し, $Q_i$ の左に全称記号が一つも存在しない場合は, 
        関数 $f_i(...)$ の代わりに定数 $c_i$ を導入する.
      \end{enumerate}
    \item sentence に含まれる全ての変数項をユニークな名前にする.
    \item sentence から全称記号を除去する(単に取り去る).
    \item 連言標準系へ変換する. これには次の分配側を用いる.
\begin{verbatim}
   A | (B & C) ----> (A | B) & (A | C)
\end{verbatim}
      また, 変換に際しては, フラグ simplify-fol が on であった
      場合, 次のような論理式の簡単化を行う.
\begin{verbatim}
   A | ~A | B             --> B
   (A | B) & (A | B | C)  --> A | B
   (A  & B) | (A & B & C) --> A & B
\end{verbatim}
    \item 変換された sentence を戻り値として返す.
  \end{enumerate}

\end{description}

\subsubsection{節リストの作成: cnf-to-list}
\label{sec:cnf-to-list}

cnf によって連言標準形に変換された FOPL 文を
節形式に変換した節のリストへ変換するのが cnf-to-list である.

\begin{description}
\item[入力] \verb|sentence psystem|
  \begin{itemize}
    \item sentence : FOPL 文. 連言標準形でなければならない.
    \item psys     : 実行文脈となる psystem.
  \end{itemize}
\item[出力]
  \begin{itemize} 
  \item 節のリスト
  \end{itemize}
\item[処理]
  \begin{enumerate}
  \item sentence が $P_1 \& \cdots \& P_n$ の形の項であった場合,
    それぞれの $P_i$ を節に変換し, リストとして返す.
  \item そうでなければ, sentence を節に変換し, それを1要素の
    リストとして返す.
  \end{enumerate}
  このとき、項から節への変換は, 次の手順による：
  \begin{enumerate}
    \item 節に含まれるリテラルを作成する.
      \begin{enumerate}
      \item sentence が論理和($P_1 | \cdots | P_n$ の形の項)ならば,
        それぞれの $P_i$ からリテラルを作成し, 作成する節のリテラルの
        リストとする.
      \item そうで無ければ, sentence からリテラルを作成し, 
        作成する項の(唯一の)リテラルする.
      \end{enumerate}
    \item 新たな節に含まれるリテラルとして, 上で作ったリテラルの
      リストを設定する.
  \end{enumerate}
  また, リテラルを作成する際には, sentence のタイプによって,
  リテラル(literal -- 第 ~\ref{sec:data-literal} 節を参照) のタイプ,
  (type スロットの値)と, 正負(sign スロットの値)を適切に設定する.

\end{description}

\subsection{CafeOBJ 公理の節形式への変換}
\label{sec:cafeobj-clause-form}
推論に先だって, 処理文脈となるモジュールに含まれる公理を節形式に
変換したり, demodulator として使用できる公理を識別し, 後の処理の
ために用意して置く必要がある. 本節では
本節では, これらの処理についての仕様を定める.

\subsubsection{moduleの公理から節へ：module-axioms→clause}
\label{sec:module-axioms->clause}

モジュールの全ての公理を走査し, 適切な公理ならば節へ変換する
関数である. 
組み込みの等式(右辺が Lisp 関数で定義されている等式) のうち, 
条件付きで無い物は demodulator として用いる(第 ~\ref{sec:embedding}
節) ので, この条件を満足する節についても判別する．
このような組み込みの等式から変換され，demodulator として使われる
ような節を built-in demodulator と呼ぶ．

変換結果は, 引数として与えられる psystem にセットされる.
すなわち, 推論に使用できる節は, psystemの axiom スロットに,
また, demods スロットに built-in demodulatorとして使用出来る
節のリストがセットされる. 

ここで axioms に格納された節のリストは，後に sos と usable に
振り分けられ，反駁エンジンに対する入力節となる．

\begin{description}
\item[入力] psyste
  \begin{itemize}
  \item 処理文脈とする psystem
  \end{itemize}
\item[出力]
  psystem の以下のスロットがセットされる：
  \begin{itemize}
  \item axioms : 公理から変換されて得られた節のリスト
  \item demods : 変換された節のうち, built-in demodulator として用いられる
    節のリスト
  \end{itemize}
\item[処理]
  モジュールに含まれる全ての公理に付いて, 以下の処理を行う：
  \begin{enumerate}
  \item 以下のタイプの公理は変換の対象とはせずに捨てる.
    \begin{itemize}
      \item Bool ソートに関する公理：
      捨てられるのは以下の CafeOBJ Bool 演算に関する公理である      
      \begin{verbatim}
      true, false, _and_, _or_, _xor_, not_, _implies_,
      _and-also_, _or-else_
      \end{verbatim}
      これらの演算子は，FOPL レベルでは真偽値あるいは，
      論理演算子として解釈され，
      対応する FOPL 文の論理演算子に変換されるからである
      (第\ref{sec:embedding}節の，「CafeOBJモジュールの解釈」の
      項を参照).

      \item 等式, あるいは, ax (goal) 宣言で定義された
        FOPL 文による公理ではないもの. すなわち, 遷移規則の
        公理は捨てる．
    \end{itemize}
    これ以外の公理に関して, 以下の処理を実行する.
  \item 公理の左右辺/条件部を FOPL 文へ変換する. 
    これは次の手順に従う：
    \begin{enumerate}
    \item 公理の左辺側の CafeOBj 項を FOPL 文へ変換し,
      これを lhs とする.
    \item 右辺の変換
      \begin{itemize}
      \item 公理が(ax や goal宣言では無い) 通常の CafeOBJのの等式ならば, 
      公理の右辺側の CafeOBJ 項を FOPL 文へ変換し, rhs とする. 
      \item 変換された右辺が Bool の定数 \verb|true| だった場合, 
        `rhs 無し' とする. 
      \item これが Bool 定数 \verb|false| だった場合は, 
        FOPL 文の否定を取り(\verb|~ RHS| -- RHS は変換された右辺), 
        これを rhs とする.
      \item 変換しなかった場合は, `rhs 無し'とする.
      \end{itemize}
    \item 条件部の変換\\
      公理に条件部が含まれている場合, この項も FOPL 文へ変換し,
      これを cond とする. 無ければ `cond 無し'とする.
    \end{enumerate}
  \item 公理に対応したFOPL 文の作成
    \begin{itemize}
    \item rhs (変換された右辺) ありの場合
      \begin{itemize}
      \item cond がある場合
\begin{verbatim}
  cond -> lhs = rhs
\end{verbatim}
        という形の FOPL 文を作る
      \item cond が無い場合は
\begin{verbatim}
  lhs = rhs
\end{verbatim}
        という形の FOPL 文を作る
      \end{itemize}
    \item rhs 無しの場合
      \begin{itemize}
      \item cond ありの場合
\begin{verbatim}
  cond -> lhs
\end{verbatim}
        という形の FOPL 文を作る
      \item cond 無しの場合は lhs を変換結果とする.
      \end{itemize}
    \end{itemize}

  \item 公理から変換された FOPL 文を節形式のリストへ変換する. この処理は
    第 ~\ref{sec:formula->clause-1} 節で述べた, formula\verb:->:clause-1
    によって実行する. 
  \item 変換で得られた各節に関して推論に使用可能な節ならば, 引数の
    psystem の axioms スロットに登録する. また, built-in demodulator として
    使用出来る節ならば, demods スロットに登録する.
    
    推論に使用できる節の条件は次の通り.
    \begin{itemize}
      \item 正の equality literal 一つのみからなる節の場合, 
        等式の右辺が組み込みの Lisp 関数ならば NG, そうで無ければ OK
      \item その他の節は, 無条件に OK
    \end{itemize}

    また, built-in demodulator として使用できる節の条件は次の通り：
    \begin{itemize}
      \item equality literal 一つのみからなる節で, 等式の右辺が
        Lisp 関数で定義されているもの. 
    \end{itemize}
  \end{enumerate}
\end{description}

上の処理で, CafeOBJ 項を FOPL 文へ変換する手続きは以下に示す通りである.
この処理では, CafeOBJ の組み込み述語を FOPL の論理結合子へ変換すること,
また, \verb|if_then_else| 等の使用できない演算子を含む項に関しては,
警告メッセージを出す等の処理を行う(変換は実行する). 

\paragraph{CafeOBJ 項から FOPL 文への変換手続き}
\begin{enumerate}
\item 項が演算子の適用フォームなら以下の処理を実行する：
  \begin{enumerate}
  \item この処理を全ての副項に再帰的に適用し, 副項を FOPL 文へ変換する.
  \item この項の演算子が組み込みの Bool ソートの演算子ならば以下の
    変換を行う. ここで, A, B 等は項である.
\begin{verbatim}
  A and B          ---->  A & B
  A or B           ---->  A | B
  not A            ---->  ~ A
  A implies B      ---->  A -> B
  A and-also B     ---->  A & B
  A or-else B      ---->  A | B
  A == B           ---->  A = B
  A =/= B          ---->  ~(A = B)
  A =b= B          ---->  A = B
  A xor B          ---->  (~ A | ~B) & (A | B)
\end{verbatim}
  \item この項が \verb|if_then_else|, \verb|_=*=_| あるいは 
    \verb|_:<SortId>| (メンバーシップ述語)の項ならば,
    使用できない旨の警告メッセージを発する. 項は変換せずに
    そのままとする.
  \end{enumerate}
\item その他の項に関しては変換せずにそのままとする.
\end{enumerate}

%%%%%%%%%%%%%
\section{フラグとパラメータ}
\label{sec:flags-and-parameters}
フラグとパラメータは推論エンジンの実行を制御するスイッチや
さまざまな制約条件を指定するためのものであり，利用者が
コマンドで値を設定する．

本章の内容は，第\ref{sec:architecture}章で述べた，モジュール
Setting options に対応するものである．

\subsection{フラグ}
\label{sec:option-flags}

フラグは on または off の値を持つスイッチであり，
推論プロセスで使用する推論ルールや，さまざまな動作の切替え制御
等を行うためのものである．
利用者は, 新規のコマンド "flag" (第\ref{sec:new-commands}章を参照)
によって以下で定めるフラグの値を設定する．

本章ではこのフラグについて個々の仕様を定める.

\subsubsection{フラグ値の格納と設定}
\label{sec:setting-flags}

全てのフラグに関する情報は大域変数 *pn-control-flags* に
束縛される表に格納するものとする.
この表には以下の情報を格納する：
\begin{itemize}
  \item フラグ名 \\
    flag コマンドの引数として与えられるフラグ名.
    表示にも使用する.
  \item 現在値 \\
    当該フラグの現在値を納める. 定数 \verb|t| で フラグが on で
    あることを, \verb|nil| で off であることを意味するものとする.
\end{itemize}

\subsubsection{フラグの一覧}
\label{sec:all-flags}

ここでは, 全フラグの名前とその概要を示す. 
個々のフラグが処理に対してどのような影響を与えるのかは,
後述する推論プロセスに含まれる個々の処理の仕様の説明で与える.

\begin{description}
\item[auto] 初期値 off. on の時, オートモードによる自動推論を行うことを指定する.
\item[back-demod] 初期値 off. on の時, back demodulation を行うことを指定する.
\item[back-sub] 初期値 on. 生成された導出節に関して back subsumption テストを
  実行することを指定する.
\item[back-unit-deletion] 初期値 off. on の時, 生成された導出節に関して 
  back unit deletion テストを実行する事を指定する.
\item[binary-res] 初期値 off. on の時, 推論規則として binary resolution
  を使用することを指定する.
\item[control-memory] 初期値 off. sos のサイズがパラメータ max-sos の
  値を越えた場合の自動 max-weight 再設定を有効にする.
\item[discard-non-oriented-eq] 初期値 off. on の時, 導出節が equality 
  literal の場合に行われる等式の左右辺の順序付けで, 順序つけが出来な
  かったものは捨てる.
\item[dynamic-demod] 初期値 off. on の時, 導出節が単一節で, 正の 
  equality リテラルのみを含む場合, それらを新たな demodulator として
  以降で使用する. 左右辺の順序つけが出来ない場合は demodulator にしない.
\item[dynamic-demod-all] 初期値 off. on の時, 導出節が単一節で, 正の 
  equality リテラルのみを含む場合, それらを新たな demodulator として
  以降で使用する. 左右辺の順序つけが出来ない場合も :order-dep の
  demodulator として使用する. 
\item[eq-units-both-ways] 初期値 off. on の時, 導出節が単一節で, 
  正負を問わず equality リテラル飲みを含む場合, 等式を左右両方向に使う
  ことを指定する. もし フラグ order-eq が off の場合は無条件に両方向に
  使うが, order-eq が on の場合は, そのリテラルが方向つけ出来なかった
  場合にのみ, 両方向に用いる.
\item[factor] 初期値 off. on の時, 導出節に対して factoring を適用する.
\item[for-sub] 初期値 on. on の時, 導出節に対して forward subsuption 
  テストを実行する.
\item[hyper-res] 初期値 off. on の時, 導出ルールとして hyper-resolution
  を用いる事を指定する.
\item[kb] 初期値 off. on の時, 推論プロセスの動作が Kunuth-Bendix 完備化手続き 
  様の動作となる. 
\item[lrpo] 初期値 off. on の時, 等式の左右辺の順序付けで, lexicographic
  recursive path ordering を用いる. このフラグが off の場合は辞書式順で
  順序つけの計算を行う.
\item[neg-hyper-res] 初期値 off. on の時, 推論規則として negative hyper
  resolution を用いる. 
\item[order-eq] 初期値 off. on の時, 等式の左右辺の順序つけを行い,
  必要に応じて左辺が右辺より大きくなるように入れ換えを行う.
\item[order-hyper] 初期値 off. (neg-)hyper resolution を行う場合に,
  単一化テストの対象とするリテラルは, それが最大(辞書式順による)のもの
  に限定する.
\item[para-all] 初期値 off. on の時, 置き換えの対象となり得る全ての項が
  置換される.
\item[para-from] 初期値 off. on の時, 推論ルールとして pramodulation from
  を使用する.
\item[para-from-left] 初期値 off. on の時, paramodulator の左辺→右辺
  の形での paramodulation を行う事が許される.
\item[para-from-right] 初期値 off. on の時, paramdulator の右辺→左辺
  の形での paramodulation を行う事が許される.
\item[para-from-units-only] 初期値 off. on の時, paramodulator が単一節
  である時のみ, paramodulation を行う事が許される.
\item[para-from-vars] 初期値 off. on の時, 変数に対する paramodulation を
  行う事が許される.
\item[para-into] 初期値 off. on の時, 推論ルールとして paramodulation into
  を使用する.
\item[para-into-left] 初期値 off. on の時, 等式の左辺に対する paramodulation
  を行う事が許される.
\item[para-into-right] 初期値 off. on の時, 等式の右辺に対する paramodulation
  を行う事が許される.
\item[para-into-units-only] 初期値 off. on の時, 対象節が単一節の場合のみ
  paramodulation を行う事が許される.
\item[print-back-demod] 初期値 on. on の時, 節が back demodulate された際に
  その旨印字する.
\item[print-back-sub] 初期値 on. on の時, 節が back subsume された際に
  その旨印字する.
\item[print-given] 初期値 on. on の時, 新たに選択された given-clause を
  その都度印字する.
\item[print-kept] 初期値 on. on の時, 導出節の内 sos に入れられた節があれば
  その都度その節を印字する.
\item[print-lists-at-end] 初期値 off. on の時 sos や usable の一覧情報を,
  推論プロセスの終了後に印字する.
\item[print-message] 初期値 on. on の時, 推論中のメッセージ出力を行う.
\item[print-new-demod] 初期値 on. on の時, 推論中に新たに生成された demodulator を
  その都度印字する.
\item[print-proofs] 初期値 on. on の時, 推論プロセスで空節が得られた場合に,
  証明木を印字する.
\item[print-stats] 初期値 on. on の時, 推論プロセス終了後に統計情報を
  印字する.
\item[process-input] 初期値 off. on の時, sos および usable の初期集合に
  含まれる個々の節に対して, 導出節に対してなされるのと同様のテストを行う.
\item[quiet] 初期値 off. 推論中に出力されるメッセージの全てを印字しない.
\item[very-verbose] 初期値 off. 推論プロセスのメッセージを詳細に印字する.
\end{description}

\subsection{パラメータ}
\label{sec:option-parameters}

パラメータは正または負の整数値であり, 推論プロセスの動作を制御するものである.
本章では推論プロセスが参照するパラメータについて定める.

\subsubsection{パラメータ情報の格納と設定}
\label{sec:setting-parameters}

パラメータの現在値は, 大域変数 \verb|*pn-parameters*| に格納する
ものとする.
この変数には少なくとも後で示すパラメータの個数分の要素を持った
表を束縛し, 個々の要素には以下の情報を格納するものとする：
\begin{itemize}
  \item パラメータの名前 \\
    param コマンドで引数として使用されるパラメータの名前.
    一覧の表示の際にも使用する.
  \item 最小値 \\
    規定の最小値を納める.
  \item 最大値 \\
    規定の最大値を納める.
  \item 現在値 \\
    パラメータの現在値を納める.
\end{itemize}

パラメータの設定に際しては, 与えられた値が最大/最小値をはみ出す場合
エラーとする. 

\subsubsection{パラメータ一覧}
\label{sec:all-parameters} 

以下で示すパラメータの名前は, 新規の \verb|param| コマンドの引数として使用さる.  
パラメータの有効範囲は [M ... N] という表記で規定する. これは M 以上 N 以下を
意味する. 最小値の規定で most-negative-fixnum となっているのは, Common Lisp 
の仕様で規定されいている最小の整数値, また most-positive-fixnum となっている
のは同じく最大の整数値を意味する.

\begin{description}
\item[change-limit-after] [0 ... most-positive-fixnum] \\
  初期値 は 0 .
  sos から given-clause として取り出された節の数が
  ここで設定された数に到達した時点で, パラメータ max-weight の値を変更する.
  新たに設定される値は, パラメータ new-max-weight の値である.

\item[demod-limit] [-1 ... most-positive-fixnum] \\
  初期値は 1000. 一つのリテラルに対して一度に実行する demodulation での書き換え
  回数の最大値を指定する. 書き換え回数がここで指定された数を越えた時点で,
  そのリテラルの demodulation は中断される. 値が -1 の場合は制限が無い事を
  意味する. 

\item[max-gen] [-1 ... most-positive-fixnum] \\
  初期値は -1 .
  導出で生成された節の数が, このパラメターで指定した値に達した場合,
  推論プロセスを中断する. -1 は制限無しを意味する.

\item[max-given] [-1 ... most-positive-fixnum] \\
  初期値は -1.
  given-clause として sos から取り出された節の数が,
  このパラメータで指定した値に達した場合, 推論プロセスを中断する.
  -1 は無制限を意味する.

\item[max-kept] [-1 ... most-positive-fixnum] \\
  初期値は -1. 
  新たに導出された節のうち sos に以降の given-clause 候補として入れられた
  ものの個数が, このパラメータで指定した値に達した場合,
  推論プロセスを中断する. -1 は無制限を意味する.

\item[max-proofs] [-1 ... most-positive-fixnum] \\
  初期値は 1.
  一度の推論プロセスで得られた空節の数が, このパラメータで指定された
  数に達した場合に推論プロセスを中断する.
  -1 は無制限を意味する.

\item[max-sos] [-1 ... most-positive-fixnum] \\
  初期値は -1.
  sos に格納されている節の数がこのパラメータで指定されている数を越えた
  場合に, max-weight パラメータの自動再設定を実行する.
  -1 は無制限を意味する.

\item[max-weight] [-1 ... most-positive-fixnum] \\
  初期値は most-positive-fixnum. 
  生成された導出節の重みがこのパラメータで指定された値を越えた場合は,
  その節を捨てる. -1 は無制限を意味する.

\item[pick-given-ratio] [-1 ... most-positive-fixnum] \\
  初期値は -1. 
  sos から節を重みで選ぶ場合, ここで指定された数の節おきに,
  重みでは無くリストの先頭にある節を given-clause として選ぶ.
  -1 は指定無しを意味する.

\item[stats-level] [0 ... 4] \\
  初期値は 2.
  推論プロセスの最後に印字される統計情報の詳細度を指定する.

\end{description}


\subsection{フラグ/パラメータの依存関係}
\label{sec:dep-flags}
前の節で掲げたフラグには依存関係を持つものがある. 
すなわち, あるフラグが on になった場合, それに応じて on または
off に自動設定されなければならないフラグが存在する. 
また, パラメータも自動的に設定される場合も存在する.
ここでは, このような依存関係について規定する.

\begin{description}
\item[auto] on となった場合, 他のフラグは以下のように
  自動設定されなければならない：
  \begin{itemize}
  \item process-input → on
  \item print-kept → off
  \item print-new-demod → off
  \item print-back-demod → off
  \item print-back-sub → off
  \item control-memory → on
  \end{itemize}
  また, 以下に示すようにパラメータを自動設定する：
  \begin{itemize}
  \item max-sos → 500
  \item pick-given-ratio → 4
  \item stats-level → 2
  \end{itemize}
\item[kb] kb が on となった場合, 他のフラグは以下のように
  自動設定されなければならない：
  \begin{itemize}
  \item para-from → on
  \item para-into → on
  \item para-from-left → on
  \item para-from-right → off
  \item para-into-left → on
  \item para-into-right → off
  \item para-from-vars → on
  \item eq-units-both-ways → on
  \item process-input → on
  \item lrpo → on
  \end{itemize}
\item[back-demod] on となった場合, 他のフラグは以下のように
  自動設定されなければならない：
  \begin{itemize}
  \item dynamic-demod → on
  \end{itemize}
\item[dynamic-demod-all] on となった場合, 他のフラグは以下のように
  自動設定されなければならない：
  \begin{itemize}
  \item dynamic-demod → on
  \end{itemize}
\item[dynamic-demod] on となった場合, 他のフラグは以下のように
  自動設定されなければならない：
  \begin{itemize}
  \item order-eq → on
  \end{itemize}
\item[binary-res] on となった場合, 他のフラグは以下のように
  自動設定されなければならない：
  \begin{itemize}
  \item factor → on
  \item unit-deletion → on
  \end{itemize}
\item[very-verbose] on となった場合, 他のフラグは以下のように
  自動設定されなければならない：
  \begin{itemize}
  \item print-kept → on
  \item print-new-demod → on
  \item trace-demod → on
  \end{itemize}
\item[propositional] on となった場合, 他のフラグは以下のように
  自動設定されなければならない：
  \begin{itemize}
  \item sort-literals → on
  \item process-input → on
  \end{itemize}
\item[quiet] on となった場合, 他のフラグは以下のように
  自動設定されなければならない：
  \begin{itemize}
  \item print-message → off
  \item print-kept → off
  \item print-given → off
  \item print-new-demod → off
  \item print-stats → off
  \item print-lists-at-end → off
  \item very-verbose → off
  \end{itemize}
\end{description}

\section{反駁エンジン}
\label{sec:refutation-engine}

本節では，反駁システムの推論実行本体モジュールである反駁エンジン
(第\ref{sec:architecture}章で述べたモジュール Refutation Engine),
および推論ルール群(モジュール Inference rules)，また，統計情報や
証明木等の表示(モジュール Printing/messaging utilities) について，
その仕様を定める．

\subsection{推論プロセスの概要}
\label{sec:infer-process}

\subsubsection{証明戦略 -- SOS}
\label{sec:sos-strategy}

反駁エンジン では証明の基本戦略として，\textbf{SOS}(Set Of Support) 方式
を採用する． 
この戦略の考え方は以下に述べる通りである．

反駁エンジンの目的は，定理
\[ A_1,A_2,\ldots,A_n \rightarrow B\]
を証明することである．ここで $A_1,\ldots A_n$ は公理，$B$ は結論である．
これを証明するため反駁法を用い，
\[A_1\land A_2\cdots\land A_n\land 〜B\]
が充足不可能である事を示すのが反駁エンジンの基本動作である．
この際に resolution 原理に基づいて節を導出し，空節が得られれば反駁された
と判定される．
このとき，
通常公理として与えられる $A_1,A_2\ldots, A_n$ は充足可能と考えられるので
$A_1,A_2,\ldots, A_n$ の間で，節の導出を行うのを避けるのが賢い．

節の集合 $S$ の部分集合 $T$ は $S - T$ が充足可能である時に，
$S$ の \textit{set of support} と呼ばれる．
set-of-support 導出とは，どちらかの節が $T$ に属するような2つの節からの
導出を言う．また，全ての導出が set of support 導出であるような演繹は，
set-of-support 演繹と呼ばれる．

SOS 戦略に関しては次の定理が成り立つ\cite{chang-lee}:
\begin{quotation}
 $S$ を有限の充足不能であるような節の集合とし，$T$ を $S$ の部分集合
 とする．もし $S - T$ が充足可能とすると，$T$ を set of support として
 $S$ から空節を導出するような set-of-support 演繹が存在する．
\end{quotation}

推論エンジンでは節の集合を下のような 
\textbf{usable} と \textbf{sos} と呼ばれる2つ
に分け，導出節の生成を sos から取り出した節と usable に含まれる節との間
でのみ行うようにする．sos が上の説明の節集合 $T$ (set of support) に
対応する．
\begin{center}
  \begin{tabular}{|lcl|}\hline
    usable &:& 推論(resolution)を行う際に使用される節の集合．\\
    sos    &:& 推論には使用されない節の集合．\\\hline
  \end{tabular}
\end{center}
利用者は節の集合を sos と usable のどちらかに振り分ける必要がある．
自動モード(後述)では，入力節のうち，正の節(正のリテラルのみからなる節)を 
sos へ入れ，それ以外の節(少なくとも一つの負のリテラルを含む節) は
usable へ入れるように設定されている．

\paragraph{SOS 方式による導出の例}
以下の節の集合を考える．
$$
\begin{array}{ll}
(1) & P(g(x_1,y_1),x_i,y_1) \\
(2) & 〜P(x_2,h(x_2,y_2),y_2) \\
(3) & 〜P(x_3,y_2,u_3)\lor P(y_3,z_3,v_3)\lor 〜P(x_3,v_3,w_3) \lor
    P(u_3,z_3,w_3) \\
(4) & 〜P(k(x_4),x_4,k(x_4)).
\end{array}
$$
sos $= \{(4)\}$ とする．従って usable $= \{(1),(2),(3)\}$ である．
このとき以下に示す演繹は
sos を set of support とする set-of-support 演繹である：

$$
\begin{array}{lll}
(5) 〜P(x_3,y_3,k(z_3))\lor P(y_3,z_3,v_3)\lor 〜P(x_3,v_3,k(z_3))
    & (4) と (3) \\
(6) 〜P(x_3,y_3,k(h(y_e,v_3))\lor 〜P(x_3,v_3,k(h(y_3,v_3)))
    & (5) と (2) \\
(7) □ & (6) と (1)
\end{array}
$$

\subsubsection{推論プロセスの主ループ}

前節で反駁エンジンは sos 戦略で推論を行うことを述べたが，
この方式による推論プロセスの主ループの概要は次のようになる：

\begin{verbatim}
  while (sos が空でなく，また反駁が見付からない)
    (1) sos から`節を一つ選'び，これを given-clause と呼ぶ
    (2) given-clause を sos から usable に 移す
    (3) `現在有効な推論ルール群'を用いて導出節を生成する
        新たに生成される節は，given-clause を一方の親として持ち，
        他の親は usable に含まれる節である．
    (4) 新たに生成された節に対して，`有用性の検査'を行う．
        これをパスした節は sos へ加え，そうでない節は
        捨てる．
   end 
\end{verbatim}
まず sos から節を一つ取り出して usable へ入れる．取り出した節と他の
usable 内の節との間で，導出節を計算する．したがって全ての導出節は必ず親
に sos から取り出した節を持っていることになる．導出された節が後の推論プ
ロセスで有用なもの(この判定基準については後述する)ならば，それは sos へ
入れられる．これを sos が空になるか，反駁が得られる(空節が導出される)ま
で繰り返す．

上で述べた推論プロセスのループでは, 次のような冗長性が避けられている：
例えば, 節 $C$ が 節 $A$ と $B$ から導出することが出来, また $A$ と $B$ の両方が
sos に含まれているもの仮定する. もし $A$ が given clause として選択されると,
上の処理概要で述べた通り, これは usable へ移されて, 推論が実行される. しかし,
$A$ と $B$ とで $C$ を導出することは\textbf{ない}. なぜなら, $B$ は未だ sos
にあるからである. $C$ の導出には, $B$ が given clause として選ばれるまで
待たねばならない. さもなければ, $C$ が2度導出されることになってしまうからである.

\begin{description}
\item[sos から `節を一つ選' ぶ方法] 利用者がフラグによって設定する．
  反駁エンジンには推論プロセスの動作を制御するために，さまざまなフラグが用意さ
  れており， given-clause の選択方法もその一つであり，下の2つフラグが対応
  する: 
  \begin{center}
    \begin{tabular}{|lcl|}\hline
      sos-queue  &:&  sos を先入れ先出し構造(queue)と見て節の選択を行う\\
      sos-stack  &:&  sos を先入れ後出し構造(stack)と見て節の選択を行う\\\hline
    \end{tabular}
  \end{center}

  sos-queue の場合は幅優先の探索, sos-stack の場合は深さ優先の探索に
  相当する. 
  これらのいずれのフラグも off の場合は，`最も軽い節' を選択する．節の重みとは 
  全てのリテラルに含まれる演算子や変数の数を合計したものである．初期にはこ
  れらのフラグはどちらも off に設定されており，したがって節の重みによって
  given-clause が選択される．

  重みによって given-clause の選択をする場合,
  実際にはもう少し細かな制御がなされる. すなわち, pick-given-ratio という
  パラメータが存在し, これに正の整数値 $n$ が設定されていた場合は, 
  sos からの取り出し $n$ 回目毎(最初を含む)に, 重さを無視して, 
  sos の先頭から節を取り出す.  これを行わないと, いつまでたっても,
  初期の sos に格納されていた節からの導出節が生成されない, という事態に
  陥る可能性があるからである. 

\item [`現在有効な推論ルール群'] 前節で述べた通り，反駁エンジンには
  複数の推論ルールが用意されており，利用者がフラグによって使用したい推論
  ルールを設定する．これには以下の種類がある:

  \begin{center}
    \begin{tabular}{|lcl|}\hline
      フラグ名      &:& 推論ルール \\\hline
      auto          &:& 自動モード\\
      binary-res    &:& binary resolution \\
      hyper-res     &:& hyper resolution \\
      neg-hyper-res &:& negative hyper resolution \\
      para-into     &:& paramodulation into \\
      para-from     &:& paramodulation from \\\hline
    \end{tabular}
  \end{center}
  これらのフラグの初期値は全て off であり，したがって推論ルールは選択され
  ていない．複数のルールを同時に使用する事が可能である．自動モードでは，
  入力節の集合に対して，簡単な構文的検査を行い，適当な推論ルールのセットを
  選択する(第\ref{sec:auto-mode}節を参照). 

\item[導出節の処理] 導出節に対しては, 以下で示す処理が施される.
  上の概要で示した `有用性のテスト' はこれに含まれるものである.
  下で, ステップの番号に * 印のついているものはオプションであり,
  フラグの値に依存して実行するか否かが決定される.
  \begin{enumerate}
  \item[1] 変数をユニークなものにつけ替える
  \item[*2] 導出節を印字する
  \item[3] demodulation を施す
  \item[*4] 等式の向き付けを行う
  \item[*5] unit deletion を施す
  \item[6] 同一のリテラルをマージする
  \item[*7] factor-simplification を施す
  \item[8] tautology だった場合は捨てて, 処理を終る
  \item[*9] 節が重すぎる場合は捨てて, 処理を終る
  \item[*10] リテラルをソートする
  \item[11] usable あるいは sos に含まれる節によって subsume される
    場合は捨てて, 処理を終る(forward subsumption).
  \item[12] 索引テーブルに登録し sos に追加する
  \item[*13] 追加された節を印字する
  \item[14] リテラルを一個も含まない節であれば, 反駁が発見された.
  \item[15] 一個のリテラルを含む節(単一節)である場合は,
    usable と sos に含まれる節との間で, それと反駁するような節を探す
    (unit conflict). 
  \item[*16] 反駁が発見されたならば, 証明木を印字する.
  \item[*17] demodulator として使えるかどうかを調べる.
  \end{enumerate}

  以上の処理は, 推論ルールによって導出された全ての導出節に対して
  施され, それが終ったあとで, あらためて捨てられずに残った
  全ての導出節に対して以下の処理が施される：
  \begin{enumerate}
  \item[*18] 上のステップ17で, 新たな demodulator が生成されていたならば,
    それらを使用して back demodulation を行う
  \item[*19] usable あるいは sos に含まれる項で, 導出節によって subsume 
    されるような節は削除する(back subsumption).
  \item[*20] 導出節の factoring を行い, 個々の factor を処理する.
  \end{enumerate}
  
\end{description}

\subsection{大域データ}
\label{sec:globals}
本章では推論エンジン全体で参照される大域データについて定める.

\subsubsection{FOPL 構文関係の大域変数}
\label{dec:global-fopl-syntax}

FOPL の構文を表現する項に関して, その内部構造を参照し, 
一定の形式の構文か否か等を判定したい場合, 項を構成する演算子が特定の
ものであるかどうか等を調べる必要が生ずる. また, 処理系内部で項を生成
したい場合にも, 特定のソートや演算子の内部構造を直接参照する必要が
ある. ここに示した大域変数はこれら, FOPL 構文に関係する演算子や
ソートの内部データ構造の情報を束縛するものである.

\begin{description}
\item[*fopl-sentence-module*] FOPL の構文を定義したモジュール,
  FOPL-SENTENCE の内部データ構造を束縛する.

\item[*fopl-sentence-sort*] FOPL 文のソート FoplSentece の
  内部データ構造を束縛する.

\item[*var-decl-list-sort*] 全称限定子(for all) や存在限定子(exists) の
  変数束縛指定部分のためのソート VarDeclList の内部データ構造を
  束縛する.

\item[*var-decl-list*] ソート VarDeclList の項の構成オペレータの
  内部データ構造を束縛する.

\item[*fopl-and*] 論理積(\verb:_and_:) オペレータの内部データ構造を束縛する.

\item[*fopl-or*] 論理和(\verb:_or_:) オペレータの内部データ構造を束縛する.

\item[*fopl-imply*] 含意(\verb:_->_:)オペレータの内部データ構造を束縛する.

\item[*fopl-iff*] 同値(\verb:_<->_:)オペレータの内部データ構造を束縛する.

\item[*fopl-neg*] 否定(\verb:~_:) オペレータの内部データ構造を束縛する.

\item[*fopl-forall*] 全称限定子(\verb:\A[_]_:)オペレータの内部データ構造を
  束縛する.

\item[*fopl-exisits*] 存在限定子(\verb:\E[_]_:)オペレータの内部データ構造を
  束縛する.

\item[*fopl-eq*] 等号(\verb:_=_:)オペレータの内部データ構造を束縛する.

\end{description}

\subsubsection{推論プロセス関連の大域変数}
\label{sec:global-inference}

推論プロセスが使用する大域変数とその内容に付いて定める.
これらは, 推論プロセスのトップレベルの実行コンテキストを規定するものである.

\begin{description}
\item[*current-psys*] 現在の推論プロセスの実行コンテキストとなる
  psystem(第 \ref{sec:data-psystem} 節を参照) を束縛する.

\item[*given-clause*] sos 節集合から取り出された, 現在の推論対象とする
  節を束縛する.

\item[*no-db-reset*] 自動モードにおける db reset コマンド(第 \ref{sec:new-commands} 節を参照)の自動実行を制御するためのフラグ. この値が \verb:nil: で無い場合,
  自動実行を行わない.

\item[*clause-hash*] *current-psys* に束縛されている psystem の clause hash
  スロットが束縛される. 

\item[*sos*] *current-psys* に束縛されている psystem の sos スロットが束縛
  される. sos 節集合の現在値となる.

\item[*usable*] *current-psys* に束縛されている psystem の usable スロットが
  束縛される. usable 節集合の現在値となる.

\item[*demdulators*] *current-psys* に束縛されている psystem の demodulators
  スロットが束縛される. demodulator 集合の現在値となる.

\end{description}

\subsection{索引テーブル}
\label{sec:index-tables}

ここでは推論プロセスが使用する索引付きのテーブルの一覧と,
そこへのデータの登録や取り出しに関して述べる.

索引テーブルは, さまざまな推論エンジンが導出節を計算したり,
subsumption のテストをする際に, 与えられた節と unify 可能な節を探索するために
用いる表である.

\subsubsection{索引テーブル一覧}
\label{sec:all-index-tables}

\begin{description}
\item[*pos-literals*] 述語に対応するオペレータの内部構造をキーとし,
  それがトップオペレータとなっているアトムを保持する正のリテラルの
  リストを内容とするハッシュテーブルである. sos および usable に含まれる
  全ての節のリテラルが格納対象となる.

\item[*neg-literals*] 述語に対応するオペレータの内部構造をキーとし,
  それがトップオペレータとなっているアトムを保持する負のリテラルの
  リストを内容とするハッシュテーブルである. sos および usable に含まれる
  全ての節のリテラルが格納対象となる.

\item[*clash-pos-literals*]
  述語に対応するオペレータの内部構造をキーとし,
  それがトップオペレータとなっているアトムを保持する正のリテラルの
  リストを内容とするハッシュテーブルである. usable に含まれる
  全ての節のリテラルのみが格納対象となる.

\item[*clash-neg-literals*] 述語に対応するオペレータの内部構造をキーとし,
  それがトップオペレータとなっているアトムを保持する負のリテラルの
  リストを内容とするハッシュテーブルである. usable に含まれる
  全ての節のリテラルのみが格納対象となる.

\item[*paramod-rules*] 述語に対応するオペレータの内部構造をキーとし,
  それがトップオペレータとなっている左辺を持つ paramodulator (paramod 
  データ構造 -- 第 \ref{sec:data-paramod} 節を参照) のリストを格納する.

\end{description}

\subsubsection{索引テーブルへの登録と削除}
\label{sec:add-to-index-table}

上で述べた索引テーブルへは全ての節の個々のリテラルについて
適当なテーブルへ登録されている必要がある.
また不要のために捨てられる節に関してはテーブルから対応するデータを
削除しなければならない.

\paragraph{登録対称となる節と対応テーブル}

まず, 全ての節に関して
\begin{itemize}
\item 個々のリテラルにつき,
  \begin{itemize}
  \item 正のリテラルならば *pos-literals* へ登録する
  \item さもなければ(負のリテラル), *neg-literals* へ登録する
  \end{itemize}
\end{itemize}

次に, usable 節集合に含まれる節に関して
\begin{itemize}
\item 個々のリテラルにつき,
  \begin{itemize}
  \item 正のリテラルならば *clash-pos-literals* へ登録する
  \item そうでなければ *clash-neg-literals* へ登録する
  \end{itemize}
\end{itemize}

paramodulator に関しては次のようにして 
*paramod-rules* へ登録を行う:
usable 節集合に含まれる節に関して：
\begin{itemize}
\item 個々のリテラルにつき,
  フラグ para-from あるいは para-into が on ならば以下の処理を行う：
  \begin{enumerate}
  \item リテラルが 正の equality リテラル ($A = B$ の形) ならば
    \begin{enumerate}
    \item フラグ para-from-units-only が on であり,
      そのリテラルを含む節が単一節でない場合は登録しない
    \item フラグ para-into-left が on で無い場合は登録しない
    \item それ以外の場合は登録対象とし, 次のようにして登録する
      \begin{itemize}
        \item フラグ para-from-left が on であれば
          $A\rightarrow B$ の形の paramodulator を登録する
        \item フラグ para-from-right が on であれば
          $B\rightarrow A$ の形の paramodulator を登録する
      \end{itemize}
    \end{enumerate}
  \item そうでなければ登録しない
  \end{enumerate}
\end{itemize}

\paragraph{テーブルへの登録と削除のタイミング}

登録/削除のタイミングは以下のような基準で行うものとする.

\begin{itemize}
\item sos から取り出された節 -- given-clause は, 一旦 usable へ登録される. 
  そのタイミングで, 上記の *clash-pos-literals* あるいは *clash-neg-literals* 
  へ登録される. 

\item 推論途中で生成された導出節に関しては前処理 -- pre-process(第 ~\ref{sec:pre-process}
  を参照) が施される. ここで残すべき節であると判定された場合, 
  節に含まれる全リテラルに付いて, 索引テーブルへの登録が行われる. 

\item また, 推論中の subsumption テストなどで, 不要と判定された節に関しては,
  それに含まれる各リテラルを, それが含まれる全ての索引テーブルから削除する必要がある

\item 初期には, sos や usable の初期集合に含まれている各節について行わなければ
  ならないが, これは反駁エンジンの事前初期化処理(第 ~\ref{sec:prepare-inference}
  節を参照)で行われる. 
  この時, 自動モードの場合(フラグ auto が on)や, フラグ process-input が on の場合は
  sos および usable に含まれる全ての節に関して, 推論中に導出された節に対して実行される
  のと同じ前処理(pre-process) が適用されるので, 自動的に索引テーブルへの登録がなされる. 
  そうで無い場合は, 文脈モジュールに対応した psystem に設定されている sos や usable
  の各節について, 個々に索引テーブルへの登録を実行する.
\end{itemize}


\subsection{自動モード}
\label{sec:auto-mode}

本節では自動モードにおけるフラグやパラメータのセッティング, 
sos と usable への節の振り分けに関して定める.

フラグ auto が on の場合, 反駁エンジンは, 入力節 (実行文脈の psystem 
の axioms スロットに含まれる節 -- 後に sos あるいは usable に振り分け
られる) をスキャンし, いくつかの簡単な構文的な性質を調べ, 推論ルールと
探索戦略を自動決定する. 自動モードは探索戦略のための, 組み込みメタ戦略
と見ることが出来る. 
反駁エンジンが選択する探索戦略は(フラグ control-memory を除けば)
通常 refutation complete (反駁可能な節集合であれば, 必ず反駁出来る)である.
しかし, 効率の良い戦略が自動設定されるとは期待すべきではない.
自動モードでは, 多くの簡単な定理の証明が可能である. また, 証明に失敗
するような場合でも, 手動による定理証明の良い出発点を提供する.

フラグ auto は, 他のどのフラグのセッティングよりも先に実行されなければ
ならない. すなわち, コマンド flag(auto,on) は他のフラグのセットコマンド
よりも先にインタプリタに入力されるべきである.
反駁エンジンは, 探索実行前に, 実行文脈となっている psystem の axioms
スロットに格納されている節のうちのいくつかを sos へ振り分け, 残りは 
usable へ振り分ける. 
フラグ auto が on にセットされた時点で, 入力節を走査する前に, 
他の依存するフラグやパラメータが自動設定される(第~\ref{sec:dep-flags} 節
を参照). 

入力節の走査時には, さまざまな構文的な性質を調べ, どの推論ルールや
探索戦略を使うべきかが判定され, またどの節を sos へ入れるかが決定
される. 

入力節の走査時に調べられる構文的な性質は以下のものである：
\begin{enumerate}
\item[(1)] propositional か\\
  つまり, 全ての節が変数を持たない場合.
\item[(2)] Horn 節か\\
  つまり, 全ての節が高々一つの正のリテラルを持つ場合.
\item[(3)] equality があるか\\
  つまり, 少なくとも一つの $A = B$ あるいは $〜(A = B)$ の形の
  リテラルを持つ節がある場合.
\item[(4)] equality axiom があるか\\
  つまり, 少なくとも一つ $A = B \rightarrow B = A$ に相当する
  節がある場合.
\item[(5)] 節に含まれるリテラル個数の最大値
\end{enumerate}
つぎに, これらの性質を組み合わせた簡単な 6 つのケースに分類する
\begin{enumerate}
\item[(1)] propositional
\item[(2)] 全ての節が単一節で equality 
\item[(3--6)] \{equality, Horn\} の4つの組み合わせ
\end{enumerate}


\subsubsection{入力節の構文的性質の調査: clause-set-property}
\label{sec:clause-set-property}

clause-set-property は入力節の構文的性質を調査し結果を返す.

\begin{description}
\item[入力] 無し. 
\item[出力] 5値の多値戻り値
  \begin{description}
  \item[第一戻り値] propositional ならば \verb|t| さもなければ \verb|nil|
  \item[第二戻り値] horn ならば \verb|t| さもなければ \verb|nil|
  \item[第三戻り値] equality ならば \verb|t| さもなければ \verb|nil|
  \item[第四戻り値] symmetry ならば \verb|t| さもなければ \verb|nil|
  \item[第五戻り値] 節に含まれるリテラル数の最大値
  \end{description}
\item[処理]
  \begin{itemize}
  \item propositional は, *usable* にふくまれる全ての節が変数を持たない場合に
    \verb|t| とする
  \item horn は, *usable* に含まれる全ての節が多くとも一つの正のリテラルを
    持つような場合に \verb|t| とする
  \item equality は, *usable* に含まれる節のうち少なくとも一つが
    $A = B$ の形のアトムのリテラルを持つ時に \verb|t| とする.
  \item symmetry は, *usable* に含まれる節のうち少なくとも一つが
    $〜(A = B) | B = A$ という形のものである場合に \verb|t| とする
  \item リテラルの最大数は *usable* に含まれる全ての節について
    含まれるリテラルの個数を調べ, そのうちの最大値とする.
  \end{itemize}
\end{description}

\subsubsection{自動モードセッティング実行: pn-automatic-settings-1}
\label{sec:pn-automatic-settings-1}

pn-automatic-settings-1 は, 上で述べた自動設定処理を実行する.
\begin{description}
\item[入力] 無し
\item[出力] フラグやパラメータが入力節の構文的性質に依存して設定される.
  また sos と usable に入力節が振り分けられる.
\item[処理]
  \begin{enumerate}
  \item 入力節を走査し, 構文的性質を調べる(clause-set-property -- 
    第~\ref{sec:clause-set-property} 節を参照). 
    また, その結果を印字する.
  \item 調べた性質に従って, フラグやパラメータの設定を行う
    \begin{description}
    \item[propositional の場合] \hfill
      \begin{itemize}
      \item フラグ propositional を on に設定する
      \item フラグ hyper-res を on に設定する
      \item 正の節を usable から sos へ移動する
      \end{itemize}

    \item [equality かつ, 最大のリテラル数が 1 の場合]\hfill
      \begin{itemize}
      \item フラグ kb を on にする
      \item 正の節を sos へ入れる
      \item もし usable に含まれる節が全て正の節ならば,
        フラグ print-lists-at-end を on にする
      \item 正の節を usable から sos へ移動する
      \end{itemize}

    \item[horn かつ equality で無い場合]\hfill
      \begin{itemize}
      \item フラグ hyper-res を on にする
      \item フラグ factor を on にする
      \item フラグ unit-deletion を on にする
      \item 正の節を usable から sos へ移動する
      \end{itemize}

    \item[horn ではなく, equality の場合]\hfill
      \begin{itemize}
      \item フラグ kb を on にする
      \item フラグ hyper-res を on にする
      \item フラグ unit-deletion を on にする
      \item フラグ factor を on にする
      \item もし symmetry ならば 
        \begin{itemize}
        \item フラグ para-from を off にする
        \item フラグ para-into を off にする
        \end{itemize}
      \end{itemize}

    \item[horn かつ equality の場合]\hfill
      \begin{itemize}
      \item フラグ kb を on にする
      \item フラグ hyper-res を on にする
      \item フラグ order-hyper を off にする
      \item もし symmetry ならば
        \begin{itemize}
        \item フラグ para-from を off にする
        \item フラグ para-into を off にする
        \end{itemize}
      \end{itemize}
    \end{description}
  \end{enumerate}
\end{description}

\subsection{統計情報}
\label{sec:statistics}
本節では推論プロセス実行中に収集されるさまざまな統計情報について
定める.

\subsubsection{統計情報の格納と設定}
\label{sec:setting-stats}

全ての統計情報は大域変数 *pn-stats* に束縛された表に
一元管理されるものとする.
表の個々の欄に対して一つの統計データが格納されるものとする.
データは全て整数値であり, 初期値は 0 である.

\subsubsection{統計情報一覧}
\label{sec:all-stats}

ここでは, 統計情報として収集すべきデータを規定する. 
以下では, 便宜的に情報に対して適当な名前をつけ,
この名前を対応する統計情報を表すものとして以降で使用する. 
全ての統計情報の初期値は 0 である.

\begin{description}
\item[cl-generated] 推論中に生成された節の合計数. 
\item[cl-kept] 導出節のうち, sos に入れられた節の合計数.
  フラグ process-input が on の場合は, usable や sos の初期集合に
  対して行われる前処理によって, usable あるいは sos に残された節の
  数も含まれる.
\item[cl-for-sub] forward subsume されて捨てられたた節の合計数.
\item[cl-back-sub] back subsume された捨てられた節の合計数.
\item[cl-tautology] tautology と判断されて捨てられた節の合計数.
\item[cl-given] given clause として sos 集合から取り出された節の合計数.
\item[cl-wt-delete] max-weight を越えたために捨てられた節の合計数.
\item[rewrites] demodulation による書き換え回数の総合計.
\item[unit-deletes] unit deletion によって削除されたリテラルの合計数.
\item[empty-clauses] 推論中に導出された空節の合計数.
\item[for-sub-sos] sos に含まれる節によって subsume され, 捨てられた
  節の合計数.
\item[new-demods] 推論中に生成された demodulator の合計数.
\item[cl-back-demod] 推論中に行われた back demodulation の合計数.
\item[sos-size] sos に含まれている節の数.
\item[usable-size] usable に含まれている節の数.
\item[demodulators-size] demodulator の数.
\item[binary-res-gen] binary resolution によって導出された節の合計数.
\item[hyper-res-gen] hyper resolution によって導出された節の合計数.
\item[neg-hyper-res-gen] negative hyper resolution によって導出された
  節の合計数.
\item[para-into-gen] paramodulation into によって導出された節の
  合計数.
\item[para-from-gen] paramodulation from によって導出された節の
  合計数.
\item[demod-inf-gen] demodulation を行った回数.
\item[factor-simplifications] factor simplification を行った回数.
\item[factor-gen] factoring で生成された節の合計数.
\end{description}

\subsubsection{統計情報の印字}
\label{sec:print-stats}

フラグ print-stats の値が on であった場合に,
推論プロセスの終りに, それまで収集された統計情報を印字する.
印字する統計情報の内容は, パラメータ stats-level の値に応じて
内容を替える. 一般に stats-level の値が大きい程, より詳細な
情報を印字するものとし, 以下のように定める：

\begin{itemize}
\item stats-level の値が 0 〜 2 の場合：以下の情報を印字する
  \begin{itemize}
    \item cl-given
    \item cl-generated
    \item cl-kept
    \item cl-for-sub
    \item cl-back-sub
  \end{itemize}
\item stats-level が 3 以上の場合 \\
  全ての統計情報を印字する.
\end{itemize}

\subsection{証明木とその印字}
\label{sec:proof-tree}

節の parents スロットには, その節が導出された際に仕様された推論ルールと
そのルールに関った節の識別子のリストが格納されている(第 ~\ref{sec:data-clause}
節を参照). 従って, 空節が得られた場合に, その parents スロットを参照し, 
空節を導出する過程に関った節を順にたどることによって, 空節の導出過程を
知ることが可能である. 従って, これらの節を識別子番号の順に並べたリストは,
証明木(反駁木)と見る事が出来る. 

\subsubsection{証明木の印字}
\label{sec:print-proof}

print-proof は, 空節の導出過程に出現する節を, 節識別子(番号)の順に
印字する.

\begin{description}
\item[入力] clause
  \begin{itemize}
  \item 導出経路を印字すべき節
  \end{itemize}
\item[出力] clause の導出過程に出現する節が, 節識別子の順に印字される
\item[処理]
  \begin{enumerate}
  \item clause の parents スロットを再帰的に操作し, 全ての親の節を集めた
    リストを作成する
  \item 上で得た節のリストを節識別子の昇順に並べ替える
  \item リストに含まれる節を先頭から順に印字する
  \end{enumerate}
\end{description}

\subsection{オペレータの優先順位}
\label{sec:op-prec}

オペレータの優先順位は, 項の大きさを比較する際に使われるものであり,
等式の左右辺の方向付けなどで用いられる.
オペレータの大小比較は, 基本的にオペレータの名前の辞書式順で行う.
頻繁に使用されることもあり, あらかじめ初期化処理において優先順位表
を作成して置き, 実際の比較ではこの表を参照して大きさの比較を行うもの
とする. 

\subsubsection{オペレータの優先順位表}
\label{sec:op-prec-tables}

推論実行時の大小比較の効率化のため, 次の2種の表を設ける.
\begin{description}
\item[辞書式順位表]
  オペレータの内部構造をキーとし, その優先順位をあらわす正の整数値を
  データとした表である. 
  オペレータの優先順位は, モジュールに含まれる全オペレータについて
  その名前を辞書式順に比較して, 小さい方から大きい方へ順に正の整数値
  を割り振る. 

\item[相対順位表]
  オペレータの相対的な優先順位を定めるための表である.
  オペレータの大きさは, 基本的に名前の辞書式順であるが,
  CafeOBJ モジュールで宣言された等式の左右辺の入れ換えを抑制したく,
  等式の左辺は右辺より大きいとしたい. 
  このため, 等式の左辺のトップオペレータは右辺のそれよりも,
  大きいとした相対順位をつける. さらに, lrpo (lexicographic recursive
  ordering) による項の大小比較のため, 左辺のトップオペレータは
  右辺の各副項のオペレータよりも大きいとした相対順位をつける.
  この表には, このようにして得られた相対順位を設定する.

  表のキーはオペレータの内部構造, データとして, そのオペレータより
  相対的に小さいとされたオペレータのリストと大きいとされたオペレータの
  リストの対を格納する.
\end{description}

\subsubsection{優先順位表の初期化: make-op-lex-table}
\label{sec:init-op-prec-tables}

推論に先だって, 上で述べた2種の表を初期化する必要がある.
これは makeop-lex-table 関数によって実行する.

\begin{description}
\item[入力] module
  \begin{itemize}
  \item module : 実行文脈とするモジュール
  \end{itemize}
\item[出力]
  \begin{itemize}
  \item 第 ~\ref{sec:op-prec-tables} 節で述べた, 辞書式順位表と
    相対順位表が設定される.
  \end{itemize}
\item[処理]
  辞書式順位表と相対順位表を, 第 ~\ref{sec:op-prec-tables} 節で述べ
  られている通りに設定する.
\end{description}

\subsubsection{オペレータの大小比較: op-lex-precedence}
\label{sec:op-lex-precedence}
優先順位表を参照してオペレータの大小比較を行い, 結果を返す
関数である.
順位表に格納されている情報とは別に, コンストラクタオペレータ
ないものよりも小さいという優先度を付ける.

\begin{description}
\item[入力] op1 op2
\begin{itemize}
\item op1 : 比較対象とするオペレータ
\item op2 : 比較対象とするオペレータ
\end{itemize}
\item[出力] 比較結果をあらわすキーワードシンボル.
  以下の種類がある：
  \begin{center}
    \begin{tabular}{|l|l|}\hline
      キーワード & 意味 \\\hline
    \verb|:same| & op1 = op2 \\
    \verb|:greater| & op1 $>$ op2 \\
    \verb|:less| & op1 $<$ op2 \\\hline
    \end{tabular}
  \end{center}
\item[処理]
  \begin{enumerate}
    \item 同じオペレータならば :same を返す
    \item op1 がコンストラクタで op2 がそうでなければ :less を返す
    \item op2 がコンストラクタで op1 がそうでなければ :greater を返す
    \item 相対順位表を参照する
      \begin{enumerate}
      \item op1 $<$ op2 という関係があれば :less を返す
      \item op1 $>$ op2 という関係があれば :greater を返す
      \item いずれでもなければ 5 へ.
      \end{enumerate}
    \item 辞書式順位表を参照し, それぞれのオペレータに設定されている
      優先度数値を得る. これを比較して, 相当するキーワードを返す.
  \end{enumerate}
\end{description}

\subsection{反駁エンジン主ループ}
\label{sec:infer-main-loop}
本節では反駁エンジンの, 推論過程の主ループ処理について仕様を定める.

\subsubsection{主ループ: infer-main}
\label{sec:infer-main}

主ループでは, 推論終了あるいは中断の条件が検知されるまで, 
フラグで指定された推論ルールにしたがって導出節を生成しつづける. 
infer-main はこのメインルーチンである.

\begin{description}
\item[入力] mod
  \begin{itemize}
  \item mod : 反駁エンジンの実行文脈とするモジュール
  \end{itemize}
\item[出力] 終了状態コード\\
  終了状態コードは, 終了した原因を示すためのキーワードシンボルであり,
  以下の種類がある：
  \begin{itemize}
    \item :sos-empty-exit -- sos が空になった
    \item :max-proofs-exit -- 導出された空節の数が, パラメータ max-proofs
      に達した
    \item :max-given-exit -- given clause の数が, パラメータ max-given の
      値に達した
    \item :max-gen-exit -- 導出節の数が, パラメータ max-gen に値に達した
    \item :max-kept-exit -- sos に入れられた節の数が, パラメータ max-kept
      に達した
  \end{itemize}
\item[処理]
\begin{enumerate}
\item 現在の主ループ状態を :keep-searching として status にセットする
\item もし変数 *pn-no-db-reset* がセットされていない(\verb|nil|)
  ならば, 引数のモジュールに対応した psystem を初期化する.
  この処理は, 関数 reset-module-proof-system によって行う
  (第 ~\ref{sec:reset-module-proof-system} 節を参照). 
\item 推論ループのための初期化処理を実行する.
  この処理は, 関数 prepare-inference によって行う
  (第 ~\ref{sec:prepare-inference} 節を参照).
\item 初期化処理の結果を知るため, 関数 check-pn-stop
  (第 ~\ref{sec:check-pn-stop} 節を参照) を呼び, 得られた状態を status
  にセットする.
\item status が :keep-searching ならば, sos から節を選択し given-clause
  にセットする(節の取り出しは関数 extract-given-clause によって行う
  -- 第 ~\ref{sec:extract-given-clause} 節を参照).
  
  status が :keep-searching で無ければ given-clause を \verb|nil| (無しの意味)
  にセットする.

\item given-clause が \verb|nil| でなく, かつ status が :keep-searching
  である限り, 以下の処理を繰り返す.
  \begin{enumerate}
  \item 統計情報 cl-given に 1 を加える.
  \item フラグ print-given が on の場合, given-clause を印字する
  \item given-clause を索引テーブル (第 ~\ref{sec:all-index-tables} 節を参照)
    に登録する(第 ~\ref{sec:add-to-index-table} 節を参照).
  \item given-clause を usable の最後に追加する.
  \item given-clause からフラグで指定されている推論ルールを用いて, 節を
    導出する. この処理は, 関数 infer によって実行する
    (第 ~\ref{sec:infer} 節を参照). 
  \item check-pn-stop により, 導出節生成後の状態を得て status にセットする.
  \item status の値が :keep-searching でなければ, 終了状態に関するメッセージを
    出力し, ループを抜け出す.
  \end{enumerate}
\item status の値を戻り値とする.
\end{enumerate}
\end{description}

\subsubsection{Given Clause の選択: extract-given-clause}
\label{sec:extract-given-clause}
sos 節集合から given clause を選択する場合, デフォルトでは
節の重さによって選択を行う. すなわち, 最も重さの少ない節を
選択する. 
節の重さとは, それに含まれるリテラルの重さの合計である.
リテラルの重さとは, リテラルに含まれる項の重さの合計値であり,
項の重さは, それに含まれる演算子と変数項の数を合計したものである.
これは節の生成の際に計算され, clause データ構造の pick-weight
スロットに格納されている. 

節の選択に関しては, 以下のフラグとパラメータが関係する：
\begin{description}
\item[sos-queue] on の時, sos を節の queue 構造とみなして, given clause を 
  選択する.
\item[sos-stack] on の時, sos を節の stack 構造とみなして, given clause を
  選択する.
\item[pick-given-ratio] -1 以外の値の時, このパラメータの値おきに,
  sos の先頭から given clause を選択する.
\end{description}

extract-given-clause は上の事項を考慮して given clause を sos から取り出す
関数である.

\begin{description}
\item[入力] なし
\item[出力] 
  \begin{itemize}
  \item 次に given clause とするべき 節, 無ければ \verb|nil| を返す.
  \end{itemize}
\item[処理]
  \begin{enumerate}
    \item フラグ sos-queue が on の場合
      \begin{enumerate}
        \item \verb|*sos*| の先頭要素を取り出しこれを given-clause とする.
          残りの要素を \verb|*sos*| にセットする. 
          \verb|*sos*| が空リストならば given-clause を \verb|nil| とする.
      \end{enumerate}
    \item フラグ sos-stack が on の場合
      \begin{enumerate}
      \item \verb|*sos*| の最後の要素を取り出し, これを given-clause とする.
        最終要素を取り除いた結果を \verb|*sos*| とする. \verb|*sos*| が
        空ならば given-clause を \verb|nil| とする.
      \end{enumerate}
    \item フラグ sos-queue も sos-stack も off の場合
      \begin{enumerate}
      \item \verb|*sos*| が空ならば given-clause を \verb|nil| とする.
      \item そうではなく, パラメータ pick-given-ratio の値が -1 ではなく,
        かつ統計情報 cl-given (今までの given-clause の数) を pick-given-ratio + 1
        で割ったあまりが 0 ならば, \verb|*sos*| の先頭要素を given-clause とし,
        この要素を \verb|*sos*| から削除する.
      \item 上のいずれでもなければ, \verb|*sos*| を先頭から走査し, 
        最初に見付けた最も軽い節を(clause の pick-weight スロットの値が
        最小のもの) を given-clause とする. また, 見付けた節を 
        \verb|*sos*| から削除する.
        \verb|*sos*| が空の場合は given-clause を \verb|nil| とする.
      \end{enumerate}
    \item given-clause を戻り値として返す.
  \end{enumerate}
\end{description}

\subsubsection{実行文脈初期化処理: reset-module-proof-system}
\label{sec:reset-module-proof-system}

reset-module-proof-system は, 反駁エンジンの実行文脈とする
CafeOBJ モジュール に関しての推論の準備, すなわち,
公理群の節形式への変換, オペレータ優先順位の設定,
対応する psystem (第 ~\ref{sec:data-psystem} を参照) の初期化を行う.

\begin{description}
\item[入力] module
\begin{itemize}
\item module : 実行文脈とする CafeOBJ モジュール
\end{itemize}
\item[出力]
\begin{itemize}
  \item モジュールの公理が節形式に変換され, モジュールに対応する
    psystem が初期化される.
    また, オペレータ記号の優先順位を計算し, 
    オペレータの優先順位表(第 ~\ref{sec:op-prec-tables}節)が
    設定される.
\end{itemize}
\item[処理]
  \begin{enumerate}
  \item オペレータの優先順位表を設定する(第 ~\ref{sec:init-op-prec-tables}節を参照).
  \item モジュールに psystem が未だ設定されていなければ, これを設定する
  \item psystem を初期化する
  \item モジュールの公理を節形式へ変換する(第 ~\ref{sec:module-axioms->clause}
    節を参照).
  \end{enumerate}
\end{description}

\subsubsection{推論初期化処理 : prepare-inference}
\label{sec:prepare-inference}

反駁エンジンの主ループに入る前に, さまざまな初期化処理を実行
するのが prepare-inference である.

\begin{description}
\item[入力] module
  \begin{itemize}
  \item module : 実行文脈とするモジュール
  \end{itemize}
\item[出力] 統計情報の初期化, 自動モードでの各種セッティング, 
  その他の事前準備を行う.
\item[処理]
  \begin{enumerate}
  \item フラグ universal-symmetry が on の場合に, 
    対称則(X = X)を psystem の axioms スロットに追加する.
  \item 統計情報を全て 0 に初期化する.
  \item フラグ auto が on の場合に自動セッティングを行う.
    (第 ~\ref{sec:pn-automatic-settings-1} 節を参照)
  \item built-in demodulator (モジュールに対応する psystem の 
    demods スロットに格納されている) を *demodulators* 表に登録する.
  \item フラグ process-input が on の場合, sos および usable 
    に含まれる各節に対して, 導出節の事前/事後処理(第 ~\ref{sec:pre-process}
    節および第 ~\ref{sec:post-process} 節を参照) を適用する.
  \end{enumerate}
\end{description}

\subsubsection{導出節生成エンジン群の起動 : infer}
\label{sec:infer}

infer は反駁エンジンの主ループ infer-main から呼び出され, 
フラグで指定されている推論規則に対応した, 
導出節生成エンジンを呼び出す関数である.

\begin{description}
\item[入力] given-clause
\begin{itemize}
\item given-clause : sos から取り出された導出をおこなうべき節
\end{itemize}
\item[出力] 
\begin{itemize}
\item 新たな導出節が生成され, sos に追加される
\end{itemize}
\item[処理]
\begin{enumerate}
\item max-weight パラメータの調整
  \begin{enumerate}
  \item もし, フラグ control-memory が on であれば, 現在の sos 節集合に
    登録されている節の数を調べ, 必要ならば max-weight パラメータを調整する.
    この処理は, 関数 pn-control-memory によって, 実行される
    (第 \ref{sec:pn-control-memory} 節を参照).
  \end{enumerate}
\item binary resolution の実行
  \begin{enumerate}
  \item もし, フラグ binary-res が on であったならば, binary-resolution
    関数を呼び出し, binary resolution を実行する
    (第~\ref{sec:binary-resolution}節を参照). 
  \item binary-resolution から戻された新たな導出節の各々について,
    導出節の後処理を実行する. 後処理は, 関数 post-proc によって
    実行する(第 ~\ref{sec:post-proc} 節を参照 --- 以下同様). 
  \end{enumerate}

\item hyper resolution の実行
  \begin{enumerate}
  \item もし, フラグ hyper-res が on であったならば, hyper-resolution
    関数を呼び出し, hyper resolution を実行する
    (第~\ref{sec:hyper-resolution}節を参照).
  \item hyper-resolution から戻された新たな導出節の各々について,
    導出節の後処理を実行する. 
  \end{enumerate}

\item negative hyper resolution の実行
  \begin{enumerate}
  \item もし, フラグ neg-hyper-res が on であったならば, 
    nagtive hyper resolution を実行する (第~\ref{sec:neg-hyper-resolution} 節
    を参照). 
  \item neg-hyper-resolution から戻された新たな導出節の各々について,
    導出節の後処理を実行する. 
  \end{enumerate}

\item paramodulation into の実行
  \begin{enumerate}
  \item もし, フラグ para-into が on であったならば, 
    paramodulation-into
    関数を呼び出し, paramodulation (into) を実行する
    (第~\ref{sec:paramodulation-into}節を参照).
  \item paramodulation-into から戻された新たな導出節の各々について,
    導出節の後処理を実行する. 
  \end{enumerate}

\item paramodulation from の実行
  \begin{enumerate}
  \item もし, フラグ para-from が on であったならば, 
    paramodulation-from
    関数を呼び出し, paramodulation (from) を実行する
    (第 ~\ref{sec:paramodulation-from} 節を参照).
  \item paramodulation-from から戻された新たな導出節の各々について,
    導出節の後処理を実行する.
  \end{enumerate}
\end{enumerate}  
\end{description}

\subsubsection{max-weight パラメータの調整: pn-control-memory}
\label{sec:pn-control-memory}

推論実行中の sos の爆発を避けるために用意されているパラメータが
max-weight である. このパラメータ値を越えるサイズを持つ導出節は
sos に登録されずに捨てられる. 

さらに, そのサイズが一定の目安を越えた場合に, max-weight 
パラメータの値を自動調整することも行う. これはフラグ control-memory
が on になっている場合に実行される.
\verb|pn-control-memory| は control-memory フラグが on の場合に
呼び出され, 上記の自動調整を行う関数である.

\begin{description}
\item[入力] 無し
\item[出力]
\begin{itemize}
\item 必要に応じて, max-weight パラメータの値が更新される.
\end{itemize}
\item[処理]
  この関数は sos から新たな節を取り出す毎に, フラグ control-memory 
  が on になっている場合に呼び出されるが, 実際に max-weight の
  値を調整するタイミングは, 次のいずれかの場合である.
  \begin{itemize}
  \item 呼ばれた時点での sos のサイズが, パラメータ max-sos を越えている.

    あるいは,

  \item 今までに sos から取り出された節の数(統計情報 cl-given)を
    パラメータとして, 
    初期は, cl-givenが sos の初期サイズの 20 倍に達した時点で実行する. 
    以降は 20 個置きに実行する.
  \end{itemize}

  パラメータ max-weight の値が -1 に設定されている場合は, 調整を
  行わない.

\end{description}

\subsection{導出節前処理}
\label{sec:pre-process-proc}

導出された節に関して, 
例えば max-weight パラメータで制限される節の重さ等, さまざまな節の削除条件や,
冗長な節であるかどうかの検査(subsumption や tautology)
を実行し, 残すべき節か捨てる物かを判別する.
また,  dymanic demodulator の生成や空節が生成されたか否かの検査等を実行する.

\subsubsection{前処理メイン: pre-process}
\label{sec:pre-process}

pre-process は節の前処理の主関数である.

\begin{description}
\item[入力] \verb|clause input? list|
  \begin{itemize}
  \item \verb|clause| : 前処理対象とする節
  \item \verb|input?| : usable あるいは sos に既に含まれている節に関する
    処理ならば \verb|t| そうでなければ \verb|nil|
  \item \verb|list| : 登録先の節集合の区分の指定. 以下いずれか：

    \begin{tabular}{|l|l|}\hline
      指定 & 意味 \\\hline
      :usable & usable 節集合 \\
      :sos    & sos 節集合 \\\hline
    \end{tabular}
  \end{itemize}
\item[出力]
  残すべき節ならば, その節を, さもなければ \verb|nil| を返す.
  残すべき節であった場合は, 新たな demodulator が生成される場合がある.
  空節が導出されていた場合は, 反駁エンジンを中断することがある.
\item[処理]
  \begin{enumerate}
  \item 導出節に対する前処理を施し, 結果として残すべきか否かを調べる
    (proc-gen 関数による -- 第 \ref{sec:proc-gen} 節を参照).
    結果が捨てるべき節となった場合は
    その節を削除し, \verb|nil| を返す. この時 clause が既に sos あるいは
    usable に所属しているものであった場合は, 索引テーブルからも削除する.
  \item 節に含まれる全てのリテラルを索引テーブルへ登録する.
    (第 ~\ref{sec:add-to-index-table} 節を参照).
  \item list で指定された節集合へ clause を追加する.
  \item 節の重みを計算し, pick-weight スロットへ格納する
  \item 統計情報 cl-kept の値に 1 を加える
  \item フラグ print-kept が on であるか, 引数の \verb:input?: が 非\verb|nil|
    であれば, clause を印字する
  \item フラグ dynamic-demod が on であり, 検査(dynamic-demodulator 関数による
    -- 第 \ref{sec:dynamic-demodulator} 節を参照)の結果が demodulator として
    ふさわしい節であった場合, あらたな demodulator を作成する.
    この時, フラグ print-new-demod が on であるか, あるいは \verb|input?| が
    非 \verb|nil| ならば作成した demodulator を印字する.
  \item 空節の検査を行う
    \begin{enumerate}
    \item check-for-proof 関数(第 ~\ref{sec:check-for-proof}) により
      空節の検査を行う. 
    \item もし, パラメータ max-proofs が -1 ではなく,
      導出された空節の数(統計情報 empty-clauses) の値が, パラメータ
      max-proofs に達していたら, 終了状態 :max-proofs-exit として
      反駁エンジンを中断する(大域的脱出). 
    \end{enumerate}
  \item 入力引数の clause を戻り値として返す
  \end{enumerate}
\end{description}

\subsubsection{導出節に対する処理: proc-gen}
\label{sec:proc-gen}

proc-gen は, 導出節の前処理段階において, 
それを以降の推論のための前処理を施し, 
結果として残すべきものか否かを判定する. 

\begin{description}
\item[入力] \verb|clause input?|
  \begin{itemize}
  \item clause : 前処理を施す節
  \item input? : clause が sos あるいは usable に属している節のとき
    非 \verb|nil|, さもなくば \verb|nil| 
  \end{itemize}
\item[出力] 処理中に捨てるべき節でることが判別した場合 \verb|nil| を, 
  そうでなければ前処理を施した結果の clause を返す
\item[処理]
  \begin{enumerate}
  \item 引数の節 clause の変数名を付け替える
  \item フラグ very-verbose が on であれば, clause を印字する
  \item clause に demodulation を施す. 

    もし, フラグ very-verbose が on 
    であり, 書き換えが一度でも実行されていれば, 書き換え結果の clause を
    印字する. demodulation は, demodulate-clause によって実行する
    (第 ~\ref{sec:demodulate-clause} 節を参照).

  \item 等式の左右辺の順序つけ

    フラグ order-eq が on の場合に実行する.
    このとき
    \begin{itemize}
    \item フラグ lrpo が on であれば, lrpo(lexicographic recursive path ordering) 
      による順序つけを用いる(order-equalities-lrpo -- 第 ~\ref{sec:order-equalities-lrpo} 
      節を参照)
    \item そうでなければ, 辞書式順による等式の順序つけを行う
      (order-equalities -- 第 ~\ref{sec:order-equalities} 節を参照)
    \end{itemize}
  \item unit deletion 処理を施す.

    フラグ unit-deletion が on であり, かつ, clause に含まれるリテラルの数が 2 以上の
    場合に, 実行する(unit-deletion による -- 第 ~\ref{sec:unit-deletion} 節を参照).
    
  \item  factor simplification の実行

    フラグ factor が on の場合に実行し (factor-simplify による -- 
    第 ~\ref{sec:factor-simplify} 節を参照),
    factor-simplify から返される, simplification を行った回数分,
    統計情報 factor-simplifications を増やす.

  \item tautology の検査

    節が tautology か否かを調べる(cl-tautology? による -- 第 ~\ref{sec:cl-tautology?} 節
    を参照). もしそうならば, 統計情報 cl-tautology を 1 増やし, 値 \verb|nil| で
    戻る.

  \item weight のテスト(引数の input? が \verb|nil| の場合に実行する).
    
    節の pick-weight スロットの値(節の重さ) が, パラメータ max-weight を
    越えいた場合, 戻り値 \verb|nil| で戻る. 
    この時, フラグ very-verbose が on であったならば, その旨印字する.

  \item forward subsumption テスト

    フラグ for-sub が on の場合に実行する(forwad-subsume による --
    第 ~\ref{sec:forward-subsume} 節を参照).
    
    結果として, clause が他の節に subsume されるような節であった場合は,
    統計情報の cl-for-sub に 1 を加える. また, clause を subsume する節が
    sos 節集合に含まれているものであった場合は, 統計情報 cl-for-sub-sos に
    1 を加える. さらに, フラグ very-verbose が on であるか, 引数 input? が
    非 \verb|nil| の場合は, clause が subsume された旨を印字する.

  \item clause を戻り値として戻る.
  \end{enumerate}
\end{description}

\subsubsection{Unit Deletion}
\label{sec:unit-deletion}

unit deletion は, 導出節に含まれるリテラルの数が 2 以上の場合に行われ,
各リテラル $l_i$ について, sos あるいは usable に含まれる単一節の
リテラルのうち, インスタンスが $l_i$ の否定に等しくなる場合, $l_i$ 
を削除する処理である.

\begin{description}
\item[入力] clause
\item[出力] もし削除されたリテラルが無ければ \verb|nil|, さもなくば \verb|t| を
  戻り値とする
\item[処理]
\begin{enumerate}
\item 節 clause の各リテラル $l_i$ について以下の処理を行う
  \begin{enumerate}
  \item $l_i$ が正ならば *neg-literals*, そうでなければ 
    *pos-literals* から, リテラルのアトムの演算子をキーとして,
    unify の可能性のあるリテラルのリスト $L2$ を得る.
  \item $L2$ の各リテラル $l2_j$ について, $l2_j$ がそれを含む節の唯一のリテラル
    である場合に, $l2_j$ をパターンとして $l_i$ との照合を試みる.
  \item 照合が成功した場合, $l_i$ を削除の対象とする.
  \end{enumerate}
\item 削除の対象となったリテラルがあれば, それを clause から削除し
  戻り値を \verb|t| とする.
  さもなくば, 戻り値を \verb|nil| とする.
\end{enumerate}
\end{description}

\subsubsection{Tautology 検査: cl-tautology?}
\label{sec:cl-tautology?}

\begin{verbatim}
     P | ... | ~P | ...
\end{verbatim}
という形をした節は tautology であるので, 以降の推論の役には立たない. 
cl-tautology? は, 節が tautology であるかどうかを調べる.

\begin{description}
\item[入力] clause
  \begin{itemize}
  \item   clause : 検査対象の節
  \end{itemize}
\item[出力] clause が tautology の場合 \verb|t| を, さもなくば \verb|nil|
  を返す.
\item[処理]
  \begin{enumerate}
  \item 節に含まれるリテラル $l_1,\cdots,l_n$ について
    $l_i$ と $l_j (i \neq j)$ を比較する
  \item $l_i$ と $l_j$ が互いに符号が異なり, かつ
    それらのアトムが構文的に同一の項であった場合,
    tautology と判断する.
  \item tautology であれば, \verb|t| を, さもなくば \verb|nil| を
    戻り値とする.
  \end{enumerate}
\end{description}

\subsubsection{Subsumption テスト : sumsume?}
\label{sec:subsume?}

節 $C$ が 節 $D$ を subsume するとは, 節 $C$ に含まれる全てのリテラルについて,
そのインスタンスが $D$ に含まれているような場合である.
subsume? はこのようなテストを実行する.

\begin{description}
\item[入力] \verb|clause-1  clause-2|
  \begin{itemize}
    \item clause-1 : テスト対象の節
    \item clause-2 : テスト対象の節
  \end{itemize}
\item[出力] clause-1 が clause-2 を subsume する場合に \verb|t| を,
  さもなくば \verb|nil| を戻り値とする.
\item[処理]
  \begin{enumerate}
  \item clause-1 に含まれる各リテラル $l1_i$ について,
    次の条件を満足するような, 節 clause-2 のリテラル $l2_j$ を探す：
    \begin{itemize}
      \item 符号が同一, かつ
      \item $\sigma(l1_i) = l2_j$ となるような, substitution $\sigma$ が存在する
        (つまり, $l1_i$ をパターンとして $l2_j$ と照合を行い, 成功する.)
    \end{itemize}
  \item clause-1 の全てのリテラルについて, 上の条件を満足するような
    clause-2 のリテラルが見付かったら, 戻り値を \verb|t| とする.
    さもなくば, 戻り値を \verb|nil| とする.
  \end{enumerate}
\end{description}

\subsubsection{Forward Subsumption テスト： forward-subsume}
\label{sec:forward-subsume}

導出された節が, sos あるいは usable に含まれる節によって subsume される
場合, この節は以降の推論には役に立たない(冗長である). 
この検査を forward subsumption テストと呼び, forward-subsume が実行する.

\begin{description}
\item[入力] clause 
  \begin{itemize}
  \item clause : テスト対象の節
  \end{itemize}
\item[出力] clause を subsume するような節がみつかれば, その節を, 
  さもなくば \verb|nil| を返す.
\item[処理]
  \begin{enumerate}
  \item subsume?(第 ~\ref{sec:subsume?} 節を参照) を利用して,
    sos および usable に含まれる節のうち, 引数の clause を subsume 
    するような節を探す.
  \item そのような節があれば, それを, さもなくば \verb|nil| を
    戻り値とする.
  \end{enumerate}
\end{description}

\subsection{導出節後処理}
\label{sec:post-proc}
導出節後処理とは, 前処理(第 \ref{sec:pre-process-proc} を参照)を通った
節に関して行われる処理である. 
この処理に節が渡される時点では, すでに節は適切な節集合に追加されており,
また, 索引テーブルにも登録が済んでいる. 

前処理では, 導出節の有効性を判定する検査が種々行われていたのに対して,
後処理では逆に, 新たな導出節によって冗長になるような, 既存の節を
探して削除(back subsumption)したり, 
新たに生成された demodulator によって既存の節を簡約化(back demodulation)
したりする. また, factoring によって, さらに新たな節が生成されることもある.

\subsubsection{後処理実行: post-process}
\label{sec:post-process}

post-process は上で述べたような, 導出節に対する後処理を実行する.

\begin{description}
\item[入力] \verb|clause   input?   list|
  \begin{itemize}
  \item clause : 処理対象とする節
  \item input? : もともと usable あるいは sos の初期集合に登録されていた
    節ならば \verb|t| さもなくば \verb|nil|
  \item list : 前処理で登録された節集合を示すシンボル
    \begin{itemize}
      \item :sos --- sos 
      \item :usable -- usable
    \end{itemize}
  \end{itemize}
\item[出力] 戻り値に意味はない. back subsume によって, sos あるいは usable 
  から, 節が削除されることがある.
  back demodulation によって, sos あるいは usable に含まれる節が簡約化される
  ことがある. また, factoring 処理によって, 新たな節が生成されることがある.
\item[処理]
  \begin{enumerate}
  \item 等式の入れ換え

    フラグ eq-units-both-ways が on かつ, 引数の節 clause が単一節であり
    そのリテラルが equality リテラル(等式のリテラル)の場合に
    以下の処理を行う：
    \begin{itemize}
    \item フラグ order-eq が off であるか, そうでなければ, リテラルの
      等式を向きつけることが出来なかったものであったならば, 以下の処理を
      行う. そうでなければなにもしない.
      \begin{enumerate}
        \item 等式の左右辺を入れ換えたリテラルを作成し,
        \item これを唯一のリテラルとする新たな単一節を作成する
        \item 作成した節の parents スロットに :copy-rule と
          :flip-eq-rule を追加する.
        \item 作成した節を, 導出節前処理 -- pre-process (第 ~\ref{sec:pre-process}節)
          -- にかける. 
      \end{enumerate}
    \end{itemize}

  \item back demodulation の実行

    フラグ back-demod が on かつ, clause に対応する demodulator
    が前処理で生成されていた場合に実行する.
    back demodulation は back-demodulate (第 ~\ref{sec:back-demodulate} 節を
    参照) によって行う.

  \item back subsumption のテスト

    フラグ back-sub が on の場合に行う. 
    実行は back-subsume (第 ~\ref{sec:back-subsume} 節を参照) で行う.
    clause に subsume された節の数の分だけ, 統計情報 cl-back-sub を増やす.
    このとき, print-back-sub フラグが on であるか, input? 引数が, 非 \verb|nil|
    の場合には, back subsume した旨メッセージを印字する.

  \item factoring

    フラグ factor が on 場合に行う.
    これは all-factoring (第 ~\ref{sec:all-factors} 節を参照) によって実行する.
    
%  \item back unit deletion 
    
%    フラグ back-unit-deletion が on,  かつ, clause が単一節の場合に行う.
%    これは back-unit-deletion (第 ~\ref{sec:back-unit-deletion} 節を参照)
%    によって実行する.

  \end{enumerate}
\end{description}

\subsubsection{Back Subsumption テスト ： back-subsume}
\label{sec:back-subsume}

導出された新たな節が, sos あるいは usable に含まれている節を subsume 
するような場合, subsume される節は冗長であるから削除することが出来る.
この検査を back subsumption テストと呼び, back-subsume が実行する.

\begin{description}
\item[入力] clause
  \begin{itemize}
  \item clause : 検査対象の節
  \end{itemize}
\item[出力] clause によって subsume される節のリスト. 無ければ空リスト(\verb|nil|).
\item[処理]
  \begin{enumerate}
  \item sos および usable に含まれる節のなかから, subsume?(第 ~\ref{sec:subsume?} 節を
    参照)を利用して, clause に subsume される節を探す.
  \item 見付かった節全てをリストにして戻り値とする. 無ければ \verb|nil| を
    戻り値とする.
  \end{enumerate}
\end{description}

%\subsubsection{back unit deletion}
%\label{sec:back-unit-deletion}

%導出節が単一節の場合, そのリテラルと符号が逆で照合可能なリテラル
%を削除し, 新たな節を生成することが出来る. 
%これを sos および usable に含まれる全ての節に
%対して実行するのが back-unit-deletion である.

%\begin{description}
%\item[入力] clause
%  \begin{itemize}
%  \item clause : テスト対象の節
%  \end{itemize}
%\item[出力] back-unit-deletion が適用されて新たな節が生成されることがある.
%\item[処理]
%\end{description}

\subsection{推論終了の判定}
\label{sec:ending-process}

推論途中で, パラメータの値や空節の導出を監視し, 推論の中断/終了の判定を
行う. 本節では, このための処理モジュールについて仕様使用を定める.

\subsubsection{推論終了のテスト： check-pn-stop}
\label{sec:check-pn-stop}

check-pn-stop は現在の推論プロセスの状態を監視し, 終了すべきか否かを
判定する.

\begin{description}
\item[入力] 無し
\item[出力] 次に推論プロセスの取るべき行動を示すキーワードシンボル.
  以下のいずれかである：
  \begin{center}
    \begin{tabular}{|l|l|}\hline
      キーワード & 意味 \\\hline
      :keep-searching & 推論過程を続行 \\
      :max-given-exit & given clause の数が, パラメータ max-given に達した \\
      :max-gen-exit & 空節の数が, パラメータ max-proofs に達した \\
      :max-kept-exit & 導出されて残された節の数が, パラメータ max-kept に達した
      \\\hline
    \end{tabular}
  \end{center}
\item[処理]
  \begin{enumerate}
  \item パラメータ max-given が -1 ではなく, 統計情報の cl-given が
    max-given 以上の場合, 戻り値 :max-given-exit で戻る
  \item パラメータ max-gen が -1 ではなく, 統計情報の cl-generated が
    max-gen 以上の場合, 戻り値 :max-gen-exit で戻る
  \item パラメータ max-kept が -1 ではなく, 統計情報の cl-kept が
    max-kept 以上の場合, 戻り値 :max-kept-exit で戻る
  \item 戻り値 :keep-searching で戻る
  \end{enumerate}
\end{description}

\subsubsection{空節の監視: check-for-proof}
\label{sec:check-for-proof}

check-for-proof は空節の導出を監視し, 結果を知らせる. 
空節であった場合証明木の印字も行う.

\begin{description}
\item[入力] \verb|clause  list|
  \begin{itemize}
  \item clause : 検査対象の節
  \item list   : clause の所属する節の区分(:usable なら usable 節集合,
    :sos なら sos 節集合.)
  \end{itemize}
\item[出力] clause が空節であった, あるいは unit-deletion で空節となった場合,
  その節を戻り値として返す. さもなくば, \verb|nil| を返す.
  また, 空節の場合に証明木を印字する.
\item[処理]
  \begin{enumerate}
  \item 節に含まれるリテラルの数が 0 の場合.

    これは空節であり, 以下の処理を実行する.
    \begin{enumerate}
    \item フラグ print-message が on であれば, 空節が導出された旨印字する.
    \item 統計情報 cl-kept を 1 増やす
    \item 引数の list で示される節集合からこの節を削除する
    \item 統計情報 empty-clauses を 1 増やす
    \item フラグ print-proofs が on であれば, 証明木を印字する
      (print-proof によって行う -- 第 ~\ref{sec:print-proof} 節を参照).
    \item 引数の clause を戻り値として戻る.
    \end{enumerate}

  \item リテラルの数が一つの場合(単一節)

    unit conflict があるかどうかを調べる(unit-conflict によって行う 
    --- 第 ~\ref{sec:unit-conflict} 節を参照).
    その結果 unit conflict となった場合, 以下の処理を行う. そうでなければ
    \verb|nil| を戻り値として戻る.

    unit-conflict から得た各空節について以下を実行する：
    \begin{enumerate}
    \item print-message フラグが on の場合 unit confict となった旨印字する.
    \item フラグ print-proofs が on の場合証明木を印字する.
    \item list で示される節集合からこの節を削除する.
    \end{enumerate}
    その後, 
    unit-conflict から得た空節のリストを戻り値として戻る.

  \item \verb|nil| を戻り値として戻る.
  \end{enumerate}
\end{description}

\subsubsection{Unit Conflict 検査: unit-conflict}
\label{sec:unit-conflict}

unit-conflict は与えられた単一節を反駁するような, sos あるいは usable に
含まれる単一節の全てを探し, もしあればそれぞれについて反駁を
実行して空節を作り, それらの空節のリストを返す.

\begin{description}
\item[入力] clause
  \begin{itemize}
  \item clause : unit conflict の検査をする節
  \end{itemize}
\item[出力] unit conflict の結果得られた導出節(空節)のリスト. なければ \verb|nil|.
\item[処理]
  \begin{enumerate}
  \item 節 clause のリテラル $l1$ が正のリテラルならば *neg-literals* を, 
    さもなくば *pos-literals* を索引テーブルとして使用する.
  \item 索引テーブルから, $l1$ のアトムの演算子をキーとして, unify の可能性のある
    リテラルのリスト $L2$ を得る.
  \item $L2$ の各リテラル $l2_i$ について, それを含む節が単一節の場合に
    以下を実行する.
    \begin{enumerate}
    \item $l1$ と $l2_i$ を unify する
    \item unify 出来たならば clause と $l2_i$ の節とで導出節を生成し,
      以下の処理を行う:
      \begin{enumerate}
        \item 統計情報 empty-clauses に 1 を加える
        \item パラメータ max-proofs が -1 ではなく, 
          今までに生成された空節の数(統計情報 empty-clauses)が
          max-proof に達していたら処理を中断し, これまでに生成された
          導出節(空節)のリストを戻り値として戻る.
      \end{enumerate}
    \end{enumerate}
  \item 生成された空節のリストを戻り値として戻る. 無ければ \verb|nil| を
    戻り値とする.
  \end{enumerate}
\end{description}

\subsection{Factoring 処理}
\label{sec:factoring-proc}

節 $C$ に含まれる 2つ以上の(同じ符号の)リテラルに，mgu(most general unifier)
$\sigma$ があるとしたとき，$\sigma C$ ($C$ の各リテラルのアトムに, $\sigma$ 
を適用した結果) を $C$ の factor と呼ぶ．

例えば，
$C = \underline{P(x)}\lor \underline{P(f(y))} \lor 〜Q(x)$ としたとき，
(下線を引いた)最初と2番目のリテラルは，mgu $\sigma = \{f(y)/x \}$ を持つ．
したがって，$\sigma C = P(f(y))\lor 〜Q(f(y))$ は $C$ の factor である．

\subsubsection{Factor の計算: get-factors}
\label{sec:get-factors}

get-factors は節から得られる factor のリストを求めて返す.
factor は, 節に含まれる同一符号のリテラル同士の間で unify が
可能である場合に, 一方のリテラルを除去し, さらに残りのリテラル
に対して unify で得られた変数置換を適用して得る．

\begin{description}
\item[入力] clause
  \begin{itemize}
  \item clause : factor を求める節
  \end{itemize}
\item[出力] 得られた factor 節のリスト. なければ空リスト(\verb|nil|).
\item[処理]
  \begin{enumerate}
  \item factors を空リストに設定する. factors は戻り値として使われる.
  \item 節に含まれる各リテラルの組合せ $l_i$ と $l_j (i \neq j)$ について
    以下の処理を行う.
    \begin{enumerate}
    \item $l_i$ と $l_j$ の符号が互いに等しい場合に, unify を試みる
    \item unify できた場合以下の処理を行う
      \begin{enumerate}
      \item clause から $l_j$ を削除した新たな節 a-factor を作成する
      \item a-factor の各リテラルに unify で得られた変数置換を適用する
      \item a-factor を factors にいれる
      \end{enumerate}
    \end{enumerate}
  \item factors を戻り値として返す.
  \end{enumerate}
\end{description}

\subsubsection{Factor 節の導出: all-factors}
\label{sec:all-factors}

all-factors は, 節から得られる全ての factor 節を求め,
それらを新たな導出節とする.

\begin{description}
\item[入力] \verb|clause   list|
  \begin{itemize}
  \item claues : factor 節を求めるべき節
  \item list   : 得られた factor 節を登録すべき節集合の指示. 
    :sos ならば sos 節集合, :usable ならば usable 節集合.
  \end{itemize}
\item[出力] 戻り値に意味はない. 生成された全ての factor 節に, 対して
  導出節に対する前処理(pre-process -- 第 \ref{sec:pre-process} 節を参照)
  が施され, pre-process によって, list で指定された節集合に factor 節が
  登録される. 
\item[処理]
  \begin{itemize}
  \item get-factors によって, clause の全 factor 節を得る
  \item 得られた個々の factor 節に対し：
    \begin{enumerate}
    \item parents スロットに '(:factor-rule clauseの節識別子) を追加する.
    \item 統計情報 cl-generated および factor-gen に 1 を加える
    \item pre-process にかける
    \end{enumerate}
  \end{itemize}
\end{description}

\subsubsection{Factor Simplification 処理: factor-simplify}
\label{sec:factor-simplify}

factor simplification は, ある節の factor が元の節を subsume する
ものかどうかを調べ, そうであれば元の節のリテラルを factor の
リテラルで置き換える. このようにして clause を簡単化して, 冗長な
リテラルを削除して行く.

\begin{description}
\item[入力] clause
  \begin{itemize}
  \item clause : 簡単化を行う対象とする節
  \end{itemize}
\item[出力] 簡単化が実行された数
\item[処理]
  \begin{enumerate}
  \item clause から得られる全ての factor を順次取り出し, a-factor とする
  \item 個々の a-factor について以下の処理を実行する
    \begin{enumerate}
    \item a-factor が clause を subsume するかどうかを調べる
      (subsume? によって行う -- 第 ~\ref{sec:subsume?} 節を参照).
    \item subsume された場合は以下を実行する:
      \begin{enumerate}
      \item clause のリテラルを, a-factor のリテラルで置き換える
      \item clause の parents スロットに '(:factor-simp-rule) を追加する
      \item 簡単化が実行された個数を 1 増やす
      \item a-factor を削除し, 次の factor を a-factor とする
      \end{enumerate}
    \end{enumerate}
  \item 簡単化が実行された数を戻り値として返す
  \end{enumerate}
\end{description}

\subsection{Binary Resolution}
\label{sec:binary-res}

binary resolution はリテラルとリテラル 1 対 1 の通常の resolution ルールである.
resolution のスキームは図 \ref{fig:binary-res} に示す通りである：
\begin{figure}[htbp]
  \begin{center}
    $$
    \infer{
      \begin{array}{ll}
        \mbox{\textbf{binary resolvent:}} &
        \sigma K_1, \cdots, \sigma K_k, \sigma M_1,\cdots,\sigma M_m
      \end{array}
      }
    {\begin{array}{ll}
        \mbox{\textbf{clause-1:}}& 〜L', M_1,\cdots,M_m \\
        \mbox{\textbf{clause-2:}}& L,K_1,\cdots,K_k
      \end{array}\;\;\;\;\sigma は L と L' の mgu
      }
    $$
    \caption{binary resolution のスキーム}
    \label{fig:binary-res}
  \end{center}
\end{figure}

図に示したスキームで, 二つの親節は同一の変数項を共通して持っていてはならない.
この条件は, 生成節の変数は常にユニークになるように変数のつけ替えが行われて
いるため, 自動的に満足されている. 

\subsubsection{Binary Resolvent の作成: build-bin-res}
\label{sec:build-bin-res}

biild-bin-res は binary resolution による導出節(binary resolvent 
-- 図 \ref{fig:binary-res}を参照) を生成する.

\begin{description}
\item[入力] \verb|literal-1   literal-2   subst|
  \begin{itemize}
  \item literal-1 : unify したリテラル
  \item literal-2 : unify したもう一方のリテラル
  \item subst : unify で得られた変数置換
  \end{itemize}
\item[出力] 生成された導出節
\item[処理]
  \begin{enumerate}
  \item 生成する導出節のリテラルのリスト $L$ を空リストにセットする
  \item literal-1 を含む節 clause-1 (リテラルの clause スロットより得る) に
    含まれる各リテラル $l_i$ に関して以下の処理を行う.
    \begin{enumerate}
    \item $l_i = \mbox{literal-1}$ ならば, $l_i$ を捨てる
    \item そうで無ければ 引数の subst を $l_i$ に適用して
      新たなリテラル $l_{i}'$ を作成し, $L$ にいれる
    \end{enumerate}
  \item literal-2 を含む節 clause-2 に関しても 1 と同様の処理を行い, 
    新た生成された各リテラルを $L$ にいれる
  \item 新たな節 clause を作成する
  \item clause の literals スロットに, 上の 1, 2 で作成されたリテラルのリスト $L$ 
    をセットする
  \item clause の parents スロットに 
    ((:binary-res-rule clause-1 の節識別子 clause-2 の節識別子)) をセットする.
  \item clause を戻り値として返す.
  \end{enumerate}
\end{description}

\subsubsection{Binary Resolution の実行: binary-resolution}
\label{sec:binary-resolution}

binary-resolution は, 与えられた節と binary resolution が可能な節を
usable から探し, 全ての可能な導出節を生成して返す.

\begin{description}
\item[入力] clause
  \begin{itemize}
  \item clause : (binary) 導出節を生成すべき節
  \end{itemize}
\item[出力] 生成された導出節のリスト. 無ければ空リストが返される.
\item[処理]
  \begin{enumerate}
  \item 結果として返す導出節のリスト resolvent-list を空リストにセットする
  \item 引数の clause に含まれる各リテラル $l1_i$ について以下の処理を行う：
    \begin{enumerate}
    \item $l1_i$ が正のリテラルならば *clash-neg-literals* を, 
      負のリテラルならば *clash-pos-literals* を探索対象の索引テーブルとする
    \item $l1_i$ のアトムの演算子をキーとして, 索引テーブルから
      unify の可能性のあるリテラルのリスト $L2$ を得る
    \item $L2$ に含まれる各リテラル $l2_j$ に関して以下の処理を行う：
      \begin{enumerate}
      \item $l1_i$ と $l2_j$ の unify を試みる
      \item unify できたら, 以下の処理を実行する：
        \begin{itemize}
        \item build-bin-res(第 ~\ref{sec:build-bin-res} 節を参照)により,
          導出節を作成する
        \item 統計情報 cl-generated および binary-res-gen を 1 増やす
        \item 作成された導出節に対して, 導出節に対する前処理 pre-process 
          (第 ~\ref{sec:pre-process} 節を参照) を施す. このとき, 
          登録すべき節集合の区分として :sos を指定する.
        \item pre-process の結果が, 残すべき節となった場合, この導出節を
          resolvent-list にいれる.
        \end{itemize}
      \end{enumerate}
    \end{enumerate}
  \item resolvent-list を戻り値として返す.
  \end{enumerate}
\end{description}

%%%
\subsection{Hyper Resolution}
\label{sec:hyper-res}

ある節から導かれる導出節を考えた場合, それを得るのに
異なった導出ステップがあり得る. 
従って, 同じ導出節が複数回生成される場合があり得る.
これは望ましくないので, この複数のステップをまとめて
一度の resolution によって導出しようとするのが hyper resolution
である.

反駁エンジンでは，positive hyper resolution と negative hyper resolution
の2種の hyper resolution 機能を提供しているが，これらはいずれも
一種の semantic resolution であり，PI-resolution と呼ばれるより一般的な
resolution rule の特殊形である．

ここではまず最初に，この semantic resolution の考えかたについて説明し(\cite{chang-lee})，
ついで，hyper resolution のスキームについて説明する．

\paragraph{Semantic Resolution の考え方}\cite{chang-lee}

節の集合 $S$ を，
$S = \{〜P \lor 〜Q \lor R, P\lor R, Q\lor R, 〜R\}$
とする．この節集合の充足不能性を示すのに，通常の binary-resolution を
使うと，以下に示すような演繹過程となる：

\begin{center}
{\small
\begin{tabular}{lll}
(1) & $〜P \lor 〜Q \lor R$ & $S$ の要素 \\
(2) & $P\lor R$ & $S$ の要素 \\
(3) & $Q\lor R$ & $S$ の要素 \\
(4) & $〜R$  & $S$ の要素 \\
(5) & $〜Q\lor R$ & (1) と (2)から\\
(6) & $〜P\lor R$ & (1) と (3)から \\
(7) & $〜P\lor 〜Q$ & (1) と (4) から\\
(8) & $P$ & (2) と (4) から \\
(9) & $Q$ & (3) と (4) から \\
(10) & $〜Q\lor R$ & (1) と (8)から \\
(11) & $〜P\lor R$ & (1) と (9)から \\
(12) & $R$ & (2) と (6) から \\
(13) & $〜Q$ & (4) と (5) から \\
(14) & $〜P$ & (4) と (6) から \\
(15) & □ & (4) と (12) から \\
\end{tabular}
}
\end{center}
導出節のうち，実際に証明に使われているのは (6) と (12) だけである．
その他の導出節は全て冗長である．この様な冗長な節の導出を避けるのが
目的となる．

節を適当な2つのグループ $S_1$ と $S_2$ に分けることが出来たとする.
また, おなじグループに含まれる節同士の間では resolution を行わないとする.
このようにする事で, 導出される節の数が減ることはあきらかである.

semantic resolution では, 節のグループ分けに\textbf{解釈}(interpretation)
を用いる. 上の例で, (2) と (3) は, 解釈 $I = \{〜P, 〜Q, 〜R\}$ では
false である. 一方 (1) と (4) は満足される. このようにすることで, 
$S$ を解釈で true になるものとそうでないものとに分類することが出来る.
反駁エンジンは, 節の充足不可能な節集合を扱うものであるから,
どのような解釈を採用したとしても, それが全ての節を満足したり否定する
ようなことは無い. したがって, どのような解釈によっても節集合を
2つの集合に分類することが可能である.
以下では, 先の例の節集合 $S$ が上で述べた解釈 $I$ によって,
二つのグループ 
$S_1 = \{(2), (3)\}$, $S_2 = \{(1), (4)\}$ に分類されているものとする.
このように分類しても, (2) と (3) は (4) と resolve することが出来る.
以下で述べるように, この resolution についても避けることが可能である.

上のような resolution を回避するため, 述語記号の間の順序付けを使うことが
出来る.
たとえば, $S$ に含まれる述語記号に
\[ P > Q > R \]
という順序を付けるものと仮定する.
この順序付けのもとで, 2つの節(片方は $S_1$ の節, もう片方は $S_2$ の節)
を resolve する場合, resolve されるリテラルで $S_1$ に属する節のものは
最大の述語記号をもっていなければならない, という制約条件を付ける.
この制約のもとでは, $R$ は (2) および (3) で最大の述語記号ではないため,
(2) を (4) と resolve することは出来ないし，また, (3) と (4) に関しても同様である.  

次に semantic resolution で重要となる概念である clash について説明する.
まず, 先の例の節について見てみる.
\begin{enumerate}
\item[(1)] $〜P\lor 〜Q \lor R$
\item[(2)] $P\lor R$
\item[(3)] $Q\lor R$
\item[(4)] $〜R$
\end{enumerate}
解釈 $I$ を $I = \{〜P,〜Q,〜R\}$ とし, 述語記号の順序を 
$P > Q > R$ とする. 上で議論した2つの制約を適用すると, 次の2つの
節のみが導出出来る：
\begin{enumerate}
\item[(5)] $〜Q\lor R$ \hskip4cm (1)と(2)から
\item[(6)] $〜P\lor R$ \hskip4cm (1)と(3)から
\end{enumerate}
これらの両方とも $I$ によって満足される. したがってこれらを $S_2$ へ入れ,
それらを $S_1$ に含まれる節と resolve する. 
(5) は (3) と (6) は (2) と resolve 出来る. 両方とも同じ結果 $R$ になる.
\begin{enumerate}
\item[(7)] $R$ \hskip5cm (3)と(5)から
\item[(8)] $R$ \hskip5cm (2)と(6)から
\end{enumerate}
節 $R$ は $I$ では false なので, それを $S_1$ へ入れ, これと $S_2$ に含まれる
節との間で resolve を行う. $〜R$ が $S_2$ にあるので, 空節 □ を得る.

上の二つの $R$ の導出過程を見ると, ともに節 (1), (2) と (3) が使われている.
異なるのはそれらが使われる順序である. どちらか一つだけが必要であり, 片方は
冗長であり, 極めて無駄である. この冗長性を無くすために, clash という概念を
導入する. clash の考え方は, (1), (2), (3) の3つの節から, 
中間的な節 (5) や (6) を経由せずに, 直接的に $R$ を導出するというものである. 
この例では, 集合 $\{(1), (2), (3)\}$ を clash と呼ぶ. clash の詳細に
ついては, 次のパラグラフで説明する. 

\paragraph{PI-resolution の定義}
$I$ を解釈とし，$P$ を述語記号の順序付けとする．
節の有限集合 $\{E_1,\ldots, E_q, N\}$, $q \ge 1$ は
次の条件を満足する時，\textsl{semantic clash} と呼ばれる：
\begin{enumerate}
\item $E_1,\ldots, E_n$ は $I$ で false
\item $R_1 = N$ とする. 各 $i = 1, \ldots q$ について, 
  $R_i$ と $E_i$ の resolvent $R_{i+1}$ が存在する.
\item resolve される $E_i$ のリテラルは, $E_i, i = 1,\ldots q$ の
  うちで最も大きな述語記号を持っている.
\item $R_{q+1}$ は $I$ において false
\end{enumerate}
$R_{q+1}$ を (PI-clash $\{E_1,\ldots,E_q,N\}$ の) PI-resolvent と呼ぶ.
また, $E_1,\ldots,E_n$ を \textbf{electrons}, $N$ を \textbf{nucleus}
と呼ぶ. 

例えば, 
$$
E_1 = A_1 \lor A_3, \hskip1cm E_2 = A_2 \lor A_3, \hskip1cm 
N = 〜A_1 \lor 〜A_2 \lor A_3
$$
とする. 解釈 $I$ を $I = \{〜A_1, 〜A_2, 〜A_3\}$ とし, 順序 $P$ を
$A_1 > A_2 > A_3$ とする. 
この場合, $\{E_1,E_2,N\}$ は PI-clash である. この clash の PI-resolvent 
は, $A_3$ である($A_3$ は $I$ で false であることに注意). 

\paragraph{Negative Hyper Resolution}
negative hyper resolution は，上で述べた PI-resolution で
解釈 $I$ に否定記号が含まれていない場合である．

negative hyper resolution のスキームを図\ref{fig:hyper-res}に示す.
\begin{figure}[htbp]
  \begin{center}
    \epsfxsize=\textwidth
    \centering\epsfbox{hyper-res.eps}
    \caption{hyper resolution のスキーム}
    \label{fig:hyper-res}
  \end{center}
\end{figure}

図で nucleus とあるのは, 少なくとも一つの正のリテラルをもつ節である.
反駁可能な節集合にはこのような節が必ず存在する.
nucleus の個々の正のリテラルにつき, 負のリテラルのみを持つ節 electron が必要である.
やはり, 反駁可能な節集合にはこのような節が必ず存在する.
nucleus は全ての electron と「同時に」resolve されなければならない. 
結果として負のリテラルのみからなる節が, 導出節として得られる(図の hyper-resolvent).
この導出節は, 以降の hyper-resolution ステップで electron として使用することが出来る.

我々の反駁エンジンでは, フラグ neg-hyper-res が on の時に
使用される negative-hyper-resolution に相当する.

\paragraph{Positive Hyper Resolution}

フラグ hyper-res が on の時に使用されるのは, これと dual な関係にある,
\textsl{positive} hyper resolution である. 
これは, 上で述べたスキームで, リテラルの 正/負 を逆にする事で得られ，
PI-resolution で，解釈 $I$ に含まれる各リテラルが否定記号を含む場合に
相当する．

否定の形で与えられる結論は, 通常負のリテラルのみを含むことが多いため,
negative hyper-resolution の electron として用いる事が出来るので,
結論から仮定へ向かっての, 後向き推論に適していると言える.
一方 positive hyper-resolution は, 仮定から結論へ向けての, 前向きの
推論が可能である. 

\subsubsection{Positive Hyper Resolution の実行: hyper-resolution}
\label{sec:hyper-resolution}

\begin{description}
\item[入力] clause
\begin{itemize}
\item clause : 導出を行う節
\end{itemize}
\item[出力] 導出節のリスト
\item[処理]
  この時点で given-clause は usable に入れられているので，
  自分自身も clash の対象になる節に含まれている．
  \begin{enumerate}
    \item given-clause が positive clause ではなかったら
      つまり，少なくとも一つの負のリテラルを含むものであったら
      これは nucleus になる．そうでなかったら 2 へ．

      \begin{enumerate}
      \item[1.1] 含まれているリテラルを分別する：
        \begin{itemize}
        \item 負のリテラル → clash の対象
        \item 正のリテラル → その他
        \end{itemize}
      \item[1.2]  usable に含まれている positive clause のうち，
        clash 対象となった負のリテラルのどれかと clash できる
        リテラルを含む節の集合を求める．その際，既にunifyによって計算
        されている変数置換が制約条件になる．組合せは複数あるはずだし，
        変数に関する制約条件ではねられるものもあるので，
        back track しながら網羅的に探索する．
      \item[1.3] 見付かった全ての組合せについて，それぞれ hyper resolvent を
        計算し，それを結果とする．
      \end{enumerate}
    \item given-clause が positive clause であった場合

      これは electron にななり得る．この場合は given-clause の
      各リテラル $l_i$ に付いて，以下の処理を行う．

      \begin{enumerate}
      \item[2.1] usable の中で，$l_i$ と clash 可能な(unify できる可能性のある)
        リテラルを含むような，nucleus になり得る節(少なくとも一つの負のリテラル 
        を含むような節を探す．
      \item[2.2] そのような節が見付かった場合，上の 2.1 および 2.2 の処理を
        今見付けた節に関して実行する．
        但し，clash 対象となる節の集合に，あらかじめ given-clause を
        入れておき，これを探索の際の制約条件の一つとする事．

      \end{enumerate}
      2.1 で nucleus になり得る節は複数あるはずなので，それらに関して，
      網羅的に上の処理を行う．
  \end{enumerate}
\end{description}

\subsubsection{Negative Hyper Resolution の実行 : neg-hyper-resolution}
\label{sec:neg-hyper-resolution}

neg-hyper-resolution は negative hyper resolution を実行するものである．
入出力処理の仕様は hyper resolution と同じである．
ただしリテラルの正負の判定を逆にする．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Paramodulation}
\label{sec:paramod}

paramodulation は等号を扱うための推論ルールである. 
図~\ref{fig:paramod-rule} に paramodulation のスキームを示す.
図で, $l = r$ は \textbf{paramodulator} (正の等式リテラル), 
$f(t)$ は $t$ を副項に持つようなリテラル
である. $f(\sigma{r})$ は, その $t$ を $\sigma(r)$ で置き換えた項を
表すものとする.

\begin{figure}[htbp]
  \begin{center}
    $$
    \infer{
      \begin{array}{ll}
        \mbox{\textbf{paramodulant:}} &
        f(\sigma r), \sigma L_1,\cdots,\sigma L_n,\sigma M_1,\cdots,\sigma M_m
      \end{array}
      }
    {\begin{array}{l}
        l = r, L_1,\cdots,L_n \\
        f(t), M_1,\cdots,M_m
      \end{array}\hskip2cm\sigma は l と t の mgu
      }
    $$
    \caption{paramodulation のスキーム}
    \label{fig:paramod-rule}
  \end{center}
\end{figure}
図で, $\sigma$ は, リテラル $f(t)$ の副項 $t$ と paramdulator の
左辺 $l$ との mgu(most general unifier) である ($\sigma l = t$).
paramodulant は $t$ を paramodulator の右辺に $\sigma$ を適用した
もの($f(\sigma r)$) で置き換えることによって得られる.

\subsubsection{Paramodulant の作成 : build-bin-para}
\label{sec:build-bin-para}

\begin{description}
\item[入力] \verb|rule   target-term   into-lit   subst|
\begin{itemize}
\item rule : paramodulator (データ型 paramod -- \ref{sec:data-paramod} 節を参照)
\item target-term : 置き換え対象の項
\item into-lit : 置き換え対象のリテラル
\item subst : mgu (変数置換)
\end{itemize}
\item[出力] paramodulant の節
\item[処理]
\begin{enumerate}
\item 引数の into-lit から paramodulation の対象となる節を得, into-clause にセットする
\item 新たな節を作成し, これを new-clause とする
\item new-clause のリテラルのリスト new-literals を空リストに設定する
\item into-clause の各リテラル $l_i$ に関して以下の処理を行う
  \begin{enumerate}
  \item $l_i$ が into-lit に等しければ, into-lit のアトムの副項のうち
    引数の target-term に等しい項を, paramodulator(引数 rule) の右辺に subst を
    適用したもので置き換えた項を, 新たなリテラルのアトムとし, new-literals にいれる
  \item さもなくば, $l_i$ に subst を適用したリテラルを new-literals にいれる
  \end{enumerate}
\item rule から paramodulator のもととなった節 from-clause を得る.
\item from-clause の各リテラル $l2_i$ に対して subst を適用したリテラルを
  new-literals にいれる
\item new-clause のリテラルリストを new-literals とする
\item new-clause を返す
\end{enumerate}
\end{description}

\subsubsection{項の paramodulation : para-into-terms}
\label{sec:para-into-terms}

para-int-terms は, 指定の項に対する paramodulation を実行し,
生成された導出節を返す. paramodulation-into で使用される.

\begin{description}
\item[入力] \verb|target-term   into-lit    &optional rule|
\begin{itemize}
\item target-term : paramodulation の対象とする項
\item into-lit    : target-term を副項として持つリテラル
\item rule        : paramodulator (データ型 paramod -- 第\ref{sec:data-paramod}
  節を参照. オプション引数であり, 指定された場合は rule を paramodulator として使う.
\end{itemize}
\item[出力] 導出節のリスト, 無ければ空リスト
\item[処理]
\begin{enumerate}
\item 引数の項 target-term が演算子の適用フォームでなければなにもせずに
  戻り値を空リストとして戻る.

\item 戻り値とする導出節のリスト paramodulants を, 空リストに設定する.
\item target-term が $L = R$ の形の項の場合, 以下の処理を行う：
  \begin{enumerate}
  \item フラグ para-into-left が on であれば, $L$ に対して, この手続きを
    再帰的に適用する. 得られた導出節を paramodulants に追加する.
  \item フラグ para-into-right が on であれば, $R$ に対して, この手続きを
    再帰的に適用する. 得られた導出節を paramodulants に追加する.
  \end{enumerate}
\item target-term が $L = R$ 以外の形の項の場合には, 以下の処理を行う.
  \begin{enumerate}
  \item 各副項に対してこの手続きを再帰的に適用する. 
  \item 得られた導出節を paramodulants に追加する.
  \end{enumerate}
\item 引数の rule が指定されていなければ,
  *parmod-rules* 索引テーブルから, terget-term の演算子をキーとして,
  適用の可能性のある paramodulator のリストを得る.
  rule が指定されていれば paramodulator として, この rule を用いる.
\item 各 paramodulator に関して以下の処理を実行する.
  \begin{enumerate}
  \item paramodulator の左辺と terget-term を unify する.
  \item unify できた場合以下の処理を実行する：
    \begin{enumerate}
    \item build-bin-para により, 新たな導出節 new-clause を作成する
    \item new-clause の parents スロットに
      ((:para-into-rule `into-lit の節の節識別子' `paramodulator の節の節識別子'))
      をセットする.
      引数の rule が指定されていれば, この :para-into-rule は 
      :para-from-rule とする.
    \item 統計情報 cl-generated および, para-into-gen を 1 増やす
    \item 導出節に対する前処理 --- pre-process, ~\ref{sec:pre-process} 節を参照 ---
      を適用する.
    \item 前処理の結果, 残すべき節であれば, paramodulants に追加する.
    \end{enumerate}
  \end{enumerate}
\item paramodulants を戻り値として返す.
\end{enumerate}
\end{description}

\subsubsection{導出節に対する paramodulation : paramodulation-into}
\label{sec:paramodulation-into}

paramodulation-into は, 導出された節に対して, paramodulation を施す.

\begin{description}
\item[入力] clause
  \begin{itemize}
  \item clause : paramodulation の対象とする項
  \end{itemize}
\item[出力] 新たに生成された導出節のリスト. なければ空リスト.
\item[処理]
\begin{enumerate}
\item フラグ para-into-units-only が on で, 引数の節 clause が
  unit clause でなければ, なにもせずに空リストを戻り値として戻る.
\item 戻り値とする導出節のリスト paramodulants を空リストに設定する.
\item clause の各リテラルに対して paramodulation を実行
  (para-into-terms によって実行する -- \ref{sec:para-into-terms} 節を
  参照) し, 得られた導出節を paramodulants に追加する
\item paramodulants を戻り値として返す
\end{enumerate}
\end{description}

\subsubsection{ルールを指定した paramodulation : para-from-alpha}
\label{sec:para-from-alpha}

para-from-alph は適用するルールを指定した parmodulation を行う.
対象となる節は usable に含まれている各節である.
para-from によって使用される.

\begin{description}
\item[入力] \verb|para-rule   from-lit|
\begin{itemize}
\item para-rule : 適用すべき paramodulator (データ型 paramod --- 
  第~\ref{sec:data-paramod} 節を参照)
\item from-lit  : para-rule のもとになった項を副項として含むリテラル
\end{itemize}
\item[出力] 生成された導出節のリスト. 無ければ空リスト.
\item[処理] 
\begin{enumerate}
\item 戻り値とする paramodulants を空リストに初期化する.
\item *usable* に含まれている各節 $C_i$ に関して以下の処理を実行する：
  \begin{enumerate}
  \item フラグ para-from-units-only が on であり, $C_i$ が unit clause
    でなければなにもしない.
  \item $C_i$ の各リテラルの項に対して, para-into-terms により
    paramodulation を行う. このとき para-rule を, 使用すべきルールとして
    与える.
  \item para-into-terms から戻された導出節を paramodulants に追加する.
  \end{enumerate}
\item paramodulants を戻り値として返す.
\end{enumerate}
\end{description}

\subsubsection{導出節からの paramodulation : paramodulation-from}
\label{sec:paramodulation-from}

paramdulation-from は, 導出節を paramodulator として, usable あるいは
sos に含まれる節の paramodulation を試みる.

\begin{description}
\item[入力] clause
\begin{itemize}
\item paramodulator として使うべき節
\end{itemize}
\item[出力] 新たに生成された導出節のリスト. なければ 空リスト.
\item[処理]
\begin{enumerate}
\item フラグ para-from-units-only が on であり, clause が unit clause で
  ない場合は, なにもせずに 戻り値を 空リストとして戻る.
\item 戻り値とする導出節のリスト paramodulants を空リストに初期化する.
\item clause に含まれる各リテラル $l_i$ に関して, 以下の処理を実行する.
  \begin{enumerate}
  \item $l_i$ が正の equality ($L = R$) でなければなにもしない.
  \item フラグ para-from-left が on の場合, $l_i$ $L \rightarrow R$ という
    形の paramod を作り, paramodulation を実行する(para-from-alpha によって
    行う --- 第\ref{sec:para-from-alpha} 節を参照). 
    このとき得られた導出節を paramodulants に追加する.
  \item フラグ para-from-right が on の場合 $R \rightarrow L$ とう形の
    parmod を作り, paramodulation を実行する(para-from-alpha によって行う).
    このとき得られた導出節を paramodulants に追加する.
  \end{enumerate}
\item paramdulants を戻り値として戻る.
\end{enumerate}
\end{description}

\subsection{Demodulation}
\label{sec:demod}

demodulation は，導出された節に適用され，それに含まれるリテラルのアトムを
簡約化する．
すなわち，$l\rightarrow r$ の形をした demodulator があり，あるリテラル
$l$ が項 $t$ を副項として含む $P[t]$ の形をしているものとする．
このとき，$\sigma l = t$ となるような，変数置換があったときに，
$l$ を，$P[\sigma r]$ に書き換える．

demodulator として，$L = R$ という等式のリテラルのみからなる節が用いられる．
これを，項の書き換え規則として用いるためには，
等式の方向付けが必要である．
つまり，何らかの順序関係によって，等式の左右辺を方向付ける必要が
ある．反駁エンジンでは，この順序の判定に，単純な辞書式順と lrpo の 2種 を用意する．

本節ではこれらの順序関係と，demodulation の実行処理について定める．

\subsubsection{辞書式順による等式の順序付け}
\label{sec:order-equalities}

これは，単純な演算子名の辞書式順を元に，等式の方向つけを行うものである．
二つの項を比較する際に，
一方の項が，他方の項の副項になっているような場合，含まれている項の方が
小さいと判定する．
そうで無い場合は，左から右へ走査して行き，演算子名が異なるところで
ストップする．この演算子の順序関係が項の間の順序関係となる．
演算子の順序関係の判定は，第~\ref{sec:op-lex-precedence} 節で仕様を定めた，
op-lex-precedence を利用する．
また，変数は，そうで無い項よりも小さいと判定する．
変数同士の比較は，フラグ lex-order-vars の設定によって異なる：
\begin{description}
\item[lex-order-vars が on の場合] 変数名を辞書式順に比較する．
   この場合順序関係は全順序となる．
\item[lex-order-vars が off の場合] 異なる変数同士の比較は行わない．
   したがって順序関係は半順序である．
\end{description}
辞書式順による等式の順序付けは，フラグ order-eq が on で，lrpo が off 
の時に行われる.

order-equalities は上で述べた判定基準にしたがって，
等式左右辺の方向つけを行う．

\begin{description}
\item[入力] clause
 \begin{itemize}
 \item clause : 等式の方向つけを行う節
 \end{itemize}
\item[出力] 等式リテラルの左右辺が入れ替えられることがある．この場合，
            リテラルの stat-bits の scratch-bit が on になる．
            結果として等式の左辺が右辺より大きい場合は，
            stat-bits の oriented-eq-bit が on になる．
\item[処理]
  \begin{enumerate}
  \item clause の各 equality リテラル $i$ について，上で述べた基準にしたがって
    左右辺の大きさを比較する．
  \item 左辺が右辺より大きかった場合
    
    リテラルの oriented-eq-bit を on にする

  \item 右辺が左辺より大きかった場合

    等式の左右辺を入れ換え, さらにリテラルの scratch-bit と
    oriented-eq-bit を on にする
  \end{enumerate}
\end{description}

\subsubsection{辞書式順による項の比較 : weight-lex-order}
\label{sec:weight-lex-order}
weight-lex-order は, lrpo が off の時の dynamic demodulator の
判定に使用される, 項に関する順序つけである.

二つの項を比較する際, まず最初に項の重みによって比較し,
重い方が大きいと判定する. 項が同じ重みを持っている場合は,
前節で述べた, 辞書式順の等式の方向つけ(フラグ lex-order-vars が off の時の).
と同じ判定基準で比較する.

\subsubsection{項のLROP順の判定 : lrpo}
\label{sec:lrpo}
LRPO (lexicographic recursive path ordering) は項を比較する
方式の一つであり，重要な理論的属性として停止性をもつ順序
であるという特徴がある．

\begin{description}
\item[入力] \verb|term1  term2|
\begin{itemize}
\item term1 : 比較対象の項  
\item term2 : 比較対象の項
\end{itemize}
[出力] term1 $>$ term2 であれば \verb|t| を，さもなければ \verb|nil|.
\item[処理]
\begin{enumerate}
\item 項 term1 が変数の時，term1 が term2 に出現するものならば \verb|t|
       さもなければ \verb|nil|
\item term1 と term2 が同じオペレータの項の場合：
   \begin{enumerate}
   \item term1 の 第一副項が term2 の第1副項よりも LRPO の意味で
         大きい場合：
         \begin{itemize}
         \item term1 が term2 の2番目以降の全ての項より LRPO の意味で
                  大きければ \verb|t|, さもなければ verb|nil|
         \end{itemize}
   \item term1 の副項(arg$_i$)で, arg = term2 かあるいは arg $>$ t2
         となるような項があれば \verb|t| さもなければ \verb|nil|.
   \item 上のいずれでもなければ \verb|nil|.
   \end{enumerate}
\item term1 と term2 が異なったオペレータの項の場合：
     term1 のオペレータ op1 と term2 のオペレータ op2 の優先順位を調べる
     (op-lex-precedence による -- \ref{sec:op-lex-precedence}節を参照):
  \begin{enumerate}
  \item  op1 $>$ op2 の場合：
      \begin{itemize}
      \item term1 が term2 の副項の全てより LRPO の意味で大きかったら
            \verb|t|, さもなければ \verb|nil|.
      \end{itemize}
  \item op1 $<$ op2 の場合：
      \begin{itemize}
      \item term1 の副項(arg)で，arg $=$ term2 か ar $>$ term2 となるような
            ものがあった場合 \verb|t|，さもなければ \verb|nil|.
      \end{itemize}
  \end{enumerate}
\end{enumerate}
\end{description}

\subsubsection{LRPO による等式の順序付け}
\label{sec:order-equalities-lrpo}

order-equalities-lrpo は LRPO 順で等式の向きつけを実行する．

\begin{description}
\item[入力] \verb|clause|
\begin{itemize}
\item clause : 等式の方向つけを行う節
\end{itemize}
\item[出力] 等式リテラルの左右辺が入れ替えられることがある．この場合，
            リテラルの stat-bits の scratch-bit が on になる．
            結果として等式の左辺が右辺より大きい場合は，
            stat-bits の oriented-eq-bit が on になる．
\item[処理]
clause の各リテラル $i$ について，それが equality リテラルであった
場合に，以下の処理を実行する：
\begin{enumerate}
\item $i (\alpha = \beta)$ 
      の左右辺を LRPO 順で比較する(lrpo -- 第\ref{sec:lrpo}節を参照).
\item $\alpha > \beta$ の場合，リテラルの oriented-eq-bit を on にする
\item $\beta > \alpha$ の場合，等式の左右辺を入れ換えて, リテラルを
      $\beta = \alpha$ とし，oriented-eq-bit および scratch-bit を
      on にする．
\end{enumerate}
\end{description}

\subsubsection{実行時のdemodulator判定 : dynamic-demodulator}
\label{sec:dynamic-demodulator}

フラグ dynamic-demod が on の場合, 反駁エンジンは,
全ての equality ($\alpha = \beta$)を demodulator として使えるか
どうかを判定する.

フラグ dynamic-demod あるいは, dynamic-demod-all が on になっている
状況では, 必ずフラグ order-eq が on になっているはずである
(第\ref{sec:dep-flags} 節を参照). 
demodulator の判定を行う文脈では, order-eq フラグの指定によって
既に等式の向き付けが行われている(post-process -- 第\ref{sec:post-process}
節を参照) 事を前提としている. 
この時フラグ lrpo が on の場合には, 等式の向きつけの判定として
先に述べた order-equalities-lrpo(第\ref{sec:order-equalities-lrpo}節)
が用いられ, そうでない場合は order-equalities(第\ref{sec:order-equalities}
節)が用いられる. 

dynamic-demodulator はこのような状況で, 既に等式の向きつけが済んでいる
節が demodulator として使えるかどうかを判定する.

\begin{description}
\item[入力] clause
\begin{itemize}
\item clause : 判定対象の節. 単一節(リテラルを一つしか含まない節)で
  なければならない.
\end{itemize}
\item[出力] 判定結果をあらわすキーワード. 以下のものがある

\begin{tabular}{|l|l|}\hline
:normal  & 通常の demodulator として使える節である \\
:order-dep & 順序に依存する demodulator である \\
 nil  & demodulator としては使用出来ない節 \\\hline
\end{tabular}       

\item[処理]
  \begin{enumerate}
  \item 節が正の equality 節でなければ, 戻り値 \verb|nil| として戻る.
  \item 節のリテラル $l (\alpha = beta)$ に関して以下の判定を実行する：
    \begin{description}
    \item[フラグ lrpo が off の場合]
      \begin{enumerate}
      \item $\beta$ が $\alpha$ の副項であれば :normal とする
      \item weight-lex-order (第\ref{sec:weight-lex-order}節) の
        意味で $\alpha > \beta$ かつ $vars(\alpha) \supseteq vars(\beta)$
        ならば,
        \begin{enumerate}
        \item フラグ dynamic-demod-all が on であれば :normal とする
        \item dynamic-demod-all が off で $wt(\beta)\leq 1$ ならば
          :normal とする
        \item それ以外の場合は nil とする
        \end{enumerate}
      \item フラグ dynamic-demod-lex-dep と dynamic-demod-all の
        両方が on のとき, $\alpha$ と $\beta$ が変数を除外すれば,
        構文的に同一の項である場合に :order-dep とする.
      \item それ以外の場合は nil とする
      \end{enumerate}
    \item[フラグ lrpo が on の場合]
      \begin{enumerate}
      \item $l$ の oriented-eq-bit が on の場合(等式の向きつけが
        行われている), :normal とする.
      \item フラグ dynamic-demod-lex-op が on の場合,
        $vars(\alpha)\supseteq vars(\beta)$ :order-dep とする.
      \item それ以外の場合は nil とする
      \end{enumerate}
    \end{description}
  \end{enumerate}
\end{description}
上の処理で, $vars(t)$ は, 項 $t$ に出現する変数の集合を意味する.

\subsubsection{項の demodulation : demod-atom}
\label{sec:demod-atom}

demod-atom は項を与えられて, それに適用可能性のある 
各 demodulator を全て施し, 項の書き換えを実行する.
項の書き換え処理は CafeOBJ インタプリタの書き換えエンジンのそれと
全く同じように出来るので，実装にあたってはそれを参考にする．

\begin{description}
\item[入力] atom
  \begin{itemize}
  \item atom : demodulation 対象の項
  \end{itemize}
\item[出力] demodulation が行われた場合, 項が破壊的に書き換えられる.
  統計情報の rewrites が書き換えの回数分増やされる.
\item[処理]
  \begin{enumerate}
  \item atom の副項に対してこの処理を再帰的に適用し, 副項の
    demodulation を行う
  \item atom の演算子をキーとして demodulator の索引テーブル
    *demodulators* から, 適用の可能性のある demodulator の
    リストを得る
  \item 各 demodulator に関して
    \begin{enumerate}
    \item demodulator を atom に適用する
    \item 書き換えが行われたら, 統計情報 rewrites を 1 増やす
    \end{enumerate}
  \end{enumerate}
\end{description}

\subsubsection{節の demodulatoin の実行 : demodulate-clause}
\label{sec:demodulate-clause}

demodulate-clause は指定の節に対する demodulation を実行する.

\begin{description}
\item[入力] clause
\item[出力] demodulation が実行された場合, 
  clause に含まれるリテラルのアトムが書き換えられ,
  統計情報 rwrites が書き換え実行回数分増やされる.
\item[処理]
  \begin{enumerate}
  \item 節の各リテラルのアトムに対して demodulation を行う
  (demod-atom -- 第\ref{sec:demod-atom}節を参照)
  \item demodulation が行われたならば，
  clause の parent スロットに，導出履歴として，
  `((:demod-rule 適用されたdemodulatorに節識別子のリスト))'
  と追加する．
  \end{enumerate}
\end{description}

\subsubsection{Back Demdulation の実行 : back-demodulate}
\label{sec:back-demodulate}

back demodulation とは，導出された節が正の単一の equality 節
(一つの $\alpha = \beta$ の形のリテラルのみからなる節) で
あった場合に，それを demodulator として用いて，usable および
sos に含まれる全ての節に関して demodulation を実行するものである．

導出節が demodulator として適切なものかどうかの判定は，
導出節に対する前処理(pre-process -- 第\ref{sec:pre-process}節
を参照)で，dynamic-demodulator (第\ref{sec:dynamic-demodulator} 節)
によって実行されている．

back-demodulate は demodulator として適すると判定された節から
作られた demodulator のリストを与えられ，sos および usable の各節に
対して demodulation を実行する．

\begin{description}
\item[入力] \verb|demod-list clause input? list|
  \begin{itemize}
  \item demod-list : (clause . demodulator) の形をした，節とそれから
    作られた demodulator の対のリスト
  \item clause : 導出節
  \item input  : clause が入力節なら \verb|t| さもなければ \verb|nil|
  \item list   : clause が属する節集合を示すキーワード．:usable なら
    usable, :sos なら sos.
  \end{itemize}
\item[出力] usable および sos に 属する節の中で，demodulation されて，
  破壊的に変更される節があるかもしれない．
  項の書き換え回数の分だけ統計情報 rewrites が増やされる．
\item[処理]
  \begin{enumerate}
  \item demod-list を clause をキーとして探し，clause に対応した
    demodulator が生成されているかどうかを調べる．
  \item demodulator があったら，sos および usable に含まれる各
    節に対して，この demodulator を適用する．
    demodulate されたならば，
    \begin{enumerate}
    \item フラグ print-back-demod が on，もしくは引数の input? が
      非\verb|nil| であれば，
      back demodulate したことを利用者に表示する．
    \item 統計情報 cl-back-demod を 1 増やす
    \item demodulate された節の parents スロットに，導出履歴として
      ((:back-demod-rule 引数のclauseの節識別子))
      を追加する．
    \end{enumerate}
  \end{enumerate}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\part{仕様検証システム}
\label{sec:spec-check-system}

仕様検証システムの目的は，ソフトウェアの仕様化部品(実装に振舞仕様が関
連づけられたもの)が与えられたときに，それが要求(振舞)仕様を満たしてい
るかどうかを形式的に検証するものである．検証においては，前節で述べた反
駁システム(反駁エンジン)が用いられる．

ここでは仕様検証システムの機能仕様および構成について定める.


\section{仕様検証システムの機能と構成}
\label{sec:spec-check-function}

図~\ref{fig:spec-check-arch}に仕様検証システム
(図の\textbf{spec. varification system})の構成を示す.

\begin{figure}[htbp]
  \begin{center}
    \epsfbox{spec-check-arch.eps}
    \caption{仕様検証システムの構成}
    \label{fig:spec-check-arch}
  \end{center}
\end{figure}

以下でシステム構成図~\ref{fig:spec-check-arch}を参照しつつ, 仕様検証システムの
機能を説明する.

仕様検証システムの起動は, 利用者あるいは外部のシステム(図の\textbf{users/external
systems}) から(拡張された) CafeOBJ インタプリタ(図~\ref{fig:spec-check-arch}
の\textbf{CafeOBJ command interpreter}) に与えられた新規のコマンド
(第 ~\ref{sec:spec-check-new-commands} を参照) によって起動される.

システムが行うことは, 要求仕様 $M$ (図の \textbf{Module M}) 
に対する部品仕様 $N$ (図の \textbf{Module N}) の検証である.
この検証は以下の２段階で行われる：
\begin{enumerate}
\item $M$ から $N$ へのシグニチャマッチング

  これは部品仕様 $N$ が要求仕様 $M$ で定められている機能を果たすための
  構文要素を備えているかどうかを検査するものである.
  図~\ref{fig:spec-check-arch}の\textbf{Signature Matching} が, この
  検査を実行する.
  可能な場合には $M$ のシグニチャから $N$ のシグニチャへの写像
  (シグニチャ射 -- 図の \textbf{Signature Morphism})が生成される．
  
  シグニチャ射が一つも存在しない場合は，部品仕様 $N$ が要求仕様 $M$ の機能を
  果たすことは不可能であるので，仕様検証はこの時点で失敗を報告し終了する．
  なお，シグニチャ射は複数存在することがある．

  振舞仕様におけるシグニチャは，オブジェクトにおけるメソッド及び属性に対
  応すると考えてよい．シグニチャマッチングを行うには，どのメソッド／属性
  がどのメソッド／属性に写像可能かを，ソート情報をもとに逐一調べていけば
  よい．これは一般に簡単な問題ではないが，ソート名の同じ可視ソートは同
  じデータ型を意味するものと仮定することで，単純な文字列マッチングの問題
  に還元され，高速な実装が可能となる．

\item $M$ から $N$ への詳細化検証

  これは1で得られたシグニチャ射による構文変換によって，部品仕様 $N$ が要求
  仕様 $M$ の機能を実際に果たすかどうかを検証するものである．$M$ の等式それぞ
  れをシグニチャ射で変換し，それが $N$ においても成り立つかどうかを証明して
  いく. 図~\ref{fig:spec-check-arch} の \textbf{Refinement Check} がこの
  検証を実行する.

  検証する $M$ の等式が，通常の等式あるいは公理であるか，または，振
  舞等式であるかによって以下のように処理が異なる．

  \begin{description}
  \item[通常の等式または公理の場合]
    変換された等式／公理の否定を $N$ の仕様に加え，それから反駁が得られるかど
    うかを 反駁エンジン(図の\textbf{Refutation Engine}) を用いて検証する．
    反駁が得られればこの等式に関する詳細化検証は成功する．

  \item[振舞等式の場合]
    変換された等式について，双対帰納法(coinduction)を実行する．双対帰納法
    が成功すれば，この等式に関する詳細化検証は成功する．双対帰納法について
    は第IV部のモデル検査システム(図の\textbf{Model Check System})を参照のこと．

  \end{description}

  \begin{quotation}
    なお現在のところ，条件付き振舞等式の条件部は全て通常の等式
    (隠蔽ソートの等式であっても)であるとして処理されている．
    条件付き振舞等式については，その記述や検証の方法に関する理論的研究が必要であり，
    仕様検証システムにおける実装についても，今後の課題として残されている．
  \end{quotation}

  $M$ の全ての等式について検証が成功すれば，$M$ から $N$ への詳細化検証は成功で
  ある．ただし，一般に一階述語論理における定理証明は決定不能であるので，
  詳細化検証が定められた計算資源(計算時間，メモリ使用量など)の上限を超え
  た場合には，結果を不明として報告し終了する．ただしこの場合でも，どの等
  式の検証が成功しなかったかなどの情報がユーザーに提示される．

\end{enumerate}

\section{仕様検証システムの新規コマンド}
\label{sec:spec-check-new-commands}

本章では仕様検証システムで導入される新規コマンドについて定める．
新規のコマンドは次の2つである：
\begin{description}
\item[シグニチャマッチングの指示]
  2つのモジュールを指定して, それらの間でのシグニチャマッチングを行うことを
  指示する. 構文は次の通り：
\begin{verbatim}
  sigmatch <モジュール式-1> to <モジュール式-2>
\end{verbatim}
  \verb:<:モジュール式-1\verb:>: で指定されるモジュールから,
  \verb:<:モジュール式-2\verb:>: で指定されるモジュールへの,
  可能なシグニチャ射を全て求め, 結果を利用者に提示する.
  モジュール式の構文は, CafeOBJ 言語の仕様に従う.

  CafeOBJ では, シグニチャ射のことを \textbf{view} と呼ぶが,
  view には名前がつけられ, その名前で参照することが出来るようになっている.
  sigmatch では, 構成出来た view(シグニチャ射)の各々に対して適当な名前をつけ,
  利用者にはこの名前のリストを提示する. 
  view を構成することが出来なかった場合には, 空のリストを表示する.

  この構文に対応した ADT 定義は次の通りとする：
\begin{verbatim}
(defterm sigmatch (%script)
  :visible (mod1 mod2)
  :eval eval-pn-sigmatch)
\end{verbatim}

\item[詳細化検証の指示]
  sigmatch コマンドの結果で得られた view の名前を指定して, 詳細化の検証を
  行う事を指示する. 構文は次の通りである.
\begin{verbatim}
  check refinement <view名>
\end{verbatim}
  検証の結果が成功であれば, ``ok'' と表示し, 結果が失敗あるいは不明の場合には
  ``ng'' と表示するとともに, どの等式の検証が成功しなかったかを表示する.

  ADT 定義は従来の CafeOBJ コマンドの check をそのまま流用する．

\end{description}

\section{シグニチャマッチング}
\label{spec:signature-matching-proc}

\subsection{シグニチャマッチングの考え方}
シグニチャマッチングは仕様間での構文的な対応性を検査するもの,
具体的には仕様間でのシグニチャ射を求めるものである.

我々のシステムにおいては CafeOBJ モジュールによって仕様を記述する.
CafeOBJ モジュールによって記述される仕様は, $(S,\Sigma,E)$ の形を
している. ここで $(S, \Sigma)$ がシグニチャであり, $S$ はソートの集合,
$\Sigma$ は引数および結果が $S$ のソートに含まれるような
オペレータの集合である. また, $E$ はモジュールで宣言された公理の
集合であり, $\Sigma$ に含まれる演算が満足しなければならない性質を記述
したものである. 

シグニチャマッチングは, 二つのモジュール $M$ と $N$ を
与えられて, $M$ から $N$ に対する可能なシグニチャ射を全て計算する.
$M$ のシグニチャを $(S,\Sigma)$，$N$ のシグニチャを $(S',\Sigma')$ とする.
シグニチャ射とは, $(S,\Sigma)$ から $(S',\Sigma')$ への写像 
$V: (S,\Sigma) \rightarrow (S',\Sigma')$ であり,
$V$ は二つの単射の関数
$$
\begin{array}{lll}
 V: S &\rightarrow& S'\\
 V: \Sigma &\rightarrow&\Sigma'\\
\end{array}
$$
から構成される. ここで, $\Sigma$ に含まれる各オペレータ
$f: s_1\ldots s_n \rightarrow s$ に関して,
$V(f): V(s_1)\ldots V(s_n)\rightarrow V(s)$ が $\Sigma'$ の
オペレータでなければならない. 一般にこれを満足する満足するような
写像は複数あり得るので, 構成可能なシグニチャ射も一般に複数である.

可能なシグニチャ射を全て求めるのは, 一般に簡単な問題ではないが，
我々のシステムではソート名の同じ可視ソートは同じデータ型を意味するもの
と仮定して問題を簡単化し，高速な計算を可能としている. 
これは以下に説明する通り大きな制約ではない．

CafeOBJ ではソートの集合 $S$ は2種のソート $D$ と $H$ に区分される
($S = D \cup H$). 
$D$ に含まれるソートは可視ソート, $V$ にふくまれるものは隠蔽ソートと呼ばれる.
可視ソートは通常の静的なデータ型を表現するものであり, 
隠蔽ソートは内部状態を持つような動的なオブジェクトを表現するためのソートである. 
同じ名前の可視ソートは同一のデータ型を意味するものとみなす，ということは
対象とする部品やシステムの仕様において，データ型が固定されている
(例えばライブラリのようなものを想定する)という意味である．
我々のシステムの目的が部品検索と検証ということから，これは不自然な仮定ではない．
要求と部品の仕様は CafeOBJ で記述されるため，システム側で部品の仕様に出現する
であろうデータ型から CafeOBJ へのマッピングを用意しておけば良い．
例えば CORBA などでは IDL を用いて部品のシグニチャが記述されるが，
これに関しては表~\ref{tab:idl-cafeobj}に示すようなマッピングが可能である．
{\sloppy
\begin{table}[htb]
  \begin{center}
    \begin{tabular}{|l|l|}\hline
      IDL & CafeOBJ\\\hline\hline
      interface & module\\\hline
      methods, attributes & bop\\\hline
      enum & constants \\\hline
      struct & tuples \\\hline
      union & super sort \\\hline
      array & behavioural specification \\\hline
      short, long, float & CafeOBJ built-ins \\\hline
      char, boolean & (Common Lisp) \\\hline
      exception & constructors of error sort \\\hline
    \end{tabular}
    \caption{IDL と CafeOBJ のマッピング}
    \label{tab:idl-cafeobj}
  \end{center}
\end{table}
}

上のような制限を設ける事により，データ型(可視ソート)に関しては
単純な名前の一致関係によって写像を構成することが可能となった．
また，可視ソートの間の順序関係についても無視する事が可能となった．
結果として，隠蔽ソートに関する可能な射の組合せ問題を解くだけで
良い．オペレータの引数順序の違いを考慮しても，ソート名の辞書式
順に並べることによって，基本的には単純な文字列マッチングの
問題に帰着させる事が出来る．

\subsection{シグニチャマッチングの起動 : eval-pn-sigmatch}
\label{sec:eval-pn-sigmatch}

eval-pn-sigmatch はコマンドインタプリタから起動され，
シグニチャマッチングを実行する sigmatch (第~\ref{sec:sigmatch}) を
起動し，結果として得られる view の名前のリストを利用者に提示する．

\begin{description}
\item[入力] adt
  \begin{itemize}
  \item adt : sigmatch コマンドの ADT インスタンス
  \end{itemize}
\item[出力] シグニチャマッチの結果が提示される.
\item[処理]
  \begin{enumerate}
  \item adt から view のソースとなるモジュール式, ターゲットとなる
    モジュール式を得る
  \item それぞれのモジュール式を評価し, 対応するモジュールの内部
    構造を得る.

    このとき評価に失敗した場合はエラーとし, エラーメッセージを
    表示するとともに, 処理を中断して戻る.

  \item 上で得たモジュールを引き数として sigmatch を起動し, 
    生成された view の名前のリストを得る.
    
  \item 名前のリストを印字する.

  \end{enumerate}
\end{description}

\subsection{シグニチャマッチングの実行 : sigmatch}
\label{sec:sigmatch}

sigmatch は, シグニチャマッチングの実行本体であり,
module1 から module2 への可能な仕様射(view)を全て計算し,
名前をつけて, CafeOBJ インタプリタの内部データベースに登録する.
結果として生成された view の名前のリストを返す.

\begin{description}
\item[入力] \verb|module1    module2|
  \begin{itemize}
  \item module1 : ソースモジュール
  \item module2 : ターゲットモジュール
  \end{itemize}
\item[出力] 生成された view の名前のリストを返す. 無い場合には
  空リストを返す.
\item[処理]
  \begin{enumerate}
  \item[1] module1 と module2 に含まれる隠蔽ソートに
    ついて, $((h1_1 . h2_1) \cdots (h1_n . h2_n))$
    の形の対のリストを作る.
    ここで $h1_i$ は, module1 に含まれる隠蔽ソート,
    $h2_i$ は module2 に含まれる隠蔽ソートである.

    このような対のリストを全ての隠蔽ソートの組合せで作成し,
    それらのリストを sal としてセットする.
    したがって sal には隠蔽ソートに関して可能な写像が
    全て網羅されている.

  \item module1 に含まれる全てのオペレータの集合を
    OPS1 とする．また module2 のそれを OPS2 とする.

  \item[2] sal の各隠蔽ソート写像 $sal_i$ に関して以下の処理を
    実行する：
    \begin{enumerate}
    \item omap を空リストに初期化する.
    \item OPS1 の各オペレータ $op_i$ に関して以下の処理を
      行う：
      \begin{enumerate}
      \item オペレータ $op_i$ のアリティ $ar1_i$ (引数のソート列)を $sal_i$ 
        によって写像したソート列 $ar2_i (= sal_i(ar1_i))$ を作る.

        この時, ソート $s$ が $sal_i$ の定義域に無い場合は,
        $sal_i(s) = s$ とする(以下同様).

      \item オペレータ $op_i$ のコアリティ $c1_i$ (値のソート)を
        $sal_i$ によって写像し, $c2_i$ を得る. 
      \item アリティとして $ar2_i$ を, コアリティとして $c2_i$ を持つ
        ようなオペレータを OPS2 の中から探し, 見付かったオペレータの
        リストを ol とする.
        この時, 既に omap に見付かったオペレータが登録されていた
        場合は ol には入れない. 

        上の探索でアリティの一致を検査する場合, アリティを
        ソート名の辞書式順でならび替えた結果で比較する.

      \item ol が空ならば, 今回使用したソートの写像 $sal_i$ は失敗とし,
        未だ試みていない $sal_j$ に関して, ステップ2から再試行する.

      \end{enumerate}
      \item 見付かった $sal_i$ とオペレータの写像の対を omap に入れる
    \end{enumerate}
    \item omap に入っているソート写像とオペレータ写像の対それぞれについて：
          ユニークな view 名をつけた view を作成し，CafeOBJ インタプリタの
          内部データベースに登録する．

          view の生成は，CafeOBJ インタプリタの create-view 関数を用いて行う．
   \item 作成した view の名前のリストを返す．
  \end{enumerate}
\end{description}

\section{詳細化検証}
\label{spec:refinement-check-proc}

詳細化検証の方式については, 既に第\ref{sec:spec-check-function}節で
説明した. 本章では詳細化検証の実行モジュールについて, 仕様を定める.

\subsection{詳細化検証の起動 : pn-check-refinement}
\label{spec:pn-check-refinement}

pn-check-refinement はコマンドインタプリタから, 詳細化検証コマンド
(check refinement) に対応する ADT の評価器として起動され,
実行本体である check-refine (第\ref{sec:check-refine}節を参照) を
起動し, その結果を利用者に提示する.

\begin{description}
\item[入力] adt
  \begin{itemize}
  \item adt : check コマンドの ADT
  \end{itemize}
\item[出力] 結果が OK ならば ``yes'' を, NG ならば ``no'' を表示すると
  ともに, 検査を通らなかった公理を表示する.
\item[処理]
  \begin{enumerate}
  \item adt から view 名を取り出し, これを引数として check-refine を
    起動する
  \item 結果が ok なら ``yes'' を印字する
  \item 結果が ng なら ``no'' を印字する.
    また, check-refine から返される, 検証に失敗した公理を全て印字する.
  \end{enumerate}
\end{description}

\subsection{詳細化検証実行本体 ：check-refine}
\label{sec:check-refine}

check-refine は詳細化検証の実行本体モジュールである.
既に述べた通り, 検証の実行には反駁エンジンを使用するが,
その時の実行文脈とするモジュールが必要となる.
これは, ``( refinement check )'' という名前の組み込みのモジュール
を用いる. これは反駁エンジンのための prelude ファイル ``fopl.mod''
(第\ref{sec:embedding}節の新規組み込みモジュールの節を参照) 
で定義されている. 
詳細化検証ではこのモジュールを使い回しする. 以下ではこのモジュールを
「詳細化検証用モジュール」と称する.

\begin{description}
\item[入力] view の名前
\item[出力] ok の場合は \verb|nil| を, ng の場合は, 検証できなかった
  公理のリストを返す.
\item[処理]
  \begin{enumerate}
  \item CafeOBJ の内部データベースから引数の view 名で view の本体を得る.
  \item view 本体から, ソースモジュール source とターゲットモジュール
    target を取り出す.
  \item ng-axioms を空リストに設定する.
  \item 現在のフラグとパラメータオプションの値を保存する.
  \item source の各公理 $ax_i$ に関して以下の処理を実行する：
    \begin{enumerate}
    \item 詳細化検証用モジュールを初期化し,
      taget, および FOPL-CLAUSE モジュールを輸入する.
    \item $ax_i$ を view によって target の公理へ写像し, $ax'_i$ とする.
    \item $ax'_i$ の否定をとり, さらに節形式へ変換する.
    \item 変換された節を詳細化検証用モジュールに対応した psystem の
      axioms スロットに追加する.
    \item 反駁エンジンを起動し, $ax'_i$ の反駁を試みる.
      この時推論ルールは, 自動モードで行う.
    \item 反駁エンジンの戻りコードが :max-proofs-exit でない場合は
      $ax_i$(target へ写像する前のもの) を ng-axioms へいれる.
    \end{enumerate}
  \item フラグ, パラメータの値を元に戻す.
  \item ng-axioms を返す．
  \end{enumerate}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\part{モデル検査システム}

ここではモデル検査システムの機能仕様および構成仕様について定める.

\section{モデル検査システムの機能と構成}
\label{sec:model-check-func}

モデル検査システムの目的は，仕様化部品の組み合わせで構成されたシステム
が，デッドロック不在やデータ整合性といった安全性，トランザクション性な
どの活性等の性質を満たすことを，網羅的に検査することである．このような
システム全体の動的な性質を，各部品の仕様から演繹的に導くことは不可能で
あるので，前述の仕様検証システムとは別にモデル検査システムが必要である．
仕様検査システムで触れた, 双対機能法(co-indution)も一種の安全性とみなす
ことが可能であるので，モデル検査システムは振舞等式の詳細化検証にも用いられる．

モデル検査の基本機能は, システムの初期状態(始状態)と検査すべき性質が
与えられ, 始状態から遷移可能な全ての状態について, 
与えられた性質が満足されるかどうかを検査することである. 
この場合の結果としては次の3通りが考えられる：
\begin{description}
\item[正常に終了]
  この場合，システムは与えれた性質を満たすことが保証される．

\item[反例を発見して終了]
  この場合，システムの実行系列の中に与えられた性質が成立しないような反例
  が存在することが証明される．モデル検査システムは，その始状態からの実行
  系列と反駁証明から, 反例として返す．

\item[結果不定のまま終了]
  前述の詳細化検証と同じく，モデル検査は一般に決定不能であるので，事前に
  定められた計算資源の使用量を超過した場合には，モデル検査システムは結果
  不定のまま終了する．この場合でも，探索が終了した実行系列についての情報
  は提示する．

\end{description}

\section{モデル検査の方式}
\label{sec:how-to-model-check}

振舞仕様におけるモデル検査については，システムの性質の記述，及び検査ア
ルゴリズムに関してμ計算を参考としている．μ計算系における不動点演算子
を用いることで安全性や活性以外の性質も柔軟に記述できる上に，モデル検査
アルゴリズムも不動点の繰り返し計算として定式化されるので，反駁エンジン
を用いた述語計算による実装が可能となる．

詳細を，安全性のモデル検査を例にとって説明する．証明したい安全性を示す
述語をP(X:h) (X は隠蔽ソート h の変数)とすると，安全性 P のモデル検査
(後向きの)手続きは次のような述語に関する漸化式 $p_n$ で与えられる．ここで，
隠蔽ソート上の述語が対応するシステムの状態集合の記号表現を与えている点
に注意されたい．

\begin{itemize}
\item $\mathtt{p_0(X)=\neg P(X)}$
\item $\mathtt{p_{n+1}(X)=p_n(X)\vee pre(p_n(X))}$
\item $\mathtt{\neg p_n(init)}$かどうかを各ステップごとに調べる
\end{itemize}

ただし init はシステムの始状態を表す(隠蔽ソート h の)定数記号であり，
状態 P(X) の前状態 pre(P(X)) は，全てのメソッド m について
$\mathtt{(\forall Y) P(m(Y,X))}$ の選言(disjunction) をとった述語(論理
式)として定義される．ただし，Y は m のアリティに適切なソートを持つ限量
変数の集合である．直観的には，$p_n(X)$ は，そこから n ステップで安全性 
P(X) を破ることができるような状態の集合を表している．

上述の漸化式は収束することが保証されているいるものの，有限ステップで収
束する(ある n について $p_{n+1} = p_{n}$)とは限らない．したがって，アル
ゴリズム化する場合には，１)有限で収束，２) $p_n(init)$ となって反例発見，
３)どちらも不明，の３通りの結果が得られ，これは上述のモデル検査システ
ムの実行結果に対応する．

前向きのモデル検査手続きについても，状態 P(X) の次状態 post(P(X))を定
義すれば同様の漸化式として定式化できる．このように，始状態(init)，状態
集合(P(X))，次状態(post(P(X)))，前状態(pre(P(X)))が定義されていれば，
μ計算におけるモデル検査手続きを 反駁エンジン を用いた述語計算として行うこ
とができる．いわば，この点が本モデル検査システムの核心である．

\section{双対機能法の実行方式}
\label{sec:how-to-co-induction}

仕様検証システムにおける振舞等式の詳細化検証に必要な双対帰納法を行うに
は，状態の対(即ち関係)を状態とみなして安全性モデル検査を実行すれば良い．

例えば，振舞等式$s\sim t$を証明するには，状態の対 (s,t) を始状態として，
属性同値関係$\mathtt{{=}{*}{=}}$(全ての属性の値が同じ)が安全性を持つこ
とを示せば良い．これは以下の関係に関する漸化式として定式化でき，前述の
安全性モデル検査と同様に 反駁エンジン を用いて処理することができる．

\begin{itemize}
\item $\mathtt{r_0(X,Y)=\neg(X{=}{*}{=}Y)}$
\item $\mathtt{r_{n+1}(X,Y)=r_n(X,Y)\vee pre(r_n(X,Y))}$
\item $\mathtt{\neg r_n(s,t)}$かどうか各ステップごとに調べる
\end{itemize}

\section{モデル検査での新規コマンド}
\label{sec:model-check-new-command}

モデル検査では，CafeOBJ に従来からある check コマンドを拡張した
次に示すコマンドを導入する：

\begin{verbatim}
 check invariance <述語名> from <初期状態>
\end{verbatim}

ここで，$<$述語名$>$ は，ある隠蔽ソート $H$ に関する述語
$P(X:H)$ の名前である．
$<$初期状態$>$ は，$H$ の初期状態を表現する定数オペレータの名前である．

このコマンドの動作は次の通りである：
\begin{enumerate}
\item 指定された述語 $P$ に関して，$P(\verb|<|初期状態\verb|>|)$ が
      成り立つかどうかを調べる．
\item $H$ に関する全てのメソッド $m_i$ に対して，
      $\forall(Y) . P(m(X, Y))$ が成り立つかどうかを調べる．
\end{enumerate}

上の個々に対して，成立/不成立の結果はその都度利用者に表示される．

\section{モデル検査の起動}
\label{sec:pn-check-invariance}

pn-check-invariance は "check invariance" コマンドの
ADT 評価器として起動され，モデル検査の実行本体の起動を行う．

\begin{description}
\item[入力] args
\begin{itemize}
\item args : checkコマンドの引数列
\end{itemize}
\item[出力] 戻り値に意味はない．
\item[処理]
\begin{enumerate}
\item args を走査し，述語名，初期状態を表すオペレータを得る．
\item 上で得た引数情報をもとに, モデル検査実行本体(do-invariance-check
      --- 第\ref{sec:do-invariance-check}章を参照).
\end{enumerate}
\end{description}

\section{メソッドに関するモデル検査の実行 : perform-inv-check}
\label{sec:perform-inv-check}

perform-inv-check はあるメソッド $m$ に関して，ある隠蔽ソート $S$ に関する
述語 P(X:S) が，$m$ の適用結果に対しても成立するか(満足されるか否か)
を調べる．
つまり，$\neg(\forall Y. P(m(X,Y))$ が反駁出来るかを，反駁エンジンを
用いて調べる．ここで $Y$ は $m$ のアリティに適当なソートを持つ
限量変数の集合である．例えば $m$ が隠蔽ソート $H$ に関して次のように
宣言されているとすると：
\begin{verbatim}
  bop m : S1 H S2 -> H .
\end{verbatim}  
上の $m(X,Y)$ は，\verb|m(X1:S1, X:H, X2:S2)| のようなパターンの項となる．

反駁エンジンを使用する際，その実行文脈となるモジュールは，
``( invariance check )''という名前の組み込みモジュールであり，
prelude ファイル ``fopl.mod'' で定義されている
(第\ref{sec:embedding}節の新規組み込みモジュールの節を参照)．
モデル検査ではこのモジュールが使い回しされる．
以下でこのモジュールのことを，「モデル検査用モジュール」と称する．

\begin{description}
\item[入力] \verb|module  predicate  method|
\begin{itemize}
\item module : モデル検査の対象とするモジュール
\item predicate : 隠れソートに関する述語(オペレータ)
\item method : 検査するメソッド(オペレータ)
\end{itemize}
\item[出力] 反駁エンジンからの戻り値をそのまま返す
\item[処理]
\begin{itemize}
\item 現在のフラグとパラメータの値を保存する．
\item モデル検査用モジュールを初期化し，これに, 引数の module と
      FOPL-CLAUSE を輸入する．
\item 述語 P とメソッド $m$ に関して，$\neg(\forall[Y] P(m(X,Y)))$ 
      の形の FOPL 文 $inv$ を作成する．
\item $inv = true$ の形の等式を作成し，モデル検査用モジュールの公理として
      追加する．
\item 推論ルールを自動モードにし，モデル検査用モジュールを実行文脈として
      反駁エンジンを起動する．
\item フラグとパラメータの値を保存したあったものに戻す．
\item 反駁エンジンからの戻り値を返す．
\end{itemize}
\end{description}

\section{モデル検査の主モジュール : do-invariance-check}
\label{sec:do-invariance-check}

do-invariance-check はモデル検査の主モジュールであり，
前の節で述べた，perform-inv-check によって隠蔽ソート $H$ に
関する述語 $P(X:H)$ が $H$ に関する全てのメソッド $m_i$ の
適用に関して満足されるか否かを調べる．

\begin{description}
\item[入力] \verb|module  predicate  init|
\begin{itemize}
\item module : 検査を実行するモジュール
\item predicate : 隠蔽ソートに関する述語(オペレータ)
\item init : 隠蔽ソートの表現する状態集合の初期状態をあらわす
      オペレータ
\end{itemize}
\item[出力] 成功なら \verb|t|，さもなければ \verb|nil| を返す．
\item[処理]
\begin{enumerate}
\item ok を \verb|t| に設定する．
\item init に関して，P が満足されるかを調べる(perform-inv-check
      による --- 第\ref{sec:perform-inv-check}節を参照 --- 以下同様).
      
      結果が :max-proofs-exit ならば，成功した旨を表示，そうでなければ
      失敗を表示する．また，失敗の場合は ok を \verb|nil| に設定する．

\item init のコアリティのソート(隠蔽ソート) $H$ に対応する全ての
      メソッド $m_i$ に付いて，以下を実行する：
      \begin{enumerate}
      \item $m_i$ に関して，P が満足されるかを調べる.
      
      結果が :max-proofs-exit ならば，成功した旨を表示，そうでなければ
      失敗を表示する．また，失敗の場合は ok を \verb|nil| に設定する．
      \end{enumerate}
\item ok の値を戻り値として返す．
\end{enumerate}
\end{description}


\newpage
%%% BIB
\begin{thebibliography}{?-}

\bibitem{chang-lee} Chang, C. and Lee. R.C.,
  \textsl{Symbolic Logic and Mechanical Theorem Proving},
  Academic Press, 1973

\bibitem{otter} McCune, W.W.,
  \textsl{Otter 3.0 Reference Manual and Guide},
  \verb|http://www.info.mcs.anl.gov|

\end{thebibliography}
\end{document}

