\chapter{反駁エンジン}
\label{sec:intro-refutation-engine}

本章ではPigNoseシステムの核である反駁エンジンについて説明する．
本章の内容は読者が導出原理(resolution principle)に基づいた定理自動証明
についての基本的な知識を有する事を仮定している．
付録~\ref{sec:resolution-principle}~に簡単な解説を載せたが，
不案内な読者は文献(\cite{chang-lee}等)を参照して欲しい．
また付録~\ref{sec:desc-resolution} に
ここで使い方を説明する反駁エンジンが使用している各種の推論ルールについ
て概説があるので必要に応じてそれも参照されたい．
% 反駁エンジンが行うresolutionは\textbf{sos 戦
%   略 --- set of support strategy} と呼ばれる方式のものである．これにつ
% いては第~\ref{sec:}章の概説を参照されたい．

\section{反駁エンジンの機能}
\label{sec:func-abst}

最初に述べた通り反駁エンジンは等号を含む一階述語論理系の上での定理証明
機能を提供するものであるが, これをもう少し具体的に述べると次のようになる：
\begin{itemize}
\item CafeOBJ モジュールで宣言された公理を，等号を含む一階述語論理(以降
  これを \texttt{FOPL}と略称する)の論理式とみなし,  
\item そのモジュールの文脈において，与えられた述語がモジュールの公理か
  らの論理的帰結となるかどうかを反駁法によって証明する.
\end{itemize}

前述のように反駁には導出原理 (resolutio principal)~\cite{chang-lee}を
用いるが, 等号を扱うための paramodulation 機構(\ref{sec:paramod}章)が
推論ルールとして含まれている. 
導出に用いられる推論ルールには基本的な binary resolution
(\ref{sec:binary-res}章) に加えて, (negativ/positive) hyper resolution
(\ref{sec:hyper-res}章), また unit resulting resolution が用意されてい
る. また, 論理式に含まれる関数適用フォームの簡単化機構として
demodulation(\ref{sec:demod}章)が組み込まれている.
% demodulation は関数フォームだけでなく論理式の書き換えにも用いることが
% 可能となっている. 
また推論戦略としては Set of Support 戦略(SOS 戦略)
を用いている\footnote{SOS戦略及び反駁エンジンの動作については
第~\ref{sec:infer-process} に概要を示した．}．

反駁エンジンを組み込んだインタプリタは, 通常の CafeOBJ インタプリタとし
てなんら変わる事無く使用できる. エンジンの機能は新規の言語要素，コマンド
群として提供される．

\section{CafeOBJモジュールの解釈}

\subsection{FOPL文}
PigNoseにおけるFOPL文は通常の項と同様に CafeOBJ 項である. 
これは組み込みモジュールFOPL-CLAUSE(第~\ref{sec:builtin-fopl-clause}章
を参照)で定義されている(FOPL文の構文の詳細は第~\ref{sec:fopl-syntax}章
で説明する)が, これは従来のCafeOBJ言語による記述と出来るだけ境界なし
にFOPL文を使えるようにするための方策である.  
これを具体的に実現するため，
\begin{framed}
CafeOBJ組み込みのソート Bool を, FOPLの真偽値を表現するためのソートとし
て使用する．
\end{framed}
という方針がとられている. ソートBoolは論理演算を定義している組み込み
モジュールBOOL\footnote{実際にはBOOLからインポートされるTRUTH-VALUEで
定義されている．}で定義されているモジュールであり，CafeOBJでは
特に指定の無い限りBOOLモジュールは利用者が定義した全てのモジュールに
暗黙的にインポートされている．

このことから言えるのは
\begin{center}
\fbox{\textbf{ソートBoolのCafeOBJ項はFOPLの文(述語)と解釈される}}.
\end{center}
という事である．
その他のCafeOBJ項(組み込みソートBool以外の項)は述語の引数として出現す
るのでない限り, FOPLでの正当な式とは見なされない.
またCafeOBJ モジュールで記述された公理は, この事を基本として以下で述べ
るように解釈される.

\subsection{等式の解釈}
CafeOBJ の(条件付き)等式は, 次のような形をしている\footnote{%
CafeOBJ には \texttt{eq} または \texttt{ceq} で宣言される
可視等式と，\texttt{beq} または \texttt{cbeq} で宣言される
振舞等式の2種があるが，ここではそれらを区別せずに扱う．}

\begin{vvtm}
\begin{simplev}
        ＜左辺＞ = ＜右辺＞ if ＜条件＞ .
\end{simplev}
\end{vvtm}

これをFOPLのimplication(含意 \verb|->|)

\begin{vvtm}
\begin{simplev}
        ＜条件＞ -> ＜左辺＞ = ＜右辺＞ 
\end{simplev}
\end{vvtm}

と解釈する. 
%CafeOBJの条件部はソートBoolの項であるので, 上のような解釈は
%自然にである. 
またこれは下と等価である. 
ここで, \verb|~|はFOPL文の否定を表す論理演算である． 
また \verb+|+ は論理和を表すFOL文表現である
(表~\ref{tab:builtin-pred} を参照)．

\begin{vvtm}
\begin{simplev}
        ~＜条件＞ | ＜左辺＞ = ＜右辺＞
\end{simplev}
\end{vvtm}

ここで, CafeOBJ等式の\texttt{=}をFOPLの等号\texttt{=}と解釈している
事に注意. 
resolution を行う際には, 最後に得られた形の式を節形式\footnote{%
  述語論理における節形式とは 0 個以上のリテラルの集合であり，
  リテラルの論理和の全称閉包の事である．また，リテラルとは
  素式(原子論理式)またはその否定を言う．例えば，節形式
  $\{P(x), \neg Q(x,y)\}$ は, $\forall x \forall y (P(x)\lor\neg Q(x,y)$
  を意味する．
}
に変換して用いる. 
これはシステムが自動的に行うので, 利用者はこれに関して特に気
を使う必要はない. 等式の＜条件部＞が省略されている場合は, 単純に

\begin{vvtm}
\begin{simplev}
        ＜左辺＞ = ＜右辺＞
\end{simplev}
\end{vvtm}

というFOPLの等式となる. 

\subsection{組み込み述語の解釈(変換)}
\label{sec:bool-mod}

先にCafeOBJのソートBoolの項は, 自動的に FOPL 文とみなされると述べた. 
CafeOBJにはBoolを値のソートとするオペレータがいくつか組み込まれている. 
これらは組み込みモジュールBOOLとそのサブモジュールで宣言されて
いるものであるが, 表\ref{tab:builtin-pred}に示したようにそれらと
意味的に対応するFOPL論理結合子へとシステムが変換する.  

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{c|c}\hline
      \multicolumn{1}{G|}{CafeOBJ組み込み述語} &
      \multicolumn{1}{G}{FOPL論理結合子}\\\hline
    \texttt{\_and\_} &                 \texttt{\_\&\_} (論理積) \\\hline
    \texttt{\_or\_} &                   \verb^_|_^ (論理和) \\\hline
    \texttt{not\_} &                  \verb|~|{\texttt\_} (否定) \\\hline
    \texttt{\_implies\_}  &            \texttt{\_->\_}(含意) \\\hline
    \texttt{\_iff\_}      &            \texttt{\_<->\_} (同等) \\\hline
    \texttt{\_and-also\_} &            \texttt{\_\&\_} (論理積) \\\hline
    \texttt{\_or-else\_} &             \verb^_|_^ (論理和) \\\hline
    \texttt{\_==\_}      &             \texttt{\_=\_} (等号) \\\hline
    \texttt{\_=b=\_}     &             \texttt{\_=\_} (等号) \\\hline
    \end{tabular}
    \caption{{組み込み述語の解釈}}
    \label{tab:builtin-pred}
  \end{center}
\end{table}

また組み込みの \texttt{\_xor\_}(exclusive or) に関しては,

\begin{vvtm}
\begin{simplev}
    p xor q --> (~p | ~q)&(p | q)
\end{simplev}
\end{vvtm}

のような等価変換を行う.
なお具体的なFOPLの文法については第\ref{sec:fopl-syntax}章で説明
する．

\subsection{制約事項}
CafeOBJでは公理として条件付き等式ばかりではなく遷移規則も記述
可能であるが，これを適切に扱うことは不可能である\footnote{%
  遷移規則 $t \Rightarrow t'$ を方向つけられた関係とし，
  遷移関係の性質を公理によって表現することにより
  ある程度の表現は可能であるが，システムにとって
  遷移規則の持つ推移則を適切に扱うことは困難である．
}
このため PigNose では遷移規則による公理は無視される.
これと併せて, PigNose を利用するに当たっては以下に掲げるような制約事項が
ある：
\begin{snugshade}
\begin{enumerate}
\item 遷移規則(\texttt{trans, ctrans} によって宣言された公理)は使用できない.
\item 利用者定義のオペレータが組み込みソートBoolを引数に持っていてはな
    らない．
\item 振舞等式の\texttt{=}と可視等式の\texttt{=}とを区別しない.
\item \texttt{if\_then\_else\_fi} は使用できない.
\item メンバシップ述語 (\texttt{\_:<ソート名>}) は使用できない.
\item 組み込みの等式(Lisp関数で定義されているもの)はresolutionに
  用いることはできない．システムはこれらを無視する. 
  但しdemodulator(第~\ref{sec:demod}章)としては使用できるので, システ
  ムは自動的にこれらをdemodulatorとして使用する. 
\end{enumerate}
\end{snugshade}

\subsection{その他の CafeOBJ 組み込みモジュールの扱い}
BOOLモジュールの扱いについては第~\ref{sec:bool-mod} 節で述べたが,
ここでは, NATやSTRING等のその他の組み込みモジュールの一般的な扱いにつ
いて述べる. 現在 CafeOBJ インタプリタには以下の組み込みモジュールが提供
されている：
\begin{center}
\begin{simplev}
  NZNAT       NAT      INT      RAT      FLOAT    STRING 
  CHARACTER   2TUPLE   3TUPLE   4TUPLE   PROPC
\end{simplev}
\end{center}
これらのモジュールのうち, PROPCを例外として他の全ての組み込みモジュール
に含まれる公理は次のような取り扱いを受ける：
\begin{itemize}
\item 全ての公理は(組み込みの)demodulatorとしてのみ使われる.
\item 従って推論ルールを用いた新たな節の導出には用いられない.
\item 条件付きの等式は無視される.
\end{itemize}
モジュール\texttt{PROC}をサブモジュールに持つモジュールにおいて
PigNoseはうまく機能しない．

\section{組み込みモジュール -- FOPL-CLAUSE}
\label{sec:builtin-fopl-clause}

あるモジュールで反駁エンジンの機能を利用するには, そのモジュール
文脈で\texttt{FOPL-CLAUSE}という名前の組込みモジュールがサブモジュール
の一つになっている事)が必要である. 
このモジュールはシステムのライブラリファイル\texttt{fopl.mod}で定義さ
れ, FOPLの論理式の構文が定義されている. またシステムは, FOPL-CLAUSE
が輸入されているモジュールではPigNoseの反駁エンジンで導入された機能が
使用できるように実行環境を設定する\footnote{%
第 \ref{sec:fopl-loading} 節で述べた通り,fopl.mod は, システム
  の初期化ファイル site-init.mod に, \textbf{require fopl} というコマン
  ドをいれておく事によって, システム(CafeOBJ インタプリタ)を立ち上げる毎
  に自動的にシステムにロードされるようにする事ができる.} ．

\subsection{FOPL-CLAUSE の自動輸入}

モジュール FOPL-CLAUSE を簡便に参照するために, 新規のCafeOBJスイッチ
\texttt{iclude FOPL-CLAUSE} が用意されている.

\begin{vvtm}
\begin{examplev}
  set include FOPL-CLAUSE on   -- 自動輸入を有効にする (初期値)
  set include FOPL-CLAUSE off  -- 自動輸入を無効にする
\end{examplev}
\end{vvtm}

このフラグを\texttt{on}に設定する事によって，
モジュール内で\texttt{ax}あるいは\texttt{goal}による公理宣言
(第\ref{sec:new-construct}章を参照)が出現した場合，自動的に
FOPL-CLAUSE がそのモジュールに輸入されるようシステムが振舞う．
スイッチの初期値は\texttt{on}であり，特に理由が無い限りこれを
\texttt{off}にする必要は無い．

\section{FOPL の構文}
\label{sec:fopl-syntax}

ここではモジュール\texttt{FOPL-CLAUSE}で定義されるFOPLの構文を示す．
FOPL の文はCafeOBJ項で表現されることは既に述べた．
そのソートは\texttt{FoplSentence}と名付けられ，
下で示したCafeOBJソート宣言文に示されているように, 組み込みソート Bool
の上位ソートとして宣言されている.  
\begin{description}
   \item \textbf{FOPL文のソート宣言}
     \begin{vvtm}
     \begin{simplev}
       [Bool < FoplSentence]
     \end{simplev}
   \end{vvtm}
 \end{description}

この定義によってBoolのCafeOBJ項はFOPLの文となり，
またBool値のオペレータはFOPLの述語とみなされる．

\subsection{論理結合子の構文}

論理結合子の構文をCafeOBJのオペレータ宣言で示すと以下のようになる
(先に掲げた表~\ref{tab:builtin-pred}も参照)．

\begin{description}
   \item \textbf{論理和}

     \begin{vvtm}
     \begin{simplev}
op _|_ : FoplSentence FoplSentence -> FoplSentence {prec: 107}
     \end{simplev}
   \end{vvtm}

\item \textbf{論理積}
  
   \begin{vvtm}
     \begin{simplev}
op _&_ : FoplSentence FoplSentence -> FoplSentence {prec: 101}
     \end{simplev}
   \end{vvtm}     

\item \textbf{否定}

   \begin{vvtm}
    \begin{simplev}
op ~_ : FoplSentence -> FoplSentence {prec: 0}
     \end{simplev}
   \end{vvtm}

\item \textbf{含意}

   \begin{vvtm}
    \begin{simplev}
op _->_ : FoplSentence FoplSentence -> FoplSentence {prec: 120}
     \end{simplev}
   \end{vvtm}
 
 \item \textbf{同値}

   \begin{vvtm}
    \begin{simplev}
op _<->_ : FoplSentence FoplSentence -> FoplSentence {prec: 120}
     \end{simplev}
   \end{vvtm}
 
 \item \textbf{等号}

   \begin{vvtm}
  \begin{simplev}
op _=_ : FoplSentence FoplSentence -> FoplSentence {prec: 51}
   \end{simplev}
 \end{vvtm}
\end{description}

次に，限量子に関しては下のように定義されている．
\begin{description}
  \item \textbf{全称限量子(forall)}

    \begin{vvtm}
  \begin{simplev}
op \A[_] _ : VarDeclList FoplSentence -> FoplSentence {prec: 125}
  \end{simplev}
\end{vvtm}

\item \textbf{存在限量子(exists)}

  \begin{vvtm}
  \begin{simplev}
op \E[_] _ : VarDeclList FoplSentence -> FoplSentence {prec: 125}
  \end{simplev}
\end{vvtm}
\end{description}
ここで, \texttt{VarDeclList}は変数名あるいはon-the-flyの変数宣言
(\texttt{VAR:SORT}の形の変数宣言 -- \texttt{VAR}は変数名,
\texttt{SORT}はソート名である)
をコンマ記号(,)で区切って並べたものである. 

\subsection{述語・命題の宣言}
先に述べた通り, ソート\texttt{FoplSentence}の項がFOPL 文であり,
前節で示した論理結合子や限量子を用いて記述される．
またBool値のオペレータは一般に述語として解釈されるので,
述語や命題は通常のCafeOBJ のオペレータ宣言によって行うことが
できる. 
命題の場合は, 引数を持たない Bool の定数項として宣言すれば良い.

このためには, 下のようにCafeOBJの\texttt{pred}構文を用いるのが
便利である：
\begin{vvtm}
\begin{examplev}
  pred P1 : S1 S2           -- 2引数の述語
  pred P0 :                 -- 命題
\end{examplev}
\end{vvtm}


%%%%%
\subsection{FOPL文の記述例}

下に FOPL 文による論理式の記述例を示す.
これは 組み込みの NAT を文脈モジュールとして使用したものである.
通常記号論理で使用される構文とほぼ同様の記法で論理式が記述
できるようになっていることが了解されるであろう\footnote{%
ここで例示したように，あるモジュールで反駁エンジンを用いて何か作業を
おこないたい場合は，\texttt{open} コマンドによってそのモジュールを
文脈にするとともにオペレーションや公理の追加が可能な状態にし，
陽に\texttt{protecting(FOPL-CLASE)}とすることによって PigNoseの
機能を利用することもできる．
}．

\begin{vvtm}
\begin{examplev}
-- NAT を文脈として用いる
open NAT
-- FOPL 文の記述を可能とするために FOPL-CLAUSE を輸入する
protecting(FOPL-CLAUSE)
-- 命題, 述語の宣言
pred p : .
pred q : .
pred r : .
pred P : Nat .
pred Q : Nat .
pred R : Nat Nat .
pred S : Nat Nat .
-- Nat の 定数
op  a   : -> Nat .
-- t1 〜 t5 は CafeOBJ の let 変数.
-- 
let t1 = (p -> q) -> (q -> r) .
let t2 = \A[X2:Nat]\E[Y1:Nat]\A[X1:Nat]\E[Y2:Nat]R(X1,Y1) & S(X2,Y2) .
let t3 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) &
         (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .
let t4 = (\A[X:Nat]P(X) -> (\E[Y:Nat]R(X,Y))) |
         (\A[X:Nat]~ P(X) -> ~ (\E[Y:Nat]R(X,Y))) .

let t5 = \A[X:Nat]P(X) -> 
                   (\E[Y:Nat](R(X,Y) -> P(a)) & 
                             (\A[Z:Nat]R(Y,Z) -> P(X))) .

-- show term t1 等とすることによって, システムがパーズした
-- 項を表示することができる.
show term t4 .

\end{examplev}
\end{vvtm}

\section{FOPL 文による公理の宣言}
\label{sec:new-construct}

FOPL文による公理の宣言を可能とするため，
次に示す新規構文が導入された.
これらは反駁エンジンの実行の際にその他の CafeOBJ の通常
の公理と併せて推論に用いられる. 
ただし, CafeOBJ の簡約コマンド
(\texttt{reduce}, \texttt{breduce}, \texttt{exec}) で用いることは出来な
い. 反駁エンジンによる定理証明にのみ有効である.

\begin{enumerate}
\item 
  \begin{vvtm}
    \begin{simplev}
ax <ラベル> <項> .
    \end{simplev}
  \end{vvtm}

  \begin{itemize}
    \item \texttt{ax}は FOPL 文による公理を宣言するものである．
    \item \texttt{<項>}はソート FoplSentence の項でなければならない．
    \item \texttt{ax}で宣言された公理は従来の CafeOBJ の
      \texttt{red}コマンドや \texttt{exec}コマンドで使用される書き換え規則と
      して使う事は\textbf{できない}．
    \item \texttt{<ラベル>}は公理のラベルであり, 通常の CafeOBJ の公理のラベル
      と同じ構文とし同様に省略可能とする.
      \item $<$項$>$ の中に自由変数が出現する場合は，それらは暗黙的に
        全量限定子$\forall$で束縛されているものと解釈する．
      \end{itemize}
\item 
\begin{vvtm}
\begin{simplev}
goal <ラベル> <項> .
\end{simplev}
\end{vvtm}

\texttt{goal}は\texttt{ax} と同様であるが，\texttt{<項>} の否定を自動的
    に取るものであり, ``\texttt{ax} \verb|~| \texttt{<項>}''の簡易表記法である．

\end{enumerate}
\texttt{ax}と\texttt{goal}は従来のCafeOBJの公理宣言文(等式や遷移規則)
が出現できる場所ならばどこにでも出現して良い. 
また, CafeOBJ のモジュール表示コマンド(\texttt{show <モジュール式>})によって 
モジュール内容が表示される際には, \texttt{ax}や\texttt{goal}による FOPL
文も表示されるようになる. 

\paragraph{FOPL文による公理の記述例}
下は FOPL 文による公理宣言の例である.
ここでは整数(Int)上の大小関係(\texttt{<=})についての
公理の幾つかが FOPL 文によって記述されている.
\begin{vvtm}
\begin{simplev}
    mod! INT* {
      [ Int ]
      op 0 : -> Int
      op _+_ : Int Int -> Int
      op _-_ : Int Int -> Int
      pred _<=_ : Int Int

      vars M N : Int
      ax M <= M .
      ax 0 <= M & 0 <= N -> 0 <= M + N .
      ax M <= N -> 0 <= N - M .
    }
\end{simplev}
\end{vvtm}

上の例では ax による公理宣言全てに自由変数 M あるいは N が出現している. 
これらは先に述べた通り, 全称限量子によって暗黙的に束縛される.
従って例えば
\begin{simplev}
    ax 0 <= M & 0 <= N -> 0 <= M + N .
\end{simplev}
は,
\begin{simplev}
    ax \A[M,N] 0 <= M & 0 <= N -> 0 <= M + N .
\end{simplev}
と同等である.

\section{反駁エンジンの新規コマンド群}
\label{sec:new-commands}
ここでは新規に導入されたコマンドの全てをまとめて提示する．
個々のコマンドの詳細については後の章で順次解説する．
\begin{description}
\item[flag コマンド]
  反駁エンジンの証明戦略の設定や, エンジンの動作を制御するためのさまざまな
  フラグを設定するためのコマンドである.
  構文は次のとおり． 

\begin{vvtm}
\begin{simplev}
  <flagコマンド> :: = flag(<フラグ名>, { on | off })
\end{simplev}
\end{vvtm}

第一引数の\texttt{<フラグ名>} は設定したいフラグの名前であり，第二引数で
  フラグの on/off を設定する．フラグの種類やその意味については後述する
  (第~\ref{sec:pn-flag}章). 

\item[param コマンド]
  flag コマンドと同様に，エンジンの動作を制御するためのパラメータの設定を
  行うためのコマンドである．

\begin{vvtm}
\begin{simplev}
   <paramコマンド> ::= param(<パラメータ名>, <値>)
\end{simplev}
\end{vvtm}

\texttt{<パラメータ名>}は値を設定したいパラメータの名前，\texttt{<値>} は設
定したい値であり，整数値を指定する．設定可能な値の範囲は個々のパラメータ
毎に定められている．パラメータの種類や意味については後述する
(第~\ref{sec:option-parameters} 章)．

\item[save-option コマンド]

  現在設定されているフラグとパラメータの値を名前を付けて保存するためのコマ
  ンドである．

\begin{vvtm}
\begin{simplev}
   <save-option コマンド> ::= save-option <オプション名>
\end{simplev}
\end{vvtm}

指定の\texttt{<オプション名>}でフラグとパラメータの現在値を保存する．
  \texttt{<オプション名>} は任意の英数文字列．
  詳細は~\ref{sec:init-options}章で説明する．

\item[option コマンド]

  フラグやパラメータの値を全て初期値に戻したり，save-option コマ
  ンドで以前に保存されているフラグ/パラメータ値を現在値として設定するた
  めのコマンド．

\begin{vvtm}
\begin{simplev}
    option { reset | = <オプション名> }
\end{simplev}
\end{vvtm}

  \texttt{<オプション名>}は, 以前に save-option コマンドを用いて保存して
  おいたオプションの名前を指定する.
  \texttt{reset}を指定すると，全ての値が初期値に再設定される．
  詳細は~\ref{sec:init-options}章で説明する．

\item[db reset]

  反駁エンジンは, 文脈モジュールで推論を実行するにあたって，さまざまな情
  報を維持し管理する．`\texttt{db reset}' はこのデータベースの初期設定を行
  うためのコマンドである(CafeOBJ モジュールの公理を節形式に変換する
  のは, このコマンドが発せられたタイミングで行われる.)
  通常は推論実行コマンド `\texttt{resolve}' の直前
  でこれを行う必要がある．自動モード(フラグ auto あるいは auto3 を on)
  で推論を行う場合は不要である．

\item[list コマンド]

  フラグやパラメータ，また推論に用いる節集合(sos や usable -- 後述) の内
  容を表示するためのコマンドである．

\begin{vvtm}
\begin{simplev}
   <listコマンド> ::= list { axiom | sos | usable | flag | 
                             param | option | demod }
\end{simplev}
\end{vvtm}

それぞれの引数の値に対して表示される内容は次の通り：

 {\small
  \begin{center}
  \begin{tabular}{|lcl|}\hline
    axiom       &:& 文脈モジュールで宣言されている公理を節形式で印字\\
    sos         &:& 節集合 SOS に含まれる節\\
    usable      &:& 節集合 Usable に含まれている節\\
    flag        &:& フラグの一覧と現在の設定値\\
    param       &:& パラメータの一覧と現在の設定値\\
    option      &:& save-option コマンドでセーブされたオプション名の一覧\\
    demod      &:& demodulator 一覧 \\\hline
  \end{tabular}
  \end{center}
  }

  \begin{description}
  \item{\textbf{注意}}: flag, param, option の3つの場合を除き,
  list コマンドが有効となるのは, 先に述べたシステム初期化
  コマンド db reset が実行された後である. また, demod に関しては,
  db reset を実行時にシステムが生成した demodulator のみが表示される.
  システムはこの時点では組込みの等式(右辺側がLisp関数で記述されている
  等式)のみを, demodulator として登録する. それ以外の公理については
  システム実行中に demodulator とされるので, この時点で知る事は出来ない.
\end{description}

\item[sos コマンド]

  節集合 SOS を設定するためのコマンド．あらかじめ db reset が実行されて
  いる必要がある．構文は下の通り：

\begin{vvtm}
\begin{simplev}
   <sosコマンド> ::= sos { = | + | - } <節集合>
\end{simplev}
\end{vvtm}

第一引数の意味は以下の通り：

  \begin{center}
    \begin{tabular}{|lcl|}\hline
      \texttt{=}
      &:& sos を \texttt{<節集合>}で指定された節の集合に設定する\\
      \verb|+|     
      &:& 現在の sos の内容に \texttt{<節集合>}で指定された節を加える\\
      \verb|-|     
      &:& 現在の sos から \texttt{<節集合>} で指定された節を削除する\\\hline
    \end{tabular}
  \end{center}

  また, \texttt{<節集合>}の構文は下の通りである：

\begin{vvtm}
\begin{simplev}
   <節集合> ::= '{' <節指定> { , <節指定> }* '}'
\end{simplev}
\end{vvtm}

\texttt{<節指定>}は，公理ラベル, 節識別子，あるいは\texttt{let}変数名の
  いずれかである.  公理ラベルは, CafeOBJ の公理宣言で指定された, 公理の
  ラベル. 節識別子はシステムが節を生成する際に与えられるものであり，list
  axioms コマンド等によって知る事ができる．let 変数名が指定された場合は，
  指定の変数に束縛されている項を節形式に変換したものが用いられる．

  節指定の解釈は, 次の規則に従うものとする:
  \begin{enumerate}
  \item 節指定が数字の場合, これは節識別子であると解釈する.
  \item 数字では無い場合, まず公理のラベルであると解釈する.
  \item 2 で該当する公理が一つも無い場合は, let 変数名であると解釈する.
  \end{enumerate}
  上のいずれの解釈によっても, 節が見付からない場合はエラーとする.
  節指定として公理のラベルが指定された場合，同じラベルを持った公理が
  複数存在する場合は，それらの公理全てが指定されたものと解釈する．

  SOS 集合は初期には空であり，また \texttt{db reset} を行った時点で空
  に設定される．
  \texttt{sos}コマンドの実行に伴って，usable 集合の内容が副作用として
  決められる．
  つまり，\texttt{list axioms}で表示される節から SOS 集合の内容を取り
  去ったものがusable 集合として設定される．

\item[resolve コマンド]

  反駁エンジンを起動するためのコマンド．
  本コマンドを発する事によって, 反駁エンジンによる定理証明プロセスが
  開始される.

\begin{vvtm}
\begin{simplev}
  <resolveコマンド> ::= resolve {. | <ファイル名>}
\end{simplev}
\end{vvtm}

引数が\texttt{<ファイル名>}で指定されるファイルへのパス名の場合は，指
  定のファイルへ実行ログが出力．これが `\texttt{.}' (ピリオド記号)の場合は標準出力へ
  ログが出力される．

\item[clause コマンド]
  指定された項を Skolem 標準形の節形式に変換し, 結果を印字する. 試験の
  ためのコマンドである.

\begin{vvtm}
\begin{simplev}
  <clauseコマンド> ::= clause <項> .
\end{simplev}
\end{vvtm}

\texttt{<項>}はソート\texttt{FoplSentence}の項でなければならない．指定
の項を節形式に変換して印字する．

\item[\texttt{show}/\texttt{describe} コマンド]
  従来のCafeOBJコマンド\texttt{show}と\texttt{describe}を拡張したものである.

\begin{vvtm}
\begin{simplev}
  <showコマンド>      ::= show <節ID> 
  <describe コマンド> ::= describe <節ID>
\end{simplev}
\end{vvtm}

どちらの場合も
  \texttt{<節ID>}で指定される節を印字する．\texttt{<節ID>}は節の識別子であり，
  `\texttt{list axioms}' や，`\texttt{list sos}' 等のコマンドで表示さ
  れる内容から知ることができる．
   \texttt{describe}の場合は, 指定の節がCafeOBJモジュールの公理を節形式に
   変換して得られた節であった場合, 対応する公理がどれであるかの情報も
   併せて印字する.

\item[\texttt{lex}コマンド]
  lrpo による項の大小比較を行う際に用いられる演算子の順序関係を定義する
  ためのコマンドである. このコマンドについては, 第
  \ref{sec:lex-command} 節で説明する.

\end{description}

%%%%%
\section{PigNose の一般的なスクリプト構造}
\label{sec:pignose-general-scheme}

システムの詳細な使用法は引き続く各章で説明されるが,
ここでは簡単な例を示して典型的な使用方法について述べる.
下は通常想定される典型的な使い方の大枠を示したものである：
\begin{enumerate}
\item[(1)] 検証対象とするモジュールをオープン\\
  これは実行文脈となるモジュールを設定するのが主目的であるが,
  証明を実行する際には, 通常付加的なオペレータや
  公理等の追加宣言が行われると想定される. 
  例えば, 証明対象(ゴール)とする FOPL 文は,
  追加公理として動的に宣言されることが多いと思われる.
  このためには, オープン文を用いるのが便利である.

\item[(2)] (必要に応じて) \texttt{FOPL-CLAUSE} をインポート\\
  証明実行の文脈となるモジュールのサブモジュールに\texttt{FOPL-CLAUSE}
  が既に輸入されているのであれば, これは不要である.

\item[(3)] (必要に応じて)オペレータや公理等の追加宣言\\
  (1) で述べた通り.

\item[(4)] 反駁エンジンの起動
  \begin{enumerate}
  \item[(4-1)] エンジンの実行環境の設定\\
    フラグ/パラメータの設定を行ったり, 
    マニュアルモードの場合は, システムの初期化(db reset),
    SOS 節集合の設定等を行う.
  \item[(4-2)] 証明実行 \\
    resolve コマンドを発行し, エンジンを起動する.
  \end{enumerate}
\end{enumerate}

下に極めて簡単な例を示す.
ここでは自動モードを用いた場合と, 手動で推論ルールを
設定する場合の2つの例が示されている. 
いずれも単純な例であるが, 
上で述べた通常の典型的と思われるスクリプトの構造を反映したものである.

\begin{vvtm}
\begin{examplev}
-- FOPL-CLAUSE が必要に応じて自動的に輸入されるように設定する
set include FOPL-CLAUSE on
-- 
module! TEST1 {
  [ Human < Life ]
  pred mortal : Life
  op Socrates : -> Human
  -- 生あるものは死す
  ax \A[X:Life] mortal(X) .
}

**>  典型的なスクリプト構造

**> (1) 対象とするモジュールをオープンする
open TEST1

**> (2) FOPL-CLAUSE は既に輸入されているので改めて輸入する必要はない.
**> (3) 必要に応じて公理などの追加宣言
-->     ここでは証明したいことを追加公理で宣言.
-->     これは ax ~ motal(Socrates) と等価.
goal mortal(Socrates) .

**> (4) 反駁エンジンの起動
**> (4-1) PigNose 実行環境の設定
-->       オプション(フラグ/パラメータ)をリセット.
-->       対話型のシステムなので, option reset を習慣付けることが大事
option reset

-->        自動モードで実行する
**> auto mode
flag(auto, on)

-- **> このフラグをセットすると沢山の情報が出力される, try it!
-- **> flag(very-verbose,on)

-->         証明は1つで良い
param(max-proofs, 1)

**> (4-2) 証明実行
-->       エンジンを起動する
resolve .

**> 文脈モジュールをクローズ : 後始末
close
\end{examplev}
\end{vvtm}

下はマニュアルモードの場合である. 例題は上のオートモードの場合と同じ
TEST1 を想定している. 

\begin{vvtm}
\begin{examplev}

**> 次はマニュアルモードによる例 *****************************
**> manual mode

**> フラグ/パラメータを初期状態に戻す
option reset

**> 文脈モジュールをオープンする
open TEST1

**> 証明したい文を宣言：今度は公理にラベルを指定している
-- 
goal[GOAL]: mortal(Socrates) .

**> マニュアルモードなので, システムの初期化を陽に実行する
**> 必要がある
db reset

**> SOS 節集合の設定
sos = {GOAL}

**> 推論ルールとして negative hyper resolution を
**> 用いる
flag(neg-hyper-res, on)

**> エンジンの起動
resolve .

**> 文脈モジュールのクローズ
close
\end{examplev}
\end{vvtm}

%%%%% 
\section{節の印字形式}
\label{sec:print-clause}
システム実行中, あるいはコマンドによって
さまざまな情報の表示や証明木の印字などで節が印字される.
システムの動作を見たり, 結果を調べるためには節の印字形式に付いて
知っておく必要がある.

\subsection{節表示の一般形式}

一般に節は次のような形式で表示される.

\begin{vvtm}
\begin{simplev}
    <節番号>:[<導出履歴>] FOPL文
\end{simplev}
\end{vvtm}

ここで, \texttt{<節番号>} はシステムが節に自動的に割り付ける自然数である.
対象とするモジュールに含まれる最初の公理から得られた最初の節に対して
番号1が割り付けられ, 以降順次1ずつ節番号が増やされて行く. 
導出節は, モジュールの公理から $n$ 個の節が得られたとすると,
節番号 $n+1$ から割り振られる. したがって節番号の大きな導出節程,
新しく生成された節と言う事になる.

節番号の次にはかぎかっこでくくられた\texttt{<導出履歴}が表示される.
これはその節がどのような推論ルール, あるいは内部処理により生成
されたかを示すものである. 導出履歴の具体的な内容については
第\ref{sec:proof-tree}章を参照されたい. 
一般にモジュールの公理から得られた節は, 導出履歴が空であるから
\texttt{[]} と表示される. 但し, back demodulation 等によって
書き換えられる場合もあり, この場合それらに対応した導出履歴が
表示されるので, 必ずしもそうとは言えない.

最後に節の FOPL 文が表示される. リテラルが 2 個以上ある場合は,
それらが論理和(\verb:|:)で繋いで表示される. 

\subsection{Skolem 関数の表示形式}

FOPL 文から節形式へ変換される場合, 存在限量子があった場合に
Skolem 関数が自動生成される. この表示の一般形式は次の通りである：

\begin{vvtm}
\begin{simplev}
  定数の場合    ： #c-<N>.<ソート>
  引数を持つ場合： #f-<N>.<ソート>
\end{simplev}
\end{vvtm}

ここで\texttt{<N>} は自然数でありシステムが適当に割り付ける.
また\texttt{<ソート>}は関数の値ソートの名前である.

\subsection{変数}

システムが節を処理する際には, 変数名の付け替え処理が
施される. したがって, 利用者が公理として記述した文に
あった変数とは異なる変数名が与えられる. 
システムが生成した変数は, 次のような名前になる：

\begin{vvtm}
\begin{simplev}
  _V<N>
\end{simplev}
\end{vvtm}

ここで\texttt{<N>}はシステムが自動で割り振る自然数である. 

\subsection{節の印字例}

実際の節の表示例を幾つか示す.
下の例で, 1 が節番号である. 導出された節ではなく, 入力節のため
導出履歴の欄は空(\texttt{[]})となっている. 続いて節を構成する
リテラルが表示されている. この場合は単一節で, リテラルは一つである.
\texttt{\#c-1.Account} はシステムが生成した Skolem 定数である.

\begin{vvtm}
\begin{simplev}
  1:[] 0 <= balance(#c-1.Account)
\end{simplev}
\end{vvtm}

次の例(節126)も単一節の表示例であるが, 導出項であり
導出履歴欄が表示されている.
この例の場合は \texttt{para-from}による paramodulation from 推論ルール
に続いて, \texttt{unit-del}による unit deletion が施されたことが解る.
para-from に関しては, 節 7 が paramodulator であり, これが節
2 に適用されたことが解る. 次いで 節 1 による unit deletion が
実行され, 結果としてこの節が出来た. 
なお, 導出履歴欄については, 第~\ref{sec:proof-tree}章で説明する.

\begin{vvtm}
\begin{simplev}
  126:[para-from:7,2,unit-del:1] 
    #c-1.Int <= balance(#c-1.Account)
\end{simplev}
\end{vvtm}

下は2つのリテラルから構成される節の表示例である.
各リテラルが論理和(\verb:|:)で結合されて表示されている.
\texttt{\_vxx} はシステムが生成した変数である.

\begin{vvtm}
\begin{simplev}
  10:[] ~(_v45:Int <= _v44:Int) | 0 <= (_v44:Int - _v45:Int)
\end{simplev}
\end{vvtm}

%%%%%%%%%%%%% 
\section{推論プロセスの概要}
\label{sec:infer-process}

\subsection{証明戦略 -- SOS}
\label{sec:sos-strategy}

反駁エンジンの推論機構の基本は {\em given-clause} アルゴリズムであり
(\cite{otter})これは,
\textbf{SOS}(Set Of Support) 戦略方式の簡単な実装の一種と見る事が
できる(\cite{chang-lee}).
この戦略の考え方を以下に概説する.

$A_1,\ldots A_n$ を前提，$B$ を結論とすると, PigNose は
\[ A_1,A_2,\ldots,A_n \rightarrow B\]
を証明するために反駁法を用い，
\[A_1\land A_2\cdots\land A_n\land 〜B\]
が充足不可能である事を示そうとする. 
その際, 全ての FOPL 文を節形式にし, resolution 原理に基づいて節を導出し
て行く. その過程で空節が得られれば反駁されたと判定されるが, このとき，通
常前提は無矛盾とみなすので $A_1,A_2\ldots, A_n$ は充足可能と仮定すると,
$A_1,A_2,\ldots, A_n$ の間で，節の導出を行うのは無駄である. このアイデ
アをより積極的に利用するのが SOS 戦略である. 

節の集合 $S$ の部分集合 $T$ は $S - T$ が充足可能である時に，$S$ の
\textit{set of support} と呼ばれる．
PigNose の場合, 節集合 $S$ は通常文脈モジュールで宣言された公理の集合に
対応する. \textit{set-of-support 導出} とは，どちらかの節が $T$ に属する
ような2つの節からの導出を言う．また，全ての導出が set of support 導出で
あるような演繹は \textit{set-of-support 演繹} と呼ばれる．

SOS 戦略に関しては次の定理が成り立つ\cite{chang-lee}:
\begin{quotation}
 $S$ を有限の充足不能であるような節の集合とし，$T$ を $S$ の部分集合
 とする．もし $S - T$ が充足可能とすると，$T$ を set of support として
 $S$ から空節を導出するような set of support 演繹が存在する．
\end{quotation}

PigNose では節の集合を下のような \textbf{usable} と \textbf{sos} と呼ば
れる2つに分け，導出節の生成を sos から取り出した節と usable に含まれる節
との間でのみ行うようにする．sos が上の説明の節集合 $T$ (set of
support) に対応することになる. 
\begin{center}
  \begin{tabular}{|lcl|}\hline
    usable &:& 推論(resolution)を行う際に使用される節の集合．\\
    sos    &:& 推論には使用されない節の集合．\\\hline
  \end{tabular}
\end{center}
システムは, このようにして分割された sos 節集合から節を一つ取り出して
usable に入れ, この節と元々 usable に含まれていた節との間で導出を行う.
導出された節は, sos へ入れられ以降の推論に用いられる.

この方式では, 利用者が節の集合を sos と usable のどちらかに振り分ける必
要があるが, 通常は, 証明対象とするものを sos に入れれば良い. 
後述する自動モードでは，入力節のうち，正の節(正のリテラルのみからなる節
)を sos へ入れ，それ以外の節(少なくとも一つの負のリテラルを含む節) は
usable へ入れるように設定されている．この場合, 上の定義で言えば

\paragraph{SOS 方式による導出の例}
以下の節の集合を考える．
$$
\begin{array}{ll}
(1) & P(g(x_1,y_1),x_i,y_1) \\
(2) & 〜P(x_2,h(x_2,y_2),y_2) \\
(3) & 〜P(x_3,y_2,u_3)\lor P(y_3,z_3,v_3)\lor 〜P(x_3,v_3,w_3) \lor
    P(u_3,z_3,w_3) \\
(4) & 〜P(k(x_4),x_4,k(x_4)).
\end{array}
$$
sos $= \{(4)\}$ とする．従って usable $= \{(1),(2),(3)\}$ である．
このとき以下に示す演繹は
sos を set of support とする set-of-support 演繹である：

$$
\begin{array}{lll}
(5) 〜P(x_3,y_3,k(z_3))\lor P(y_3,z_3,v_3)\lor 〜P(x_3,v_3,k(z_3))
    & \makebox{(4) と (3)} \\
(6) 〜P(x_3,y_3,k(h(y_e,v_3))\lor 〜P(x_3,v_3,k(h(y_3,v_3)))
    & \makebox{(5) と (2)} \\
(7) \makebox{□} & \makebox{(6) と (1)}
\end{array}
$$

\subsection{推論プロセスの主ループ}
\label{sec:main-loop}

前節で反駁エンジンは sos 戦略で推論を行うことを述べたが，
この方式による推論プロセスの主ループの概要は次のようになる：

\begin{simplev}[fontfamily=helvetica]
  while (sos が空でなく，かつ空節が導出されていない)
      (1) sos から`節を一つ選'び，これを given-clause と呼ぶ.
      (2) given-clause を sos から usable に 移す.
      (3) `現在有効な推論ルール群'を用いて導出節を生成する.
          新たに生成される節は，given-clause を一方の親として持ち，
          他の親は usable に含まれる節である．
      (4) 新たに生成された節に対して，`有用性の検査'を行う．
          これをパスした節は sos へ加え，そうでない節は捨てる．
  end 
\end{simplev}
この推論プロセスの主ループの詳細は後で説明するが, 次のような冗長性が避け
られていることに注意されたい：
例えば, 節 $C$ が 節 $A$ と $B$ から導出することが出来, また $A$ と
$B$ の両方が sos に含まれているもの仮定する. もし $A$ が given clause と
して選択されると, 上の処理概要で述べた通り, これは usable へ移されて, 推
論が実行される. しかし, $A$ と $B$ とで $C$ を導出することは\textbf{ない
  }. なぜなら, $B$ は未だ sos にあるからである. $C$ の導出には, $B$ が
given clause として選ばれるまで待たねばならない. さもなければ, $C$ が2度
導出されることになってしまうからである.

\begin{description}
\item[sos から `節を一つ選' ぶ方法] 利用者がフラグによって設定する．
  反駁エンジンには推論プロセスの動作を制御するために，さまざまなフラグが
  用意されており， given-clause の選択方法もその一つであり，下の2つフラ
  グはこれに関係するものである：
  \begin{center}
    \begin{tabular}{|lcl|}\hline
      sos-queue  &:&  sos を先入れ先出し構造(queue)と見て節の選択を行う\\
      sos-stack  &:&  sos を先入れ後出し構造(stack)と見て節の選択を行う\\\hline
    \end{tabular}
  \end{center}

  sos-queue の場合は幅優先の探索, sos-stack の場合は深さ優先の探索に相当
  する. これらのいずれのフラグも off の場合は，`最も軽い節' を選択する．
  節の重みとは  全てのリテラルに含まれる演算子や変数の数を合計したもので
  ある．初期にはこ  れらのフラグはどちらも off に設定されており，したがっ
  て節の重みによって  given-clause が選択される．

  重みでの given-clause の選択に関しては, 実際にはもう少し細かな制御がな
  される. すなわち, pick-given-ratio というパラメータが存在し, これに正
  の整数値 $n$ が設定されていた場合は, sos からの取り出し $n$ 回目毎(最
  初を含む)に, 重さを無視して, sos の先頭から節を取り出す.  これを行わな
  いと, いつまでたっても, 初期の sos に格納されていた節からの導出節が生
  成されない, という事態に陥る可能性があるからである. 

  given clause の選択に関係するその他のフラグについては, 
  第~\ref{sec:loop-flags} 節を参照されたい. 

\item [`現在有効な推論ルール群'] 前節で述べた通り，反駁エンジンには
  複数の推論ルールが用意されており，利用者がフラグによって使用したい推論
  ルールを設定する．これには以下の種類がある:

  \begin{center}
    \begin{tabular}{|lcl|}\hline
      フラグ名      &:& 推論ルール \\\hline
      auto          &:& 自動モード\\
      auto3         &:& 自動モード \\
      binary-res    &:& binary resolution \\
      hyper-res     &:& hyper resolution \\
      neg-hyper-res &:& negative hyper resolution \\
      para-into     &:& paramodulation into \\
      para-from     &:& paramodulation from \\\hline
    \end{tabular}
  \end{center}
  これらのフラグの初期値は全て off であり，したがって推論ルールは選択され
  ていない．複数のルールを同時に使用する事が可能である．自動モードでは，
  入力節の集合に対して，簡単な構文的検査を行い，適当な推論ルールのセットを
  選択する(第\ref{sec:auto-mode}節を参照). 

  上に示したフラグと合わせて, 推論ルールの選択に関係するフラグは, 
  第~\ref{sec:inf-flags} で説明されている. 

\item[導出節の処理] 導出節に対しては, 以下で示す処理が施される.
  上の概要で示した `有用性のテスト' はこれに含まれるものである.
  下で, ステップの番号に * 印のついているものはオプションであり,
  フラグの値に依存して実行するか否かが決定される.
  \begin{enumerate}
  \item[1] 変数をユニークなものにつけ替える
  \item[*2] 導出節を印字する
  \item[3] demodulation を施す
  \item[*4] 等式の向き付けを行う
  \item[*5] unit deletion を施す
  \item[6] 同一のリテラルをマージする
  \item[*7] factor-simplification を施す
  \item[8] tautology だった場合は捨てて, 処理を終る
  \item[*9] 節が重すぎる場合は捨てて, 処理を終る
  \item[*10] リテラルをソートする
  \item[11] usable あるいは sos に含まれる節によって subsume される
    場合は捨てて, 処理を終る(forward subsumption).
  \item[12] 索引テーブルに登録し sos に追加する
  \item[*13] 追加された節を印字する
  \item[14] リテラルを一個も含まない節であれば, 反駁が発見された.
  \item[15] 一個のリテラルを含む節(単一節)である場合は,
    usable と sos に含まれる節との間で, それと反駁するような節を探す
    (unit conflict). 
  \item[*16] 反駁が発見されたならば, 証明木を印字する.
  \item[*17] demodulator として使えるかどうかを調べる.
  \end{enumerate}

  以上の処理は, 推論ルールによって導出された全ての導出節に対して
  施され, それが終ったあとで, あらためて捨てられずに残った
  全ての導出節に対して以下の処理が施される：
  \begin{enumerate}
  \item[*18] 上のステップ17で, 新たな demodulator が生成されていたならば,
    それらを使用して back demodulation を行う
  \item[*19] usable あるいは sos に含まれる項で, 導出節によって subsume 
    されるような節は削除する(back subsumption).
  \item[*20] 導出節の factoring を行い, 個々の factor を処理する.
  \end{enumerate}
  
\end{description}

%%%%%%%%%%%%%
\section{フラグとパラメータの設定}
\label{sec:flags-and-parameters}
フラグとパラメータは推論エンジンの実行を制御するスイッチや
さまざまな制約条件を指定するためのものであり，利用者が
コマンドで値を設定する
(第\ref{sec:new-commands}章を参照).
下はフラグとパラメータの値の設定例である. 個々のフラグやパラメータの意味
は第\ref{sec:pn-flag}章と第\ref{sec:option-parameters}章で説明する.

\begin{vvtm}
\begin{examplev}
  flag(binary-res, on)        -- binary resolution を有効にする
  flag(back-sub, off)         -- back subsumption を無効にする
  param(max-given, 100)       -- given clause の数を 100 に限定する
\end{examplev}
\end{vvtm}

\subsection{フラグ/パラメータ値の保存/初期化}
\label{sec:init-options}
システムが初期に起動した際には, 各フラグやパラメータは特定の既定値に初期
化される. 利用者は各人の目的に応じてこれらの値を適当に設定してシステムを
使用するわけであるが, 特定の組合せを保存しておくことが出来ると便利である. 
このためのコマンドが\texttt{save-option}である(第~\ref{sec:new-commands}
章を参照).  \texttt{save-option}で名前を付けて保存したオプション(全てのフ
ラグ/パラメータとそれらの値の組み)は\texttt{option}コマンドによって再利
用することが出来る. また, オプションを全て初期値にリセットするのにも,
\texttt{option}コマンドを使用する.

\begin{vvtm}
\begin{examplev}
  option reset               -- 全てを初期値に戻す
  flag(hyper-res,on)         -- フラグやパラメータの値を
  flag(back-sub, off)        -- 設定
       :
  param(max-seconds, 3600)
       :
  save-option option-set-1   -- 現在の設定値を option-set-1
                             -- という名前を付けて保存
       :
  option = option-set-1      -- 先に作っておいたオプションを利用  
\end{examplev}
\end{vvtm}

システムを対話的に利用する場合, フラグやパラメータの値に関して混乱を生ず
る恐れがある. 上で示した例のように, 一旦全てを初期値にリセットし, 次いで
各オプションの設定を行うという使い方をすると良い.

現在のフラグの設定値を知るには \texttt{list}コマンドを用いる.

\begin{vvtm}
\begin{examplev}
  list flag
\end{examplev}
\end{vvtm}

また, パラメータの設定値を知るにも, 同じ\texttt{list}コマンドを
用いる.

\begin{vvtm}
\begin{examplev}
  list param
\end{examplev}
\end{vvtm}

\section{フラグ}
\label{sec:pn-flag}

\subsection{given clause 選択に関するフラグ}
\label{sec:loop-flags}
推論の主ループの各サイクル毎に sos 節集合から取り出される節は
\textbf{given clause} と呼ばれる.
given clause として最も軽い節を選択する, というのが既定の方法であること
は先に述べた. 節の重さとは, それに含まれるリテラルの重さの合計である.
リテラルの重さとは, リテラルに含まれる項の重さの合計値であり,
項の重さは, それに含まれる演算子と変数項の数を合計したものである.
given cluase の選択方法は, 以下のフラグによって制御される：
\begin{description}
\item[sos-queue] on の時, sos を節の queue 構造とみなして, given clause を 
  選択する. 初期値は off.
\item[sos-stack] on の時, sos を節の stack 構造とみなして, given clause を
  選択する. 初期値は off.
\item[input-sos-first] 初期値は off. もし on ならば, 初期の sos 節集合に
  含まれている各節に対して, 内部的にある非常に小さな重みが設定される.
  従って重みで節を選択する際, 初期状態で sos に含まれていた節が優先的に
  選択されることになる.  
\item[randamize-sos] 初期値は off. もし on ならば, 節の重みが
  同じ節が複数あった場合, 疑似乱数を発生させて無作為に選択する.
%\item[pick-given-ratio] -1 以外の値の時, このパラメータの値おきに,
%  sos の先頭から given clause を選択する.
%  初期値では 4 に設定されている.
\end{description}
この他, given clause の選択には, パラメータ pick-given-ratio が関係する
(第\ref{sec:misc-params}節を参照). 

\subsection{その他の主ループ動作に関するフラグ}
\begin{description}
\item[print-given] 初期値 off.\ on ならば given clause
  が選択される毎に, その節を印字する.
\item[print-lists-at-end] 初期値 off.\ on ならば,
  sos, usable 各節集合と demodulator の一覧印字を,
  推論ループの終了後に行う.
\end{description}

\subsection{推論ルールに関するフラグ}
\label{sec:inf-flags}

節の導出に使用する推論ルールを設定するフラグであり,
以下のものがある：
\begin{description}
\item[auto] 初期値は off.\ on ならばシステムに導出ルールの選択や
  その他の制御フラグ, パラメータなどの設定を任せる.
  詳しくは第\ref{sec:auto-mode}章を参照されたい.

\item[auto3] 初期値は off.\ auto フラグと同様であるが, フラグの
  設定が一部異なる. 詳細は第 \ref{sec:auto-mode}章を参照されたい.

\item[binary-res] 初期値は off.\ on ならば, 新たな節の導出のため
  (その他に設定されている推論ルールと合わせて) 
  binary resolution を用いる. このフラグを on にすることによって,
  factor および, unit-deletion フラグがそれぞれ自動的に on となる.
\item[hyper-res] 初期値は off.\ on ならば(他の設定されている
  推論ルールと合わせて), 導出節の生成に正の hyper resolution を用いる.
\item[neg-hyper-res] 初期値は off.\
  on ならば(他の設定されている推論ルールと合わせて), 導出節の生成に negative
  hyper resolution を用いる.
\item[para-into] 初期値は off.\ 
  on ならば, given clause に対する paramodulation が実行される.
  paramodulation を用いる場合, 同値性に関する反射則($X = X$)が,
  一般的には必要である. これを自動的に設定するのが, 下の universal-symmetry
  である.
\item[universal-symmetry] 初期値は off.\ on の場合,
  入力節として, 同値性に関する反射則に対応する節($ X = X $ に相当
  するもの)を自動的に追加する.
\item[para-from] 初期値は off.\ on の場合,
  given clause を paramodulator とした(usable, および sos に含まれる
  節に対しての) paramodulation が実行される.
  paramodulation を用いる場合, 同値性に関する反射則($X = X$)が,
  一般的には必要である(上の \texttt{universal-symmetry}の説明を
  参照).
\item[demod-inf] 初期値は off.\ on の場合, あたかも推論ルール
  であるかのように, given-clause に対して demodulation が実行される.
  このフラグが on の場合は, given-clause がコピーされ, 通常の
  導出節に対してと同じ処理が施される.
\item[prop-res] 初期値は off.\ on の場合, 以下の条件が満足される
  場合に, 命題論理的な節(変数を含まない節)に対して, 
  binary resolution を実行する：
  \begin{itemize}
  \item フラグ \texttt{binary-res} が off
  \item フラグ \texttt{hyper-res} あるいは \texttt{neg-hyper-res} が on
  \end{itemize}
  この場合, resolution の対象となる節も変数を含まないものに
  限定される.
\item[dist-const] 初期値は off.\ on の場合, 全ての定数は互いに異なるもの
  ($\neq$)として扱う.  
  すなわち, $c_1=c_2$ のような形のリテラルがあり,
  $c_1$ と $c_2$ が異なる定数項であった場合, \texttt{false} とされ, 同一の
  場合は \texttt{true} として扱う. Skolem 定数に関してはこのフラグは無視
  される. 
\end{description}


\subsection{Paramodulation に関するフラグ}
\label{sec:para-flags}
Paramodulation の動作を制御するためのフラグ群であり,
以下のものがある：
\begin{description}
\item[para-from-left] 初期値は on.\ on の場合, 
  paramodulator として使用される等式 $l = r$ を,
 $l\rightarrow r$ と方向つけた paramodulation が行われる.
  para-from および para-into 両方の推論ルールの動作に有効である.
\item[para-from-right] 初期値は on.\ on の場合,
  等式 $l = r$ を $r\rightarrow l$ と方向つけた paramodulation が
  行われる. para-from および para-into 両方の推論ルールに有効である.
\item[para-into-left] 初期値は on.\ on の場合,
  paramodulation が施される対象となる正または負の等式の左辺側に
  対する paramodulation が可能となる. para-from および para-into
  両方の推論ルールに対して有効である.
\item[para-into-right] 初期値は on.\ on の場合
  paramodulation が施される対象となる正または負の等式の右辺側に
  対する paramodulation が可能となる. para-from および para-into
  両方の推論ルールに対して有効である.
\item[para-from-vars] 初期値は off.\ on の場合は, 変数からの
  paramodulation を有効にする. \emph{このフラグを on にすると
    非常に多くの paramodulation が実行される可能性がある.}
  para-into および para-from 両方の推論ルールに対して有効なフラグである.
\item[para-from-units-only] 初期値は off.\ on の場合
  paramodulator となり得る節は, (等式のみからなる)単一節に限られる.
  para-from および para-into 両方の推論ルールに対して有効である.
\item[para-into-units-only] 初期値は off.\ on の場合
  paramodulation の対象となる節は, (等式のみからなる)単一節に限られる.
  para-from および para-into 両方の推論ルールに対して有効である.
\item[para-ones-rules] 初期値は off.\ 現在このフラグは使用されていない.
\item[para-skip-skolem] 初期値は off.\ 現在このフラグは使用されていない.
\end{description}

\subsection{導出節の処理に関するフラグ}
\label{sec:gen-flags}
導出節に対して施される処理を制御するためのフラグであり,
以下のものがある：
\begin{description}
\item[unit-deletion] 初期値 off.\ on の場合,
  導出された節に対する unit deletion 処理が施される.
  unit deletion とは, 節に含まれるリテラルが,
  sos または usable に含まれる単一節の否定になっている
  場合, それらのリテラルを除去する処理である.
  例えば \texttt{p(a,X) | q(a,X)} という節の2番目のリテラルは,
  単一節 \texttt{~ q(u,V)} によって除去される(ここで, X と V は変数であり,
  他は定数とする--以下同様).
  しかし, 単一節 \texttt{~ q(u,b)} によっては除去されない. 
  なぜなら unification によって変数 X が instantiate されるからである.
  この条件に合致するリテラルは全て除去され, 結果として空節が得られる
  場合もある. (unit deletion は, 導出節が必ず単一節となるような場合には
  冗長な処理である.)

\item[delete-identical-nested-skolem] 初期値 off.\ on の場合,
  Skolem 関数がネストしているような項を持った節を除去する.
  例えば, \texttt{f} が Skolem 関数であるような場合, \texttt{f(f(x))}
  や \texttt{f(g(f(x)))} というような形の項を含む節を除去する.

\item[sort-literals] 初期値 off.\ on の場合,
  新たな導出節に含まれるリテラルを, 負(否定)のリテラル,
  次に正のリテラルといった順に並び替える. 
  この処理の主目的は, 節を見やすくすることであるが,
  単一節でない節の subsumption 判定処理が高速化される場合もある.

\item[for-sub] 初期値 on.\ on の場合, 新たに導出された
  節に対する処理の際に, 前向き subsumption 検査(usable あるいは sos に含
  まれる節によって subsume されるかどうかの検査)が行われ, その場合は以降
  の推論に無駄な節なので, これを除去する. 

\item[bak-sub] 初期値 on.\ on の場合, 新たに保持された節を用いて, 後向き
  subsumption 処理(その節によって  subsume されるような usable あるいは
  sos 内の節を除去する事)が行われる.

\item[factor] 初期値 off.\ on の場合, factoring 処理が
  以下の2つの方式で適用される
  \begin{enumerate}
  \item 新たな導出節に対する簡単化処理：\\
    もし, 導出節 $C$ が $C$ を subsume するような factor を持っているな
    らば, 最も小さな factor で節を置き換える.
  \item 新たな保持節に対する推論ルール:\\
    factoring 処理である. 他の推論ルールとは異なり, given clause には適
    用されない. 
  \end{enumerate}
\end{description}

\subsection{Demodulation と等式の向きつけに関するフラグ}
\label{sec:eq-flags}

Demodulation の動作と, 等式の左右辺の向き付けの処理を制御するための
フラグ群である.

\begin{description}
\item[demod-history] 初期値 on.\ on の場合,
  節が demodulate された場合, demodulator 節の id 番号を節の導出履歴の中
  に保持する. 
\item[order-eq] 初期値 off.\ on の場合, 等式の右辺が左辺より重かった場合
  に左右辺を入れ換える(「重さ」の意味に関しては, 第~\ref{sec:orient} と
  ~\ref{sec:orient-lrpo} 節を参照). 
\item[eq-units-both-ways] 初期値 off.\ on の場合, 等式のみからなる単一節
  に関して, 左右どちらからの向き付けも可能となる. 実際の動作は, フラグ
  \texttt{order-eq} の値に依存する：
  \begin{itemize}
  \item もし \texttt{order-eq} が off ならば, 等式 $\alpha=\beta$
    に関して $\beta=\alpha$ が無条件に自動生成される.
  \item \texttt{order-eq} が on ならば, 等式の左右辺の向き付けが
    出来なかった場合にのみ, $\beta=\alpha$ が生成される.
  \end{itemize}

\item[dynamic-demod] 初期値 off.\ on の場合,
  条件に叶った, 新たな保持節(処理が施されて以降の導出のために保持された
  節)が, 新たな demodulator として登録される.
  このように, 推論過程で demodulator として追加される節を dynamic
  demodulator と呼ぶ. PigNose には, demodulator を利用者が指定する機能は
  なく, 一部例外を除いて全ての demodulator は dynamic
  demodulator である. 従って, demodulation 機構を使用したい場合は, この
  フラグを on に設定しておく必要がある.

  条件については, 第~\ref{sec:dynamic} と ~\ref{sec:dynamic-lrpo} 節を参
  照. このフラグを on に設定すると, 自動的に \texttt{order-eq} も on に設
  定される. 

\item[dynamic-demod-all] 初期値 off.\ on の場合,
  システムは全ての新たな導出節を demodulator とすべく試みる(第
  ~\ref{sec:dynamic}節を参照). 
  このフラグを on に設定すると, 自動的に \texttt{dynamic-demod} と
  \texttt{order-eq} が on に設定される.

\item[dynamic-demod-lex-dep] 初期値 off.\ on の場合
  動的 demodulator (dynamic-demod フラグが on の際に, 動的に
  demodulator として登録される節 -- 上の dynamic-demod フラグの説明を
  参照 -- は lex-依存, あるいは lrpo-依存 であっても良いとされる. 
  詳しくは第~\ref{sec:dynamic} と \ref{sec:dynamic-lrpo} 節を参照.

\item[back-demod] 初期値 off.\ on の場合, 
  新たな demodulator が追加される毎に,それを用いて usable, sos, 及び現在の
  demodulator に対して, demodulation が行われる.
  このフラグが on にされると, 自動的に \texttt{order-eq} と 
  \texttt{dynamic-demod} フラグが on に設定される.

\item[kb] 初期値 off.\ on の場合, システムの推論過程は Knuth-Bendix の
  完備化手続きのような振舞いをする. このフラグは実際にはメタフラグであり,
  下に示すようにして他のフラグを設定するものである：
\begin{simplev}
  flag(para-from,on)
  flag(para-into,on)
  flag(para-from-left,on)
  flag(para-from-right,off)
  flag(para-into-left,on)
  flag(para-into-right, off)
  flag(para-from-vars, on)
  flag(eq-units-both-ways, on)
  flag(dynamic-demod-all, on)
  flag(back-demod, on)
  flag(process-input, on)
  flag(lrpo, on)
\end{simplev}  

\item[kb2] kb と同様であるが, 自動設定されるフラグのうち, 
  para-from-vars が off にされる点が異なる.

\item[lrpo] 初期値 off.\ on の場合, 辞書式再帰パス順序(lexicographic
  recursive path ordering -- lrpo) によって項の大小比較を行う.
  off の場合は, 重みと単純な辞書式順による比較が使用される
  (第\ref{sec:lrpo}節を参照).

\item[lex-order-vars] 初期値 off.\ このフラグは lex-依存の demodulation
  と, 節に含まれる項の大小比較を行う内部手続きの動作を制御する.
  このフラグが on の場合, 辞書式順による項の順序付けは全順序となる.
  つまり, 変数は項の順序関係において最も小さく, 変数同士の順序は
  名前の辞書式順である. このフラグが off の場合は, 同じ変数かどうか
  という判定のみが行われる. 異なる変数同士や変数ではない項との比較は
  行われない. 例えば, $X$ と $Y$ を変数とする. $f(X)$ と $f(Y)$ を
  比較すると, lex-order-vars が on の場合は比較が行われ, $f(X)$ の
  方が小さいと判定される. しかしこのフラグが off の場合の比較結果は
  「不明」(順序つけができない)となる.

  フラグ \texttt{lrpo} が on になっている場合, lex-order-vars の値は
  demodulation の動作には影響を与えない(\ref{sec:lex-order}章).
  
\end{description}

\subsection{入力節の処理に関するフラグ}
\label{sec:input}
\begin{description}
\item[simplify-fol] 初期値 on.\ on の場合, FOPL 文を節形式に
  変換する際に, tautology の検出などを含む式の簡単化処理が施される.
  簡単化処理は CNF 変換の際に Skolem 化を行った後で実施される. 
  この際に結果が空節となる場合も有り得るが, フラグ process-input
  が off の場合は, システムはそれを認識しない -- 反駁された(証明が見付かっ
  た)としない.

\item[process-input] 初期値 off.\ on の場合, 初期の usable および
  sos 節集合に含まれている節に対して, あたかもそれらが推論ルール
  を適用して得られた導出節であるかのような処理が施される
  (導出節に対する処理概要の説明が第\ref{sec:main-loop}節にあるので
  これを参照されたい). 実際の導出節に対する処理と, これらの入力節
  に対する処理では, 以下の違いがある：
  \begin{itemize}
  \item[(1)] 入力節に対しては, \texttt{max-literals} および 
    \texttt{max-weight} パラメータによる制約テストは行われない.
    また, \texttt{delete-identical-nested-skolem} フラグによるテストも
    行われない.
  \item[(2)] usable に含まれていた節は, 処理の後保持されると判定された
    場合, そのまま usable に置かれる(通常の導出節は sos に追加される).

  \item[(3)] 印字に関するフラグ(第\ref{sec:output-flags}を参照)
    が off の場合でも, いくつかの情報が印字される.
  \end{itemize}

\end{description}

\subsection{印字に関するフラグ}
\label{sec:output-flags}

\begin{description}
\item[very-verbose] 初期値 off.\ on の場合, 詳細な処理情報が
  印字される. 
\item[print-kept] 初期値 on.\ on の場合, 新たな導出節が保持されると
  判定された場合, それを印字する.

\item[print-proofs] 初期値 on.\ on の場合, 空節が得られた時に
  その導出履歴(証明木)を印字する. 

\item[print-new-demod] 初期値 on.\ on の場合, 
  推論過程で動的に追加された demodulator をその都度印字する.
  入力節に対する処理の場合は, このフラグの値にかかわらず,
  印字される.

\item[print-bak-demod] 初期値 on.\ on の場合,
  back demodulation が実行された節をその都度印字する.
  入力節が back demodulation された場合は, このフラグの値に係わらず
  印字される.

\item[print-back-sub] 初期値 on.\ on の場合,
  back subsume された節をその都度印字する.
  入力節が back subsume された場合は, このフラグの値にかかわらず
  印字される.

\item[quiet] 初期値 off.\ on の場合, 全ての情報印字が抑制される.

\end{description}

\subsection{その他のフラグ}
\label{sec:misc-flags}

\begin{description}
\item[control-memory] 初期値 off.\ on の場合, 自動的に sos サイズを
  元にした max-weight パラメータの再設定機能が有効となる.

\item[order-hyper] 初期値 on.\ on の場合, 推論ルールの \texttt{hyper-res}
  と \texttt{neg-hyper-res} による導出の際に, 順序付け戦略による
  制約が施される. つまり, サテライト節のリテラルは, それが最大のものである
  (同じ節にそれより大きいリテラルが無い)ときにのみ, resolve の対象とされる.
  大きさの比較は, 述語記号を辞書式順で比べる事によって行われる.
  (このフラグは, 正の hyper resolution -- hyper-res フラグによる推論
  ルールを用いる際, 全ての節が Horn 節であった場合には無意味である.)

\item[propositional] 初期値 off.\ このフラグが on の場合,
  システムは全ての節が命題論理的であると仮定して, それに最適化された処理をする.

  このフラグを on にする場合, 実際に全ての節が命題論理的でなければ,
  結果が正当であることは保証されない. 場合によってはシステムが clash する
  こともあるので, 注意されたい.

\end{description}

\section{パラメータ}
\label{sec:option-parameters}

パラメータは正または負の整数値であり, 推論プロセスの動作を制御するものである.
本章では推論プロセスが参照するパラメータについて説明する.
パラメータの有効範囲は [M ... N] という表記で規定する. これは M 以上 N 以下を
意味する. 最小値の規定で most-negative-fixnum となっているのは, Common Lisp 
の仕様で規定されいている最小の固定整数値, また most-positive-fixnum となっ
ているのは同じく最大の固定整数値を意味する\footnote{Common Lisp 処理系に
  よってこれらの実際の値はまちまちである. }

\subsection{探索制約設定パラメータ}

\begin{description}
\item[max-seconds] [-1 ... most-positive-fixnum]\\
  初期値は -1. もし $n\neq -1$ ならば, cpu 消費時間が
  約 n 秒に達した時点で証明探索を中止する. 設定した時間は
  あくまでも目安である. システムは, ある given clause に関する
  処理を全て終えた後に, このパラメータによる制約を検査する.

\item[max-gen] [-1 ... most-positive-fixnum]\\
  初期値は -1. もし $n\neq -1$ ならば, およそ $n$ 個の
  導出節を生成した時点で, 証明探索を中止する. 
  システムは, ある given clause に関する処理を全て終えた時点で
  このパラメータによる制約を検査するので, 設定した数はあくまでも
  目安である. 

\item[max-kept] [-1 ... most-positive-fixnum]\\
  初期値は -1. もし $n\neq -1$ ならば, およそ $n$ 個の節が
  保持された後で, 証明探索を中止する. 
  システムは, ある given clause に関する処理を全て終えた時点で
  このパラメータによる制約を検査するので, 設定した数はあくまでも
  目安である.

\item[max-given] [-1 .. most-positive-fixnum] \\
  初期値は -1. もし $n\neq -1$ ならば, 取り出した given-clause の数が 
  $n$ 個に達した時点で, 証明探索を中止する.

\end{description}

\subsection{導出節に対する制約設定パラメータ}

\begin{description}
\item[max-weight] [-1 ... most-positive-fixnum] \\
  初期値は most-positive-fixnum. 
  生成された導出節の重みがこのパラメータで指定された値を越えた場合は,
  その節を捨てる. -1 は無制限を意味する.
\end{description}

\subsection{その他のパラメータ}
\label{sec:misc-params}

\begin{description}
\item[pick-given-ratio] [-1 ... most-positive-fixnum] \\
  初期値は -1. 
  sos から節を重みで選ぶ場合, ここで指定された数の節おきに,
  重みにはよらずに, sos をリストとみなした先頭にある節を given-clause 
  として選ぶ. 
  -1 は指定無しを意味する.
\item[demod-limit] [-1 ... most-positive-fixnum] \\
  初期値は 1000. 一つのリテラルに対して一度に実行する demodulation での
  書き換え回数の最大値を指定する. 書き換え回数がここで指定された数を越え
  た時点で, そのリテラルの demodulation は中断される. 値が -1 の場合は制
  限が無い事を意味する. 
\item[max-proofs] [-1 ... most-positive-fixnum] \\
  初期値は 1.
  一度の推論プロセスで得られた空節の数が, このパラメータで指定された数に
  達した場合に推論プロセスを中断する. -1 は無制限を意味する.
\item[stats-level] [0 ... 4] \\
  初期値は 2. 推論プロセスの最後に印字される統計情報の詳細度を指定する.
\item[max-sos] [-1 ... most-positive-fixnum] \\
  初期値は -1. sos に格納されている節の数がこのパラメータで指定されてい
  る数を越えた場合に, max-weight パラメータの自動再設定を実行する.
  -1 は無制限を意味する.
\end{description}

\section{自動モード}
\label{sec:auto-mode}

本節では自動モードにおけるフラグやパラメータのセッティング, 
sos と usable への節の振り分けに関して説明する.

フラグ auto あるいは auto3 が on の場合, 反駁エンジンは, 入力節(文脈となっ
ている CafeOBJ モジュールに含まれる公理から得られた節集合)をスキャンし,
いくつかの簡単な構文的な性質を調べて推論ルールと探索戦略を自動決定する. 
選択される探索戦略は(フラグ control-memory を除けば)通常 refutation
complete (反駁可能な節集合であれば, 必ず反駁出来る)である. 
しかし, 効率の良い戦略が自動設定されるとは期待すべきではない.
自動モードでは, 多くの簡単な定理の証明が可能である. また, 証明に失敗する
ような場合でも, 手動による定理証明の良い出発点を提供する. 

\textbf{フラグ auto/auto3 は, 他のどのフラグのセッティングよりも先に実行
  されなければならない}. すなわち, コマンド flag(auto,on) は他のフラグの
セットコマンドよりも先にインタプリタに入力されるべきである.
フラグ auto(auto3) が on にセットされた時点で, 他の依存するフラグやパラ
メータが次のように自動設定される: 
\begin{itemize}
  \item process-input → on
  \item print-kept → off
  \item print-new-demod → off
  \item print-back-demod → off
  \item print-back-sub → off
  \item control-memory → on
  \item max-sos → 500
  \item pick-given-ratio → 4
  \item stats-level → 2
\end{itemize}

次いで, resolve コマンドによって反駁エンジンが起動される際に, システムは
入力節を走査し, 得られた構文的な性質の内容からどの推論ルールを使用するか
を判定する. その結果適当なフラグやパラメータの設定が行われる.
入力節の走査時に調べられる構文的な性質は以下のものである：
\begin{enumerate}
\item[(1)] propositional か\\
  つまり, 全ての節が変数を持たない場合.
\item[(2)] Horn 節か\\
  つまり, 全ての節が高々一つの正のリテラルを持つ場合.
\item[(3)] equality があるか\\
  つまり, 少なくとも一つの $A = B$ あるいは $〜(A = B)$ の形の
  リテラルを持つ節がある場合.
\item[(4)] equality axiom があるか\\
  つまり, 少なくとも一つ $A = B \rightarrow B = A$ に相当する
  節がある場合.
\item[(5)] 節に含まれるリテラル個数の最大値
\end{enumerate}
つぎに, これらの性質を組み合わせた簡単な 6 つのケースに分類する
\begin{enumerate}
\item[(1)] propositional
\item[(2)] 全ての節が単一節で equality 
\item[(3--6)] \{equality, Horn\} の4つの組み合わせ
\end{enumerate}
これらのケースに対応してどのような設定がなされるかは, システムの出力を見
る事で知る事が出来る. 一般に等式が含まれる場合は, paramodulation, 
demodulation が無条件で有効とされる. この場合, 細かな設定は, フラグ kb
あるいは kb2 を内部的に on にすることで行う(kb および kb2 については, 第
\ref{sec:eq-flags}節を参照). 
auto と auto3 の違いはここのみにあり, auto の場合は kb, auto3 の場合は
kb2 が on にされる. あとの動作は全く同じである.

次に入力節の sos および usable への振り分けであるが, 正の節(すべての
リテラルが正の節)を sos へ, それ以外の節は usable へ入れられる.

\section{統計情報}
\label{sec:statistics}
本節では推論プロセス実行中に収集されるさまざまな統計情報について説明する.
以下に示すのはシステムが実行中に収集される情報の一覧である.

\begin{tabular}[htcb]{l|p{0.74\textwidth}}\hline
cl-generated & 推論中に生成された節の合計数.  \\
cl-kept & 導出節のうち, sos に入れられた節の合計数. 
  フラグ process-input が on の場合は, usable や sos の初期集合に
  対して行われる前処理によって, usable あるいは sos に残された節の
  数も含まれる. \\
cl-for-sub & forward subsume されて捨てられたた節の合計数. \\
cl-back-sub & back subsume された捨てられた節の合計数. \\
cl-tautology & tautology と判断されて捨てられた節の合計数.\\
cl-given & given clause として sos 集合から取り出された節の合計数.\\
cl-wt-delete & max-weight を越えたために捨てられた節の合計数. \\
rewrites & demodulation による書き換え回数の総合計. \\
unit-deletes & unit deletion によって削除されたリテラルの合計数. \\
empty-clauses & 推論中に導出された空節の合計数.\\
for-sub-sos & sos に含まれる節によって subsume され, 捨てられた 
  節の合計数.\\
new-demods & 推論中に生成された demodulator の合計数. \\
cl-back-demod & 推論中に行われた back demodulation の合計数. \\
sos-size & sos に含まれている節の数. \\
usable-size & usable に含まれている節の数. \\
demodulators-size & demodulator の数. \\
binary-res-gen & binary resolution によって導出された節の合計数. \\
hyper-res-gen & hyper resolution によって導出された節の合計数. \\
neg-hyper-res-gen & negative hyper resolution によって導出された 
  節の合計数.\\
para-into-gen & paramodulation into によって導出された節の
  合計数. \\
para-from-gen & paramodulation from によって導出された節の
  合計数. \\
demod-inf-gen & demodulation を行った回数. \\
factor-simplifications & factor simplification を行った回数. \\
factor-gen & factoring で生成された節の合計数. \\ \hline
\end{tabular}

フラグ print-stats の値が on であった場合に, 推論プロセスの終りに, それ
まで収集された統計情報が印字される.
印字する統計情報の内容は, パラメータ stats-level の値に応じて内容を変え
る. 一般に stats-level の値が大きい程, より詳細な情報を印字される：

\begin{itemize}
\item stats-level の値が 0 〜 2 の場合は以下の情報を印字する
  \begin{itemize}
    \item[] cl-given
    \item[] cl-generated
    \item[] cl-kept
    \item[] cl-for-sub
    \item[] cl-back-sub
  \end{itemize}
\item stats-level が 3 以上の場合は全ての統計情報を印字する.
\end{itemize}

\section{証明木とその印字}
\label{sec:proof-tree}

空節が得られた場合に, 空節を導出する過程に関った節を順にたどることによって, 
空節の導出過程を知ることが可能である. 
第~\ref{sec:print-clause}章で述べられている通り, 節を印字する際には, そ
の導出履歴も合わせて表示される. 従って, これらの節を識別子番号の順に並べ
たリストは, 証明木(反駁木)と見る事が出来る. 
システムは, フラグ \texttt{print-proof} が on の場合に,
空節に出食わす毎に, このような反駁木を印字する.
下は実際の証明木印字の例である：
最後の節 163 が得られた空節である. この節を導出するのに使われた節が,
節番号の若い順に表示されている事が解る.
これらの節の導出履歴を見る事により, どのような過程を経て
空節が得られたかを調べる事が出来る.

\begin{vvtm}
\begin{examplev}
** PROOF ________________________________
 
  1:[] 0 <= balance(#c-1.Account)
  2:[back-demod:161] ~(0 <= (balance(#c-1.Account) + #c-1.Int))
  5:[] ~(0 <= _v34:Int) | balance(deposit(_v34:Int,_v33:Account)) 
                          = balance(_v33) + _v34
  6:[] 0 <= _v62:Int | balance(deposit(_v62:Int,_v63:Account)) 
                       = balance(_v63)
  10:[] ~(0 <= _v41:Int) | ~(0 <= _v42:Int) | 0 <= (_v41:Int 
                                                    + _v42:Int)
  136:[para-from:6,2,unit-del:1] 
    0 <= #c-1.Int
  150:[hyper:136,10,1] 0 <= (balance(#c-1.Account) + #c-1.Int)
  161:[hyper:136,5] balance(deposit(#c-1.Int,_v175:Account)) 
                    = balance(_v175) + #c-1.Int
  162:[back-demod:161,2] ~(0 <= (balance(#c-1.Account) + #c-1.Int))
  163:[binary:162,150] 
 
** ______________________________________
\end{examplev}
\end{vvtm}

\subsection{導出履歴欄の見方}
\label{sec:history}
節の表示の導出履歴欄は一般的に次の形をしている：
\begin{vvtm}
\begin{simplev}
  <導出履歴欄> ::= <導出履歴>{,<導出履歴>}*
  <導出履歴>   ::= <導出ルール>：[<節番号>{,<節番号>}*]
\end{simplev}
\end{vvtm}
つまり $<$導出履歴$>$ をコンマ記号で並べたものである.
一つの $<$導出履歴$>$ は, 具体的にどのような処理によって
生成されたかを示す $<$導出ルール$>$ と, オプションで
$<$節番号$>$ をコンマ記号で繋げたリストからなる.
例えば,
\begin{vvtm}
\begin{examplev}
  para-from:6,2,unit-del:1
\end{examplev}
\end{vvtm}
では, \texttt{para-from} と \texttt{unit-del} が導出ルール
に相当し, \texttt{para-from} は, 節6 と 2 が, また
\texttt{unit-del} では, 節番号 1 をオプションの $<$節番号$>$
として持つ. 以下各導出履歴の読み方について説明をする.
\begin{description}
\item{}\texttt{[bin-res:clause-1,clause-2]}\\
  binary resolution(\texttt{bin-res}) によって生成された. clause-1 は
  given clause の節番号. clause-2 は, これと resolve した節の節番号.
\item{}\texttt{[prop-res:clause-1,clause-2]}\\
  propositional resolution(\texttt{prop-res}) によって生成された.
  clause-1 は given clause の節番号. clause-2 は, これと resolve した
  節の節番号. 
\item{}\texttt{[hyper-res:clause-1,claus-2,..,clause-n]}\\
  hyper resolution(\texttt{hyper-res})によって生成された. clause-1 は
  given clause の節番号. clasuse-2 .. clause-n はこれと resolve した節
  の節番号. 
\item{}\texttt{[neg-hyper-res:clause-1,clause-2,...,clause-n]}\\
  negative hyper resolution(\texttt{neg-hyper-res}) によって生成された.
  clause-1 は given clause の節番号. clause-2 ... clause-n はこれと
  resolve した節の節番号.
\item{}\texttt{[para-into:clause-1,clause-2]}\\
 paramodulation into(\texttt{para-into}) によって生成された.
  clause-1 がオリジナルな節, clause-2 が paramodulator である.
\item{}\texttt{[para-from:clause-1,clause-2]}\\
  \texttt{para-from} によって生成された.
  clause-1 がオリジナルの節, clause-2 が paramodulator である.
\item{}\texttt{[fsimp:]} \\
  factor simplification(\texttt{factor-simp})によって
  生成された.
\item{}\texttt{[back-demod:clause-1,claus-2,...,clause-n]}\\
  clause-1...clause-n によって
  back demodulate(\texttt{back-demod})されて生成された. この場合, もと
  もとのオリジナルな節の内容ば破壊的に変更されている.
\item{}\texttt{[demod:clause-1,clause2,...,clause-n]}\\
  clause-1..clause-n によって
  demodulation が施されて生成された. \texttt{back-demod}の場合と同様,
  オリジナルな節の内容は破壊的に変更されている.
\item{}\texttt{[copy:clause-1]} \\
  内部処理でclause-1の節をコピーして生成された.
\item{}\texttt{[flip:]} \\
  等式の左右辺の入れ換えによって生成された.
\item{}\texttt{[unit-del:clause-1]}\\
  clause-1 との unit deletion(\texttt{unit-del})に
  よって生成された.
\item{}\texttt{[back-unit-del:clause-1]}\\
  clause-1とのback unit deletion(\texttt{back-unit-del})
  によって生成された.
\end{description}

%%%%%%%%%%%
\section{項の順序付けと Demodulation}
\label{sec:term-ordering}

フラグ \texttt{order-eq} が on の場合には等式の左右辺の項の大小比較が行わ
れ, 大きい方を左辺に持って来るよう並べ変えるという処理が行われる(これを
「等式の方向つけ」と呼ぶ). この他にもさまざまな文脈で, 項の大きさの比較
が行われる. 
大小比較に際しては, 「単純辞書式順」 と 「辞書式再帰パス順序(lrpo)」 
(lexicographic recursive path ordering) の2種の順序付けのうちどちらかが
用いられる(「単純辞書式順」はなんら理論的な背景を持たないことから Ad
Hoc な順序付けとも呼ばれる. ) 
フラグ \texttt{lrpo} がこれらどちらの順序つけを使用するかを決め, これが
on の場合は lrpo を用い, そうでなければ ad hoc な順序つけを用いる. 

\subsection{単純辞書式順 -- Ad Hoc}
\label{sec:ad-hoc-lex}

\subsubsection{項の順序 (Ad Hoc)} \label{sec:lex-order}

単純な辞書式順による項の比較の場合, システムでは, 「辞書式順」と「重み
-辞書式順」の2種類の順序付け方法が使われている. 利用者がこれらを選択する
ことが出来るわけではなく, 順序つけを行う文脈に応じて, システムがこれらを
使い分けている.
\begin{description}
\item[辞書式順]
  これば基本的な辞書式順による記号の順序つけである.   2つの項を比較する
  際に, それらを左から右へと読んで行き,   異なる演算子記号あるいは変数に
  出食わした時点でストップする. これらの互いに異なる記号の大小比較の結果
  が, 項の大小関係を決定する.
  変数記号との比較はフラグ \texttt{lex-order-vars} の値に依存する.
  \begin{description}
  \item[\texttt{lex-order-vars} が on.]
    この場合変数も比較の対象となる. 
    変数は記号順序で一番小さいと決められており, 変数同士はその名前の辞書
    式順で大小を決める.  
    名前の上の辞書式順序による比較はトータル(任意の2つの名前は比較可能
    )なので, 辞書式順による項の順序つけもトータルである.

    変数束縛によって, 相対的な項の大小関係が変化する場合があることに
    注意されたい.

  \item[\texttt{lex-order-vars} が off (初期値).]
    変数は同一の変数であるかどうかだけが判定される.
    従って項の順序は部分的である(大小の判定が不可能な場合がある).
    変数を比較の対象とはしないので,
    もし, $t_1 \prec t_2$, であり, $\sigma$ を変数置換とした場合,
    $t_1\sigma \prec t_2\sigma$ である. つまり, 変数の instantiation
    を行っても項の相対的な大小関係に変わりはない.
  \end{description}

\item[重み-辞書式順]
  二つの項を比較する際に, まず最初に項の重み(項に含まれるオペレータと
  変数の数の合計)で比較する. 一方の項の方が重ければ, 順序においても
  大きいと判定される. 両方の項の重みが同じ場合は, \texttt{lex-order-vars}
  が off の場合の, 辞書式順での比較と同じ方法を取る.

\end{description}


\subsubsection{等式の方向付け (Ad Hoc)} \label{sec:orient}

フラグ\texttt{order-eq} が on で, \texttt{lrpo} が off の場合, 導出節に含ま
れる等式リテラル $\alpha=\beta$ に対して $\alpha$ と $\beta$ を比較して,
以下のような処理が施される. この処理のことを, \textbf{等式の方向つけ}と
呼ぶ. 
\begin{enumerate}
\item どちらかの項が他の項の(真の)副項であれば, 副項が等式の右辺に
  来るように並べられる.
\item もし一方の項が「重み-辞書式順」で他方より大きい場合は
  大きい方が左辺に来るように並べられる.
\end{enumerate}
つまり, 大きい方が常に左辺側に来るようにアレンジされる. これは lrpo を
用いた方向つけでも同じである. 

\subsubsection{Dynamic Demodulator の判定 (Ad Hoc)}  \label{sec:dynamic}

フラグ\texttt{dynamic-demod}あるいは, \texttt{dynamic-demod-all}が on の
場合, フラグ\texttt{order-eq}も自動的に on になっているはずである.  
この場合, システムは推論の過程で導出された正の等式リテラルのみを含む単一
節を, 以降 demodulator(書き換え規則) として用いるべく試みる. 
もし, \texttt{process-input}が on であった場合には, usable 及び sos に含
まれている初期節集合の個々の節にたいしても同じ処理が施される.
具体的には, 等式を $\alpha=\beta$ とすると, 以下のような処理が
施される(この処理では等式が既に方向つけされているものと仮定している.)
下の説明で, $\succ$ は順序関係の大小を表現するのに用いられている.
すなわち, $t \succ t'$ は $t$ が $t'$ より大きい事を意味する.
また, $vars(t)$ は, 項 $t$ に含まれている変数の集合,
$wt(t)$ は項 $t$ の重さである.
\begin{enumerate}
\item もし $\beta$ が $\alpha$ の(真)部分項であれば,
  この等式を demodulator として用いる.

\item もし 「重み-辞書式順」 の意味で $\alpha\succ\beta$ であり,
  $vars(\alpha) \supseteq vars(\beta)$, の場合
  \begin{itemize}
  \item[(a)]
    もし \texttt{dynamic-demod-all} が on であれば, 等式を
    demodulator とする;
  \item[(b)]
    もし \texttt{dynamic-demod-all} が off であり, $wt(\beta) \leq 1$, 
    ならば, 等式を demodulator とする.
  \end{itemize}

\item  もし, フラグ \texttt{dynamic-demod-lex-dep} と
  \texttt{dynamic-demod-all} の両方が on の場合は, 
  \begin{enumerate}
  \item $\alpha$ と $\beta$ が変数を無視すれば同一, かつ
  \item $vars(\alpha) \supseteq vars(\beta)$,
  \end{enumerate}
  であれば, 等式を lex-依存の demodulator とする(次節--\ref{sec:lex-dep}
  を参照).
\end{enumerate}

\subsubsection{Lex-依存の Demodulation (Ad Hoc)} \label{sec:lex-dep}

含まれている変数を全て同じ $X$ で置き換えた2つの項が, 同一となる場合,
2つの項は, 「変数を無視して同じ」と言われる.
入力節や動的 demodulator は, 等式 $\alpha=\beta$ において, $\alpha$ と
$\beta$ が「変数を無視して同じ」場合に, lex-依存の demodulator と呼ばれ
る. (lex-依存の動的 demodulator の判定については, 第\ref{sec:dynamic}節
を参照されたい).

lex-依存の demodulator は, 書き換えられた結果の項が元の項より 「辞書式順」
で小さくなる場合にのみ適用される. 

\subsection{LRPO} \label{sec:lrpo}

\subsubsection{項の順序付け (\textsc{lrpo})}

辞書式再帰パス順序({\em lexicographic recursive path ordering}) は項の比
較を行う方法もう一つの方法であり, フラグ lrpo が on の時に用いられる.
重要な理論的性質として \textsc{lrpo} は, {\em termination} 順序であるという
ことがある.  
つまり, $R$ を demodulator の集合とし, 含まれる各 demodulator の左辺は
\textsc{lrpo} の意味で右辺より大きいならば, demodulation (demodulator を左
辺から右辺の向きに適用する) プロセスは終了することが保証される.

\textsc{lrpo} による比較は, (1) 等式リテラルの方向つけ(左辺が右辺より大きく
なるように置き換える事), (2) 等式が demodulator として使われ得るか, ある
いは \textsc{lrpo}-依存の demodulator となるかを判定したり, 
(3) \textsc{lrpo}-依存の demodulator を適用できるか否かを判定するのに用いら
れる. 上記以外の文脈で使用されることは無い.

\subsubsection{オペレータ記号の順序付け -- lex コマンド}
\label{sec:lex-command}

\textsc{lrpo} を使用する場合, オペレータ記号に関する順序つけが決められてい
なければならない. これは lex コマンドを用いて指定することが出来る.
コマンドの構文は次の通りである：
\begin{vvtm}
\begin{simplev}
 <lex コマンド> ::= lex(<op1_1>,....,<op_n>)
\end{simplev}
\end{vvtm}
\texttt{<op1\_1>} や \texttt{<op\_n>} はオペレータ記号である. 左側にある程
小さいと規定する. 特殊なオペレータ記号として \texttt{*} と 
\texttt{SKOLEM} の2つがシステムで予約されている：
\begin{description}
\item[*] lex コマンドの引数に記述されなかった残りのオペレータすべてを意
  味する. これらは名前の単純辞書式順で展開され並べられる.
\item[SKOLEM] システムが生成した Skolem 関数. Skolem 関数同士は
  名前の辞書式順で比較される.
\end{description}
例えば下のようなモジュールがあったとする：
\begin{vvtm}
\begin{examplev}
   module! LEX
   { [Elt]
     ops a b c : -> Elt
     op _+_ : Elt Elt -> Elt
     op _*_ : Elt Elt -> Elt
     op s : Elt -> Elt 
     op _-_ : Elt Elt -> Elt
     op _/_ : Elt Elt -> Elt
   }
\end{examplev}
\end{vvtm}
ここで
\begin{vvtm}
\begin{examplev}
  lex(a, b, c, s, _+_, *, _*_)
\end{examplev}
\end{vvtm}
とした場合のオペレータ順序は次のようになる：
\[
\mathtt{\_*\_\succ\_/\_\succ\_-\_\succ\_+\_\succ s\succ c \succ b
  \succ a}
\]

上の例では SKOLEM の指定が無い. * あるいは SKOLEM 指定が引数リストに無
い場合は, 以下のようにシステムが補間する：
\begin{enumerate}
\item * 指定がなければ, リストの最後に * を追加する.
\item SKOLEM 指定がなければ, リストの最後に SKOLEM を追加する.
\end{enumerate}
つまり, これら両方が省略された時の設定は次のようになる：
\begin{vvtm}
\begin{simplev}
    lex(<op_1>, ..., <op_n>, *, SKOLEM)
\end{simplev}
\end{vvtm}
また, lex コマンドの指定が無い場合のオペレータ記号の順序つけは
\begin{vvtm}
\begin{simplev}
    lex(*, SKOLEM)
\end{simplev}
\end{vvtm}
とした場合と同じである. すなわち, 全てのオペレータ記号は単純辞書式順で比
較され, またシステムが生成する Skolem 関数は最も大きいと判定する.
先に述べたとおり, Skolem 関数同士の比較は辞書式順による.

lex コマンドで, * および SKOLEM というオペレータ記号が予約語とされる事に
より,  利用者がこれらの名前を持ったオペレータを定義出来なくなるのでは,
と懸念されるかもしれないが, 次のようにしてこれを回避出来る.
いずれの場合も, 利用者の定義したオペレータを引数の数で修飾した名前を用い
ればよい. 例えば利用者が * という2引数のオペレータを定義している場合は,
\texttt{*/2} とすることでこれを参照することが出来る. もしこれが定数であれ
ば \texttt{*/0} とすれば良い. SKOLEM の場合も同様である.

\paragraph{lex コマンドに関する注意}
lex コマンドは `db reset' を実行する\textbf{前に}発せられていなければ
ならない. 自動モードの場合は自然にこれが実現されるので問題ないが, マニュ
アルモードの際には注意が必要である. 

% 現在システムは単純な辞書式順によるオペレータ名の順序を基本とし,
% 次のような, heuristic な順序付けを暗黙的に行っている：
% \begin{itemize}
% \item モジュールの等式を元にしたオペレータ記号の相対順序つけ\\
%  等式を用いて公理を記述する際は, 左辺→右辺への方向付けを
%  暗黙的に意識して記述していることが多いと思われる.
%  この仮定を元に, システムは各等式を走査し, 左辺側に出現する
%  オペレータ記号の方が, 右辺側より大きいとする相対的な順序付け
%  を行う. もしこのとき巡回が起きるような場合は, この順序関係は
%  使用しない.
% \item 定数はそうでないオペレータより小さいものとする.
% \item Skolem 関数記号はそうでないオペレータより大きいものとする.
% \end{itemize}
% 以上を順序付けを行う際の制約条件として用い, これらの制約に
% かからないようなケースでは, 純粋に辞書式順序による名前の大きさ
% 比較を行う.

\subsubsection{等式の方向つけ (\textsc{lrpo})} \label{sec:orient-lrpo}

もし, フラグ \texttt{order-eq} が on であり, ある等式リテラルの
どちらかの引数が他方より \textsc{lrpo} 順で大きいならば, 
大きい方の引数が左辺におかれるように並び替えられる.

\subsubsection{Dynamic Demodulator の判定 (\textsc{lrpo})} \label{sec:dynamic-lrpo}

フラグ \texttt{dynamic-demod} が on の場合, 
システムは
全ての等式に関して, それらが demodulator として使えないかどうかを
調べる(フラグ \texttt{dynamic-demod-all} は, \texttt{lrpo} が
on の場合は無視される.)
等式 $\alpha=\beta$ において,
\textsc{lrpo} 順で $\alpha\succ\beta$ であれば,
等式は demodulator となる
(この判定が行われる時点では, すでに等式の方向つけが済んでいる). 
もし, \texttt{dynamic-demod-lex-dep} が on であり, 
等式のどちらの辺も他の辺に対して \textsc{lrpo} の意味で小さくなく,
かつ $\beta$ に含まれている変数は全て $\alpha$ にも出現する
ものであれば, 等式は \textsc{lrpo}-依存の demodulator とされる.

\subsubsection{\textsc{lrpo}-依存の Demodulation (\textsc{lrpo})} 
\label{sec:lex-dep-lrpo}

\textsc{lrpo}-依存の demodulator は, 書き換えられた結果の項が
元の項より \textsc{lrpo} の意味で小さくなる場合にのみ
適用される.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% TeX-master: t
%%% TeX-master: t
%%% End: 
