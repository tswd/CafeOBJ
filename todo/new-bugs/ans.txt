%-----------------------------------------------------------------------
\section{Equational Specification and Programming}

This is inherited from OBJ \cite{iobj,obj2} and constitutes the basis
of the language, the other features being built on top of it. As with
OBJ, \cafeobj\ is {\em executable} (by term rewriting), which gives an
elegant declarative way of functional 
programming,\index{programming!(functional)}\index{functional programming}
often referred as {\em algebraic programming}.\footnote{Please notice
that although this paradigm may be used as programming, this aspect is
still secondary to the specification aspect of it.} As with OBJ,
\cafeobj\ also permits equational specification modulo several
equational theories such as associativity, commutativity, identity,
idempotence, and combinations between all these. This feature is
reflected at the execution level by term rewriting {\em modulo} such
equational theories.

\idea{something about implementation, maybe focus on implementation
of the execution mechanism}

項書換え系の実装：
特に言うべき事がない。

%-----------------------------------------------------------------------
\section{Behavioural Concurrent Specification}

Behavioural specification \cite{tasop1,goguen-malcolm96,coh} provides
               :
               :
The advanced coinduction proof method  receives support in \cafeobj\
via a default coinduction relation. In \cafeobj\, coinduction can be
used either in the classical HSA sense \cite{goguen-malcolm96} for
proving behavioural equivalence of states of objects, or for proving
behavioural transitions (which appear when  applying behavioural
abstraction to RWL).\foo{However, until the time this paper was
written, the latter has not been yet explored sufficiently, especially
from a practical perspective.} 
                :
上で、`a default coinduction' として現在の実装がどのような関係を
採用し、その証明を試みるのかの説明をする？
                :
                :

Behavioural specification is reflected at the execution level by the
concept of {\em behavioural rewriting} \cite{caferep,coh} which
refines ordinary rewriting with a condition ensuring the correctness
of the use of behavioural equations in proving strict equalities.

\idea{something about implementation issues; maybe scattered all over
this subsection in several places?}

behavioural rewriting の実装:
(1) 必要に応じて(モジュールに振舞い公理が含まれている時)書き換え時の
    context 検査を行う。
    contextの表現はスタック構造を使用し、書き換え対象となっている項の
    木構造の親子関係を、スタックを走査することによって得られるように
    している。
(3) 適用しようとしている書き換え規則が振舞い公理から得られたもので
    ある場合、behavioural context 検査をこのスタックを用いて親方向へ
    たどることによって実行する。(beh context の具体的説明が必要？)

%---------------------------------------------------------------------
\section{Rewriting Logic Specification}

Rewriting logic specification in \cafeobj\ is based on a simplified
version of Meseguer's {\em rewriting logic} \cite{meseguer92}
           :
           :
\idea{maybe some explanation on the implementation of \texttt{==>} ?}

==> の実装:
(1) 遷移が存在することに関する証明支援のために, 組み込みの述語 ==>
    が各ソートに関して暗黙的に宣言される
(2) システムは ==> に関して 反射、合同関係のための公理を自動的に
    追加するが、推移閉包に関しては別の組み込みの述語 =(*)=> 
    を用いて実装している。
(3) =(*)=> は組み込みの手続きによって実装されている。X =(*)=> Y の評価
    は、X の全ての可能な遷移を網羅的に順次調べあげ、Y に(equational equal
    の意味で)等しくなるような遷移があるか否かを検査することによって
    行われる。

%---------------------------------------------------------------------
\section{Module system}

The principles of the \cafeobj\ module system are inherited from OBJ
which builds on ideas first realized in  the language Clear
       :
       :
This revision incorporates a switch from a sharing mode (in which an
import of a parameter appears as import in the body) and a non-sharing
mode (in which the imports of the parameters are not shared) which
permits much more powerful parameterized specification and
programmming. At the moment of writing this paper the current SRA
implementation supports only the sharing mode but we plan to implement
the more powerful non-sharing mode in the near future.   

\idea{something about the implementation of the module system?}

モジュールシステムの実装：
実装方法に関しては簡単に説明出来ないので、やめ。

以下はコメント。
non-sharing 方式に関しては、個人的には現在の言語の範囲では sharing
で十分、というか、non-sharing には無理があるという立場。
instance を作る際の colimit の計算で、オブジェクトを identifying
する(しない)ための情報を、なんらかの方法で指定する必要があり、
現在の言語の拡張が必要になると思われる。また、sharing 方式との共存/混在
を許すのは難しい。いずれにしても、現在のモジュール式で無理をするのは
得策ではなく、おそらくダイアグラムを直接表現するような言語要素が必要になる。

%---------------------------------------------------------------------
\section{Type System}

\cafeobj\ has a type system that allows subtypes\index{sub-type}
based on {\em order sorted algebra}\index{algebra!(order sorted)}
         :
         :
Since at this moment there are many order sortedness formalisms, many
of them very little different from others, and each of them having its
own technical advantages/disadvantages and being most appropriate for
a certain class of applications, we decided to keep the concrete order
sortedness formalism open at least at the level of the language
definition. Instead we formulate some basic simple conditions which
any concrete \cafeobj\ order sortedness should obey. These conditions
come close to Meseguer's $\mathrm{OSA}^\mathrm{R}$ \cite{meseguer-mel}
\index{$\mathrm{OSA}^\mathrm{R}$}
which is a revised version of other versions of order sortedness
existing in the literature, most notably Goguen's OSA
\cite{osa-survey}.

\idea{say something about subsorting style of the implementation}

？？ 特に言うべきことが思い浮かばない。

