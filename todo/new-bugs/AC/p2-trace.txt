SMPI> in /tmp/p2
processing input : /tmp/p2.mod
-- execute in SMPI : (mpirun(3,((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })))):List
1>[1] rule: eq mpirun(I:Int,P:Pgm) = mpirun'(I,(P end),I)
    { I:Int |-> 3, P:Pgm |-> ((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) }
1<[1] mpirun(3,((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })))
     --> mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),3)
[1]: mpirun(3,((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })))
---> mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),3)
1>[2] apply trial #1
-- rule: ceq mpirun'(I:Int,P:Pgm,J:Int)
   = nil if (J < 1)
    { P:Pgm |-> (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end), 
      I:Int |-> 3, J:Int |-> 3 }
2>[2] rule: eq [:BDEMOD] : (NN:NzNat < NM:NzNat)
   = #! (< nn nm)
    { NN:NzNat |-> 3, NM:NzNat |-> 1 }
2<[2] (3 < 1) --> false
[2(cond)]: (3 < 1)
   --> false
1>[3] rewrite rule exhausted (#1)
1>[3] apply trial #1
-- rule: ceq mpirun'(I:Int,P:Pgm,J:Int)
   = ((((pid :: (J - 1)) (np :: I)) P) | mpirun'(I,P,(J - 1))) if (J > 1)
    { P:Pgm |-> (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end), 
      I:Int |-> 3, J:Int |-> 3 }
2>[3] rule: eq [:BDEMOD] : (NN:NzNat > NM:NzNat)
   = #! (> nn nm)
    { NN:NzNat |-> 3, NM:NzNat |-> 1 }
2<[3] (3 > 1) --> true
[3(cond)]: (3 > 1)
   --> true
1>[4] match success #1
1<[4] mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),3)
     --> ((((pid :: (3 - 1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
[4]: mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),3)
---> ((((pid :: (3 - 1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[5] rule: eq [:BDEMOD] : (I:Int - J:Int)
   = (I + (- J))
    { I:Int |-> 3, J:Int |-> 1 }
1<[5] (3 - 1) --> (3 + (- 1))
[5]: ((((pid :: (3 - 1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> ((((pid :: (3 + (- 1))) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[6] rule: eq [:BDEMOD] : (- I:Int)
   = #! (- i)
    { I:Int |-> 1 }
1<[6] (- 1) --> -1
[6]: ((((pid :: (3 + (- 1))) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> ((((pid :: (3 + -1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[7] rule: eq [:BDEMOD] : (I:Int + J:Int)
   = #! (+ i j)
    { I:Int |-> -1, J:Int |-> 3 }
1<[7] (3 + -1) --> 2
[7]: ((((pid :: (3 + -1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> ((((pid :: 2) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[8] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((pid :: 2) (np :: 3)), P:Pgm |-> ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end), 
      BP:BPgm |-> (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) }
1<[8] (((pid :: 2) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end))
     --> ((((pid :: 2) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) })) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))
[8]: ((((pid :: 2) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> (((((pid :: 2) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) })) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[9] apply trial #1
-- rule: ctrans (S:Store (if E:Exp { P1:Pgm }))
   => (S P1) if ((S [ E ]) =/= 0)
    { E:Exp |-> (not (pid = 0)), S:Store |-> ((pid :: 2) (np :: 3)), P1:Pgm
       |-> ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }
2>[9] rule: eq (S:Store [ (not E:Exp) ])
   = (if ((S [ E ]) == 0) then 1 else 0 fi)
    { S:Store |-> ((pid :: 2) (np :: 3)), E:Exp |-> (pid = 0) }
2<[9] (((pid :: 2) (np :: 3)) [ (not (pid = 0)) ]) --> (if ((((pid :: 2) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi)
[9(cond)]: ((((pid :: 2) (np :: 3)) [ (not (pid = 0)) ]) =/= 0)
   --> ((if ((((pid :: 2) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi) =/= 0)
2>[10] rule: eq (S:Store [ (E1:Exp = E2:Exp) ])
   = (if ((S [ E1 ]) == (S [ E2 ])) then 1 else 0 fi)
    { E1:Exp |-> pid, S:Store |-> ((pid :: 2) (np :: 3)), E2:Exp |-> 0 }
2<[10] (((pid :: 2) (np :: 3)) [ (pid = 0) ]) --> (if ((((pid :: 2) (np :: 3)) [ pid ]) == (((pid :: 2) (np :: 3)) [ 0 ])) then 1 else 0 fi)
[10(cond)]: ((if ((((pid :: 2) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if ((((pid :: 2) (np :: 3)) [ pid ]) == (((pid :: 2) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[11] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((pid :: 2) (np :: 3)), A:Var |-> pid }
2<[11] (((pid :: 2) (np :: 3)) [ pid ]) --> val(pid,((pid :: 2) (np :: 3)))
[11(cond)]: ((if ((if ((((pid :: 2) (np :: 3)) [ pid ]) == (((pid :: 2) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if (val(pid,((pid :: 2) (np :: 3))) == (((pid :: 2) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[12] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> (np :: 3), I:Int |-> 2 }
2<[12] val(pid,((pid :: 2) (np :: 3))) --> 2
[12(cond)]: ((if ((if (val(pid,((pid :: 2) (np :: 3))) == (((pid :: 2) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if (2 == (((pid :: 2) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[13] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((pid :: 2) (np :: 3)), I:Int |-> 0 }
2<[13] (((pid :: 2) (np :: 3)) [ 0 ]) --> 0
[13(cond)]: ((if ((if (2 == (((pid :: 2) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if (2 == 0) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[14] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 2, CYU |-> 0 }
2<[14] (2 == 0) --> false
[14(cond)]: ((if ((if (2 == 0) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if false then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[15] rule: eq (if false then CXU else CYU fi)
   = CYU
    { CXU |-> 1, CYU |-> 0 }
2<[15] (if false then 1 else 0 fi) --> 0
[15(cond)]: ((if ((if false then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if (0 == 0) then 1 else 0 fi) =/= 0)
2>[16] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[16] (0 == 0) --> true
[16(cond)]: ((if (0 == 0) then 1 else 0 fi) =/= 0)
   --> ((if true then 1 else 0 fi) =/= 0)
2>[17] rule: eq (if true then CXU else CYU fi)
   = CXU
    { CXU |-> 1, CYU |-> 0 }
2<[17] (if true then 1 else 0 fi) --> 1
[17(cond)]: ((if true then 1 else 0 fi) =/= 0)
   --> (1 =/= 0)
2>[18] rule: eq (CXU =/= CYU) = #!! (coerce-to-bool (not (term-equational-equal cxu cyu)))
    { CXU |-> 1, CYU |-> 0 }
2<[18] (1 =/= 0) --> true
[18(cond)]: (1 =/= 0)
   --> true
1>[19] match success #1
1<[19] (((pid :: 2) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }))
     --> (((pid :: 2) (np :: 3)) ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))))
[19]: (((((pid :: 2) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) })) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> (((((pid :: 2) (np :: 3)) ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[20] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((pid :: 2) (np :: 3)), P:Pgm |-> ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)), 
      BP:BPgm |-> (int x ;) }
1<[20] (((pid :: 2) (np :: 3)) ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))))
     --> ((((pid :: 2) (np :: 3)) (int x ;)) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)))
[20]: (((((pid :: 2) (np :: 3)) ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> ((((((pid :: 2) (np :: 3)) (int x ;)) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[21] apply trial #1
-- rule: ctrans (S:Store (int A:Var ;))
   => S if in?(A,S)
    { S:Store |-> ((pid :: 2) (np :: 3)), A:Var |-> x }
2>[21] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> x, S:Store |-> (pid :: 2), Y:Var |-> np, I:Int |-> 3 }
2<[21] in?(x,((pid :: 2) (np :: 3))) --> ((x == np) or in?(x,(pid :: 2)))
[21(cond)]: in?(x,((pid :: 2) (np :: 3)))
   --> ((x == np) or in?(x,(pid :: 2)))
2>[22] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> np }
2<[22] (x == np) --> false
[22(cond)]: ((x == np) or in?(x,(pid :: 2)))
   --> (false or in?(x,(pid :: 2)))
2>[23] rule: eq in?(X:Var,(Y:Var :: I:Int))
   = (X == Y)
    { Y:Var |-> pid, X:Var |-> x, I:Int |-> 2 }
2<[23] in?(x,(pid :: 2)) --> (x == pid)
[23(cond)]: (false or in?(x,(pid :: 2)))
   --> (false or (x == pid))
2>[24] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> pid }
2<[24] (x == pid) --> false
[24(cond)]: (false or (x == pid))
   --> (false or false)
2>[25] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[25] (false or false) --> false
[25(cond)]: (false or false)
   --> false
1>[26] rewrite rule exhausted (#1)
1>[26] apply trial #1
-- rule: ctrans (S:Store (int A:Var ;))
   => ((A :: na) S) if (not in?(A,S))
    { S:Store |-> ((pid :: 2) (np :: 3)), A:Var |-> x }
2>[26] rule: eq (not A:Bool) = (A xor true)
    { A:Bool |-> in?(x,((pid :: 2) (np :: 3))) }
2<[26] (not in?(x,((pid :: 2) (np :: 3)))) --> (in?(x,((pid :: 2) (np :: 3))) xor true)
[26(cond)]: (not in?(x,((pid :: 2) (np :: 3))))
   --> (in?(x,((pid :: 2) (np :: 3))) xor true)
2>[27] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> x, S:Store |-> (pid :: 2), Y:Var |-> np, I:Int |-> 3 }
2<[27] in?(x,((pid :: 2) (np :: 3))) --> ((x == np) or in?(x,(pid :: 2)))
[27(cond)]: (in?(x,((pid :: 2) (np :: 3))) xor true)
   --> (((x == np) or in?(x,(pid :: 2))) xor true)
2>[28] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> np }
2<[28] (x == np) --> false
[28(cond)]: (((x == np) or in?(x,(pid :: 2))) xor true)
   --> ((false or in?(x,(pid :: 2))) xor true)
2>[29] rule: eq in?(X:Var,(Y:Var :: I:Int))
   = (X == Y)
    { Y:Var |-> pid, X:Var |-> x, I:Int |-> 2 }
2<[29] in?(x,(pid :: 2)) --> (x == pid)
[29(cond)]: ((false or in?(x,(pid :: 2))) xor true)
   --> ((false or (x == pid)) xor true)
2>[30] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> pid }
2<[30] (x == pid) --> false
[30(cond)]: ((false or (x == pid)) xor true)
   --> ((false or false) xor true)
2>[31] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[31] (false or false) --> false
[31(cond)]: ((false or false) xor true)
   --> (false xor true)
2>[32] rule: eq (false xor A:Bool) = A
    { A:Bool |-> true }
2<[32] (false xor true) --> true
[32(cond)]: (false xor true)
   --> true
1>[33] match success #1
1<[33] (((pid :: 2) (np :: 3)) (int x ;)) --> ((x :: na) ((pid :: 2) (np :: 3)))
[33]: ((((((pid :: 2) (np :: 3)) (int x ;)) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[34] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((x :: na) ((pid :: 2) (np :: 3))), P:Pgm |-> (recv ( x , 0 ) ;), 
      BP:BPgm |-> (send ( pid , 0 ) ;) }
1<[34] (((x :: na) ((pid :: 2) (np :: 3))) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)))
     --> ((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (recv ( x , 0 ) ;))
[34]: (((((x :: na) ((pid :: 2) (np :: 3))) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> ((((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[35] rule: eq (((S:Store BP:BPgm) P1:Pgm) P2:Pgm)
   = ((S BP) (P1 P2))
    { P1:Pgm |-> (recv ( x , 0 ) ;), BP:BPgm |-> (send ( pid , 0 ) ;), 
      S:Store |-> ((x :: na) ((pid :: 2) (np :: 3))), P2:Pgm |-> ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end) }
1<[35] (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))
     --> ((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) ((recv ( x , 0 ) ;) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)))
[35]: ((((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) ((recv ( x , 0 ) ;) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
1>[36] rule: eq [:BDEMOD] : (I:Int - J:Int)
   = (I + (- J))
    { I:Int |-> 3, J:Int |-> 1 }
1<[36] (3 - 1) --> (3 + (- 1))
[36]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 - 1)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 + (- 1))))
1>[37] rule: eq [:BDEMOD] : (- I:Int)
   = #! (- i)
    { I:Int |-> 1 }
1<[37] (- 1) --> -1
[37]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 + (- 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 + -1)))
1>[38] rule: eq [:BDEMOD] : (I:Int + J:Int)
   = #! (+ i j)
    { I:Int |-> -1, J:Int |-> 3 }
1<[38] (3 + -1) --> 2
[38]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(3 + -1)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),2))
1>[39] apply trial #1
-- rule: ceq mpirun'(I:Int,P:Pgm,J:Int)
   = nil if (J < 1)
    { P:Pgm |-> (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end), 
      I:Int |-> 3, J:Int |-> 2 }
2>[39] rule: eq [:BDEMOD] : (NN:NzNat < NM:NzNat)
   = #! (< nn nm)
    { NN:NzNat |-> 2, NM:NzNat |-> 1 }
2<[39] (2 < 1) --> false
[39(cond)]: (2 < 1)
   --> false
1>[40] rewrite rule exhausted (#1)
1>[40] apply trial #1
-- rule: ceq mpirun'(I:Int,P:Pgm,J:Int)
   = ((((pid :: (J - 1)) (np :: I)) P) | mpirun'(I,P,(J - 1))) if (J > 1)
    { P:Pgm |-> (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end), 
      I:Int |-> 3, J:Int |-> 2 }
2>[40] rule: eq [:BDEMOD] : (NN:NzNat > NM:NzNat)
   = #! (> nn nm)
    { NN:NzNat |-> 2, NM:NzNat |-> 1 }
2<[40] (2 > 1) --> true
[40(cond)]: (2 > 1)
   --> true
1>[41] match success #1
1<[41] mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),2)
     --> ((((pid :: (2 - 1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1)))
[41]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),2))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: (2 - 1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[42] rule: eq [:BDEMOD] : (I:Int - J:Int)
   = (I + (- J))
    { I:Int |-> 2, J:Int |-> 1 }
1<[42] (2 - 1) --> (2 + (- 1))
[42]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: (2 - 1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: (2 + (- 1))) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[43] rule: eq [:BDEMOD] : (- I:Int)
   = #! (- i)
    { I:Int |-> 1 }
1<[43] (- 1) --> -1
[43]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: (2 + (- 1))) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: (2 + -1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[44] rule: eq [:BDEMOD] : (I:Int + J:Int)
   = #! (+ i j)
    { I:Int |-> -1, J:Int |-> 2 }
1<[44] (2 + -1) --> 1
[44]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: (2 + -1)) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: 1) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[45] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((pid :: 1) (np :: 3)), P:Pgm |-> ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end), 
      BP:BPgm |-> (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) }
1<[45] (((pid :: 1) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end))
     --> ((((pid :: 1) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) })) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))
[45]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: 1) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((pid :: 1) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) })) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[46] apply trial #1
-- rule: ctrans (S:Store (if E:Exp { P1:Pgm }))
   => (S P1) if ((S [ E ]) =/= 0)
    { E:Exp |-> (not (pid = 0)), S:Store |-> ((pid :: 1) (np :: 3)), P1:Pgm
       |-> ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }
2>[46] rule: eq (S:Store [ (not E:Exp) ])
   = (if ((S [ E ]) == 0) then 1 else 0 fi)
    { S:Store |-> ((pid :: 1) (np :: 3)), E:Exp |-> (pid = 0) }
2<[46] (((pid :: 1) (np :: 3)) [ (not (pid = 0)) ]) --> (if ((((pid :: 1) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi)
[46(cond)]: ((((pid :: 1) (np :: 3)) [ (not (pid = 0)) ]) =/= 0)
   --> ((if ((((pid :: 1) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi) =/= 0)
2>[47] rule: eq (S:Store [ (E1:Exp = E2:Exp) ])
   = (if ((S [ E1 ]) == (S [ E2 ])) then 1 else 0 fi)
    { E1:Exp |-> pid, S:Store |-> ((pid :: 1) (np :: 3)), E2:Exp |-> 0 }
2<[47] (((pid :: 1) (np :: 3)) [ (pid = 0) ]) --> (if ((((pid :: 1) (np :: 3)) [ pid ]) == (((pid :: 1) (np :: 3)) [ 0 ])) then 1 else 0 fi)
[47(cond)]: ((if ((((pid :: 1) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if ((((pid :: 1) (np :: 3)) [ pid ]) == (((pid :: 1) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[48] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((pid :: 1) (np :: 3)), A:Var |-> pid }
2<[48] (((pid :: 1) (np :: 3)) [ pid ]) --> val(pid,((pid :: 1) (np :: 3)))
[48(cond)]: ((if ((if ((((pid :: 1) (np :: 3)) [ pid ]) == (((pid :: 1) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if (val(pid,((pid :: 1) (np :: 3))) == (((pid :: 1) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[49] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> (np :: 3), I:Int |-> 1 }
2<[49] val(pid,((pid :: 1) (np :: 3))) --> 1
[49(cond)]: ((if ((if (val(pid,((pid :: 1) (np :: 3))) == (((pid :: 1) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if (1 == (((pid :: 1) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[50] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((pid :: 1) (np :: 3)), I:Int |-> 0 }
2<[50] (((pid :: 1) (np :: 3)) [ 0 ]) --> 0
[50(cond)]: ((if ((if (1 == (((pid :: 1) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if (1 == 0) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[51] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 1, CYU |-> 0 }
2<[51] (1 == 0) --> false
[51(cond)]: ((if ((if (1 == 0) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if false then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[52] rule: eq (if false then CXU else CYU fi)
   = CYU
    { CXU |-> 1, CYU |-> 0 }
2<[52] (if false then 1 else 0 fi) --> 0
[52(cond)]: ((if ((if false then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if (0 == 0) then 1 else 0 fi) =/= 0)
2>[53] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[53] (0 == 0) --> true
[53(cond)]: ((if (0 == 0) then 1 else 0 fi) =/= 0)
   --> ((if true then 1 else 0 fi) =/= 0)
2>[54] rule: eq (if true then CXU else CYU fi)
   = CXU
    { CXU |-> 1, CYU |-> 0 }
2<[54] (if true then 1 else 0 fi) --> 1
[54(cond)]: ((if true then 1 else 0 fi) =/= 0)
   --> (1 =/= 0)
2>[55] rule: eq (CXU =/= CYU) = #!! (coerce-to-bool (not (term-equational-equal cxu cyu)))
    { CXU |-> 1, CYU |-> 0 }
2<[55] (1 =/= 0) --> true
[55(cond)]: (1 =/= 0)
   --> true
1>[56] match success #1
1<[56] (((pid :: 1) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }))
     --> (((pid :: 1) (np :: 3)) ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))))
[56]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((pid :: 1) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) })) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((pid :: 1) (np :: 3)) ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[57] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((pid :: 1) (np :: 3)), P:Pgm |-> ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)), 
      BP:BPgm |-> (int x ;) }
1<[57] (((pid :: 1) (np :: 3)) ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))))
     --> ((((pid :: 1) (np :: 3)) (int x ;)) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)))
[57]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((pid :: 1) (np :: 3)) ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((((pid :: 1) (np :: 3)) (int x ;)) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[58] apply trial #1
-- rule: ctrans (S:Store (int A:Var ;))
   => S if in?(A,S)
    { S:Store |-> ((pid :: 1) (np :: 3)), A:Var |-> x }
2>[58] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> x, S:Store |-> (pid :: 1), Y:Var |-> np, I:Int |-> 3 }
2<[58] in?(x,((pid :: 1) (np :: 3))) --> ((x == np) or in?(x,(pid :: 1)))
[58(cond)]: in?(x,((pid :: 1) (np :: 3)))
   --> ((x == np) or in?(x,(pid :: 1)))
2>[59] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> np }
2<[59] (x == np) --> false
[59(cond)]: ((x == np) or in?(x,(pid :: 1)))
   --> (false or in?(x,(pid :: 1)))
2>[60] rule: eq in?(X:Var,(Y:Var :: I:Int))
   = (X == Y)
    { Y:Var |-> pid, X:Var |-> x, I:Int |-> 1 }
2<[60] in?(x,(pid :: 1)) --> (x == pid)
[60(cond)]: (false or in?(x,(pid :: 1)))
   --> (false or (x == pid))
2>[61] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> pid }
2<[61] (x == pid) --> false
[61(cond)]: (false or (x == pid))
   --> (false or false)
2>[62] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[62] (false or false) --> false
[62(cond)]: (false or false)
   --> false
1>[63] rewrite rule exhausted (#1)
1>[63] apply trial #1
-- rule: ctrans (S:Store (int A:Var ;))
   => ((A :: na) S) if (not in?(A,S))
    { S:Store |-> ((pid :: 1) (np :: 3)), A:Var |-> x }
2>[63] rule: eq (not A:Bool) = (A xor true)
    { A:Bool |-> in?(x,((pid :: 1) (np :: 3))) }
2<[63] (not in?(x,((pid :: 1) (np :: 3)))) --> (in?(x,((pid :: 1) (np :: 3))) xor true)
[63(cond)]: (not in?(x,((pid :: 1) (np :: 3))))
   --> (in?(x,((pid :: 1) (np :: 3))) xor true)
2>[64] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> x, S:Store |-> (pid :: 1), Y:Var |-> np, I:Int |-> 3 }
2<[64] in?(x,((pid :: 1) (np :: 3))) --> ((x == np) or in?(x,(pid :: 1)))
[64(cond)]: (in?(x,((pid :: 1) (np :: 3))) xor true)
   --> (((x == np) or in?(x,(pid :: 1))) xor true)
2>[65] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> np }
2<[65] (x == np) --> false
[65(cond)]: (((x == np) or in?(x,(pid :: 1))) xor true)
   --> ((false or in?(x,(pid :: 1))) xor true)
2>[66] rule: eq in?(X:Var,(Y:Var :: I:Int))
   = (X == Y)
    { Y:Var |-> pid, X:Var |-> x, I:Int |-> 1 }
2<[66] in?(x,(pid :: 1)) --> (x == pid)
[66(cond)]: ((false or in?(x,(pid :: 1))) xor true)
   --> ((false or (x == pid)) xor true)
2>[67] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> pid }
2<[67] (x == pid) --> false
[67(cond)]: ((false or (x == pid)) xor true)
   --> ((false or false) xor true)
2>[68] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[68] (false or false) --> false
[68(cond)]: ((false or false) xor true)
   --> (false xor true)
2>[69] rule: eq (false xor A:Bool) = A
    { A:Bool |-> true }
2<[69] (false xor true) --> true
[69(cond)]: (false xor true)
   --> true
1>[70] match success #1
1<[70] (((pid :: 1) (np :: 3)) (int x ;)) --> ((x :: na) ((pid :: 1) (np :: 3)))
[70]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((((pid :: 1) (np :: 3)) (int x ;)) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[71] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), P:Pgm |-> (recv ( x , 0 ) ;), 
      BP:BPgm |-> (send ( pid , 0 ) ;) }
1<[71] (((x :: na) ((pid :: 1) (np :: 3))) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;)))
     --> ((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (recv ( x , 0 ) ;))
[71]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[72] rule: eq (((S:Store BP:BPgm) P1:Pgm) P2:Pgm)
   = ((S BP) (P1 P2))
    { P1:Pgm |-> (recv ( x , 0 ) ;), BP:BPgm |-> (send ( pid , 0 ) ;), 
      S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), P2:Pgm |-> ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end) }
1<[72] (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))
     --> ((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) ((recv ( x , 0 ) ;) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)))
[72]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) ((recv ( x , 0 ) ;) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
1>[73] rule: eq [:BDEMOD] : (I:Int - J:Int)
   = (I + (- J))
    { I:Int |-> 2, J:Int |-> 1 }
1<[73] (2 - 1) --> (2 + (- 1))
[73]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 - 1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 + (- 1)))))
1>[74] rule: eq [:BDEMOD] : (- I:Int)
   = #! (- i)
    { I:Int |-> 1 }
1<[74] (- 1) --> -1
[74]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 + (- 1)))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 + -1))))
1>[75] rule: eq [:BDEMOD] : (I:Int + J:Int)
   = #! (+ i j)
    { I:Int |-> -1, J:Int |-> 2 }
1<[75] (2 + -1) --> 1
[75]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),(2 + -1))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),1)))
1>[76] apply trial #1
-- rule: ceq mpirun'(I:Int,P:Pgm,J:Int)
   = nil if (J < 1)
    { P:Pgm |-> (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end), 
      I:Int |-> 3, J:Int |-> 1 }
2>[76] rule: eq [:BDEMOD] : (NN:NzNat < NM:NzNat)
   = #! (< nn nm)
    { NN:NzNat |-> 1, NM:NzNat |-> 1 }
2<[76] (1 < 1) --> false
[76(cond)]: (1 < 1)
   --> false
1>[77] rewrite rule exhausted (#1)
1>[77] rule: eq mpirun'(I:Int,P:Pgm,1)
   = (((pid :: 0) (np :: I)) P)
    { I:Int |-> 3, P:Pgm |-> (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end) }
1<[77] mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),1)
     --> (((pid :: 0) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end))
[77]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | mpirun'(3,(((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end),1)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((pid :: 0) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end))))
1>[78] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((pid :: 0) (np :: 3)), P:Pgm |-> ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end), 
      BP:BPgm |-> (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) }
1<[78] (((pid :: 0) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end))
     --> ((((pid :: 0) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) })) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))
[78]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((pid :: 0) (np :: 3)) (((if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: 0) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) })) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))))
1>[79] apply trial #1
-- rule: ctrans (S:Store (if E:Exp { P1:Pgm }))
   => (S P1) if ((S [ E ]) =/= 0)
    { E:Exp |-> (not (pid = 0)), S:Store |-> ((pid :: 0) (np :: 3)), P1:Pgm
       |-> ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }
2>[79] rule: eq (S:Store [ (not E:Exp) ])
   = (if ((S [ E ]) == 0) then 1 else 0 fi)
    { S:Store |-> ((pid :: 0) (np :: 3)), E:Exp |-> (pid = 0) }
2<[79] (((pid :: 0) (np :: 3)) [ (not (pid = 0)) ]) --> (if ((((pid :: 0) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi)
[79(cond)]: ((((pid :: 0) (np :: 3)) [ (not (pid = 0)) ]) =/= 0)
   --> ((if ((((pid :: 0) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi) =/= 0)
2>[80] rule: eq (S:Store [ (E1:Exp = E2:Exp) ])
   = (if ((S [ E1 ]) == (S [ E2 ])) then 1 else 0 fi)
    { E1:Exp |-> pid, S:Store |-> ((pid :: 0) (np :: 3)), E2:Exp |-> 0 }
2<[80] (((pid :: 0) (np :: 3)) [ (pid = 0) ]) --> (if ((((pid :: 0) (np :: 3)) [ pid ]) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi)
[80(cond)]: ((if ((((pid :: 0) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if ((((pid :: 0) (np :: 3)) [ pid ]) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[81] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((pid :: 0) (np :: 3)), A:Var |-> pid }
2<[81] (((pid :: 0) (np :: 3)) [ pid ]) --> val(pid,((pid :: 0) (np :: 3)))
[81(cond)]: ((if ((if ((((pid :: 0) (np :: 3)) [ pid ]) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if (val(pid,((pid :: 0) (np :: 3))) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[82] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> (np :: 3), I:Int |-> 0 }
2<[82] val(pid,((pid :: 0) (np :: 3))) --> 0
[82(cond)]: ((if ((if (val(pid,((pid :: 0) (np :: 3))) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if (0 == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[83] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((pid :: 0) (np :: 3)), I:Int |-> 0 }
2<[83] (((pid :: 0) (np :: 3)) [ 0 ]) --> 0
[83(cond)]: ((if ((if (0 == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if (0 == 0) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[84] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[84] (0 == 0) --> true
[84(cond)]: ((if ((if (0 == 0) then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if ((if true then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
2>[85] rule: eq (if true then CXU else CYU fi)
   = CXU
    { CXU |-> 1, CYU |-> 0 }
2<[85] (if true then 1 else 0 fi) --> 1
[85(cond)]: ((if ((if true then 1 else 0 fi) == 0) then 1 else 0 fi) =/= 0)
   --> ((if (1 == 0) then 1 else 0 fi) =/= 0)
2>[86] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 1, CYU |-> 0 }
2<[86] (1 == 0) --> false
[86(cond)]: ((if (1 == 0) then 1 else 0 fi) =/= 0)
   --> ((if false then 1 else 0 fi) =/= 0)
2>[87] rule: eq (if false then CXU else CYU fi)
   = CYU
    { CXU |-> 1, CYU |-> 0 }
2<[87] (if false then 1 else 0 fi) --> 0
[87(cond)]: ((if false then 1 else 0 fi) =/= 0)
   --> (0 =/= 0)
2>[88] rule: eq (CXU =/= CYU) = #!! (coerce-to-bool (not (term-equational-equal cxu cyu)))
    { CXU |-> 0, CYU |-> 0 }
2<[88] (0 =/= 0) --> false
[88(cond)]: (0 =/= 0)
   --> false
1>[89] rewrite rule exhausted (#1)
1>[89] apply trial #1
-- rule: ctrans (S:Store (if E:Exp { P1:Pgm }))
   => S if ((S [ E ]) == 0)
    { E:Exp |-> (not (pid = 0)), S:Store |-> ((pid :: 0) (np :: 3)), P1:Pgm
       |-> ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }
2>[89] rule: eq (S:Store [ (not E:Exp) ])
   = (if ((S [ E ]) == 0) then 1 else 0 fi)
    { S:Store |-> ((pid :: 0) (np :: 3)), E:Exp |-> (pid = 0) }
2<[89] (((pid :: 0) (np :: 3)) [ (not (pid = 0)) ]) --> (if ((((pid :: 0) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi)
[89(cond)]: ((((pid :: 0) (np :: 3)) [ (not (pid = 0)) ]) == 0)
   --> ((if ((((pid :: 0) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi) == 0)
2>[90] rule: eq (S:Store [ (E1:Exp = E2:Exp) ])
   = (if ((S [ E1 ]) == (S [ E2 ])) then 1 else 0 fi)
    { E1:Exp |-> pid, S:Store |-> ((pid :: 0) (np :: 3)), E2:Exp |-> 0 }
2<[90] (((pid :: 0) (np :: 3)) [ (pid = 0) ]) --> (if ((((pid :: 0) (np :: 3)) [ pid ]) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi)
[90(cond)]: ((if ((((pid :: 0) (np :: 3)) [ (pid = 0) ]) == 0) then 1 else 0 fi) == 0)
   --> ((if ((if ((((pid :: 0) (np :: 3)) [ pid ]) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
2>[91] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((pid :: 0) (np :: 3)), A:Var |-> pid }
2<[91] (((pid :: 0) (np :: 3)) [ pid ]) --> val(pid,((pid :: 0) (np :: 3)))
[91(cond)]: ((if ((if ((((pid :: 0) (np :: 3)) [ pid ]) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
   --> ((if ((if (val(pid,((pid :: 0) (np :: 3))) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
2>[92] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> (np :: 3), I:Int |-> 0 }
2<[92] val(pid,((pid :: 0) (np :: 3))) --> 0
[92(cond)]: ((if ((if (val(pid,((pid :: 0) (np :: 3))) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
   --> ((if ((if (0 == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
2>[93] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((pid :: 0) (np :: 3)), I:Int |-> 0 }
2<[93] (((pid :: 0) (np :: 3)) [ 0 ]) --> 0
[93(cond)]: ((if ((if (0 == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
   --> ((if ((if (0 == 0) then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
2>[94] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[94] (0 == 0) --> true
[94(cond)]: ((if ((if (0 == 0) then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
   --> ((if ((if true then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
2>[95] rule: eq (if true then CXU else CYU fi)
   = CXU
    { CXU |-> 1, CYU |-> 0 }
2<[95] (if true then 1 else 0 fi) --> 1
[95(cond)]: ((if ((if true then 1 else 0 fi) == 0) then 1 else 0 fi) == 0)
   --> ((if (1 == 0) then 1 else 0 fi) == 0)
2>[96] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 1, CYU |-> 0 }
2<[96] (1 == 0) --> false
[96(cond)]: ((if (1 == 0) then 1 else 0 fi) == 0)
   --> ((if false then 1 else 0 fi) == 0)
2>[97] rule: eq (if false then CXU else CYU fi)
   = CYU
    { CXU |-> 1, CYU |-> 0 }
2<[97] (if false then 1 else 0 fi) --> 0
[97(cond)]: ((if false then 1 else 0 fi) == 0)
   --> (0 == 0)
2>[98] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[98] (0 == 0) --> true
[98(cond)]: (0 == 0)
   --> true
1>[99] match success #1
1<[99] (((pid :: 0) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) }))
     --> ((pid :: 0) (np :: 3))
[99]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: 0) (np :: 3)) (if (not (pid = 0)) { ((int x ;) ((send ( pid , 0 ) ;) (recv ( x , 0 ) ;))) })) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((pid :: 0) (np :: 3)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))))
1>[100] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((pid :: 0) (np :: 3)), P:Pgm |-> end, BP:BPgm |-> (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) }
1<[100] (((pid :: 0) (np :: 3)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))
     --> ((((pid :: 0) (np :: 3)) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)
[100]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((pid :: 0) (np :: 3)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: 0) (np :: 3)) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)))
1>[101] apply trial #1
-- rule: ctrans (S:Store (if E:Exp { P1:Pgm }))
   => (S P1) if ((S [ E ]) =/= 0)
    { E:Exp |-> (pid = 0), S:Store |-> ((pid :: 0) (np :: 3)), P1:Pgm |-> (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }
2>[101] rule: eq (S:Store [ (E1:Exp = E2:Exp) ])
   = (if ((S [ E1 ]) == (S [ E2 ])) then 1 else 0 fi)
    { E1:Exp |-> pid, S:Store |-> ((pid :: 0) (np :: 3)), E2:Exp |-> 0 }
2<[101] (((pid :: 0) (np :: 3)) [ (pid = 0) ]) --> (if ((((pid :: 0) (np :: 3)) [ pid ]) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi)
[101(cond)]: ((((pid :: 0) (np :: 3)) [ (pid = 0) ]) =/= 0)
   --> ((if ((((pid :: 0) (np :: 3)) [ pid ]) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) =/= 0)
2>[102] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((pid :: 0) (np :: 3)), A:Var |-> pid }
2<[102] (((pid :: 0) (np :: 3)) [ pid ]) --> val(pid,((pid :: 0) (np :: 3)))
[102(cond)]: ((if ((((pid :: 0) (np :: 3)) [ pid ]) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) =/= 0)
   --> ((if (val(pid,((pid :: 0) (np :: 3))) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) =/= 0)
2>[103] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> (np :: 3), I:Int |-> 0 }
2<[103] val(pid,((pid :: 0) (np :: 3))) --> 0
[103(cond)]: ((if (val(pid,((pid :: 0) (np :: 3))) == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) =/= 0)
   --> ((if (0 == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) =/= 0)
2>[104] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((pid :: 0) (np :: 3)), I:Int |-> 0 }
2<[104] (((pid :: 0) (np :: 3)) [ 0 ]) --> 0
[104(cond)]: ((if (0 == (((pid :: 0) (np :: 3)) [ 0 ])) then 1 else 0 fi) =/= 0)
   --> ((if (0 == 0) then 1 else 0 fi) =/= 0)
2>[105] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[105] (0 == 0) --> true
[105(cond)]: ((if (0 == 0) then 1 else 0 fi) =/= 0)
   --> ((if true then 1 else 0 fi) =/= 0)
2>[106] rule: eq (if true then CXU else CYU fi)
   = CXU
    { CXU |-> 1, CYU |-> 0 }
2<[106] (if true then 1 else 0 fi) --> 1
[106(cond)]: ((if true then 1 else 0 fi) =/= 0)
   --> (1 =/= 0)
2>[107] rule: eq (CXU =/= CYU) = #!! (coerce-to-bool (not (term-equational-equal cxu cyu)))
    { CXU |-> 1, CYU |-> 0 }
2<[107] (1 =/= 0) --> true
[107(cond)]: (1 =/= 0)
   --> true
1>[108] match success #1
1<[108] (((pid :: 0) (np :: 3)) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }))
     --> (((pid :: 0) (np :: 3)) (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))))
[108]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: 0) (np :: 3)) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: 0) (np :: 3)) (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))) end)))
1>[109] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((pid :: 0) (np :: 3)), P:Pgm |-> ((int i ;) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))), 
      BP:BPgm |-> (int x ;) }
1<[109] (((pid :: 0) (np :: 3)) (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))))
     --> ((((pid :: 0) (np :: 3)) (int x ;)) ((int i ;) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))))
[109]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((pid :: 0) (np :: 3)) (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((pid :: 0) (np :: 3)) (int x ;)) ((int i ;) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))) end)))
1>[110] apply trial #1
-- rule: ctrans (S:Store (int A:Var ;))
   => S if in?(A,S)
    { S:Store |-> ((pid :: 0) (np :: 3)), A:Var |-> x }
2>[110] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> x, S:Store |-> (pid :: 0), Y:Var |-> np, I:Int |-> 3 }
2<[110] in?(x,((pid :: 0) (np :: 3))) --> ((x == np) or in?(x,(pid :: 0)))
[110(cond)]: in?(x,((pid :: 0) (np :: 3)))
   --> ((x == np) or in?(x,(pid :: 0)))
2>[111] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> np }
2<[111] (x == np) --> false
[111(cond)]: ((x == np) or in?(x,(pid :: 0)))
   --> (false or in?(x,(pid :: 0)))
2>[112] rule: eq in?(X:Var,(Y:Var :: I:Int))
   = (X == Y)
    { Y:Var |-> pid, X:Var |-> x, I:Int |-> 0 }
2<[112] in?(x,(pid :: 0)) --> (x == pid)
[112(cond)]: (false or in?(x,(pid :: 0)))
   --> (false or (x == pid))
2>[113] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> pid }
2<[113] (x == pid) --> false
[113(cond)]: (false or (x == pid))
   --> (false or false)
2>[114] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[114] (false or false) --> false
[114(cond)]: (false or false)
   --> false
1>[115] rewrite rule exhausted (#1)
1>[115] apply trial #1
-- rule: ctrans (S:Store (int A:Var ;))
   => ((A :: na) S) if (not in?(A,S))
    { S:Store |-> ((pid :: 0) (np :: 3)), A:Var |-> x }
2>[115] rule: eq (not A:Bool) = (A xor true)
    { A:Bool |-> in?(x,((pid :: 0) (np :: 3))) }
2<[115] (not in?(x,((pid :: 0) (np :: 3)))) --> (in?(x,((pid :: 0) (np :: 3))) xor true)
[115(cond)]: (not in?(x,((pid :: 0) (np :: 3))))
   --> (in?(x,((pid :: 0) (np :: 3))) xor true)
2>[116] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> x, S:Store |-> (pid :: 0), Y:Var |-> np, I:Int |-> 3 }
2<[116] in?(x,((pid :: 0) (np :: 3))) --> ((x == np) or in?(x,(pid :: 0)))
[116(cond)]: (in?(x,((pid :: 0) (np :: 3))) xor true)
   --> (((x == np) or in?(x,(pid :: 0))) xor true)
2>[117] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> np }
2<[117] (x == np) --> false
[117(cond)]: (((x == np) or in?(x,(pid :: 0))) xor true)
   --> ((false or in?(x,(pid :: 0))) xor true)
2>[118] rule: eq in?(X:Var,(Y:Var :: I:Int))
   = (X == Y)
    { Y:Var |-> pid, X:Var |-> x, I:Int |-> 0 }
2<[118] in?(x,(pid :: 0)) --> (x == pid)
[118(cond)]: ((false or in?(x,(pid :: 0))) xor true)
   --> ((false or (x == pid)) xor true)
2>[119] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> x, CYU |-> pid }
2<[119] (x == pid) --> false
[119(cond)]: ((false or (x == pid)) xor true)
   --> ((false or false) xor true)
2>[120] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[120] (false or false) --> false
[120(cond)]: ((false or false) xor true)
   --> (false xor true)
2>[121] rule: eq (false xor A:Bool)
   = A
    { A:Bool |-> true }
2<[121] (false xor true) --> true
[121(cond)]: (false xor true)
   --> true
1>[122] match success #1
1<[122] (((pid :: 0) (np :: 3)) (int x ;)) --> ((x :: na) ((pid :: 0) (np :: 3)))
[122]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((pid :: 0) (np :: 3)) (int x ;)) ((int i ;) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((x :: na) ((pid :: 0) (np :: 3))) ((int i ;) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))) end)))
1>[123] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((x :: na) ((pid :: 0) (np :: 3))), P:Pgm |-> ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })), 
      BP:BPgm |-> (int i ;) }
1<[123] (((x :: na) ((pid :: 0) (np :: 3))) ((int i ;) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))))
     --> ((((x :: na) ((pid :: 0) (np :: 3))) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))
[123]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((x :: na) ((pid :: 0) (np :: 3))) ((int i ;) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 0) (np :: 3))) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end)))
1>[124] apply trial #1
-- rule: ctrans (S:Store (int A:Var ;))
   => S if in?(A,S)
    { S:Store |-> ((x :: na) ((pid :: 0) (np :: 3))), A:Var |-> i }
2>[124] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> i, S:Store |-> ((x :: na) (pid :: 0)), Y:Var |-> np, I:Int
       |-> 3 }
2<[124] in?(i,((x :: na) ((pid :: 0) (np :: 3)))) --> ((i == np) or in?(i,((x :: na) (pid :: 0))))
[124(cond)]: in?(i,((x :: na) ((pid :: 0) (np :: 3))))
   --> ((i == np) or in?(i,((x :: na) (pid :: 0))))
2>[125] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> np }
2<[125] (i == np) --> false
[125(cond)]: ((i == np) or in?(i,((x :: na) (pid :: 0))))
   --> (false or in?(i,((x :: na) (pid :: 0))))
2>[126] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> i, S:Store |-> (x :: na), Y:Var |-> pid, I:Int |-> 0 }
2<[126] in?(i,((x :: na) (pid :: 0))) --> ((i == pid) or in?(i,(x :: na)))
[126(cond)]: (false or in?(i,((x :: na) (pid :: 0))))
   --> (false or ((i == pid) or in?(i,(x :: na))))
2>[127] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> pid }
2<[127] (i == pid) --> false
[127(cond)]: (false or ((i == pid) or in?(i,(x :: na))))
   --> (false or (false or in?(i,(x :: na))))
2>[128] rule: eq in?(X:Var,(Y:Var :: I:Int))
   = (X == Y)
    { Y:Var |-> x, X:Var |-> i, I:Int |-> na }
2<[128] in?(i,(x :: na)) --> (i == x)
[128(cond)]: (false or (false or in?(i,(x :: na))))
   --> (false or (false or (i == x)))
2>[129] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> x }
2<[129] (i == x) --> false
[129(cond)]: (false or (false or (i == x)))
   --> (false or (false or false))
2>[130] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[130] (false or false) --> false
[130(cond)]: (false or (false or false))
   --> (false or false)
2>[131] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[131] (false or false) --> false
[131(cond)]: (false or false)
   --> false
1>[132] rewrite rule exhausted (#1)
1>[132] apply trial #1
-- rule: ctrans (S:Store (int A:Var ;))
   => ((A :: na) S) if (not in?(A,S))
    { S:Store |-> ((x :: na) ((pid :: 0) (np :: 3))), A:Var |-> i }
2>[132] rule: eq (not A:Bool) = (A xor true)
    { A:Bool |-> in?(i,((x :: na) ((pid :: 0) (np :: 3)))) }
2<[132] (not in?(i,((x :: na) ((pid :: 0) (np :: 3))))) --> (in?(i,((x :: na) ((pid :: 0) (np :: 3)))) xor true)
[132(cond)]: (not in?(i,((x :: na) ((pid :: 0) (np :: 3)))))
   --> (in?(i,((x :: na) ((pid :: 0) (np :: 3)))) xor true)
2>[133] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> i, S:Store |-> ((x :: na) (pid :: 0)), Y:Var |-> np, I:Int
       |-> 3 }
2<[133] in?(i,((x :: na) ((pid :: 0) (np :: 3)))) --> ((i == np) or in?(i,((x :: na) (pid :: 0))))
[133(cond)]: (in?(i,((x :: na) ((pid :: 0) (np :: 3)))) xor true)
   --> (((i == np) or in?(i,((x :: na) (pid :: 0)))) xor true)
2>[134] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> np }
2<[134] (i == np) --> false
[134(cond)]: (((i == np) or in?(i,((x :: na) (pid :: 0)))) xor true)
   --> ((false or in?(i,((x :: na) (pid :: 0)))) xor true)
2>[135] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> i, S:Store |-> (x :: na), Y:Var |-> pid, I:Int |-> 0 }
2<[135] in?(i,((x :: na) (pid :: 0))) --> ((i == pid) or in?(i,(x :: na)))
[135(cond)]: ((false or in?(i,((x :: na) (pid :: 0)))) xor true)
   --> ((false or ((i == pid) or in?(i,(x :: na)))) xor true)
2>[136] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> pid }
2<[136] (i == pid) --> false
[136(cond)]: ((false or ((i == pid) or in?(i,(x :: na)))) xor true)
   --> ((false or (false or in?(i,(x :: na)))) xor true)
2>[137] rule: eq in?(X:Var,(Y:Var :: I:Int))
   = (X == Y)
    { Y:Var |-> x, X:Var |-> i, I:Int |-> na }
2<[137] in?(i,(x :: na)) --> (i == x)
[137(cond)]: ((false or (false or in?(i,(x :: na)))) xor true)
   --> ((false or (false or (i == x))) xor true)
2>[138] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> x }
2<[138] (i == x) --> false
[138(cond)]: ((false or (false or (i == x))) xor true)
   --> ((false or (false or false)) xor true)
2>[139] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[139] (false or false) --> false
[139(cond)]: ((false or (false or false)) xor true)
   --> ((false or false) xor true)
2>[140] rule: eq (A:Bool or A) = A
    { A:Bool |-> false }
2<[140] (false or false) --> false
[140(cond)]: ((false or false) xor true)
   --> (false xor true)
2>[141] rule: eq (false xor A:Bool)
   = A
    { A:Bool |-> true }
2<[141] (false xor true) --> true
[141(cond)]: (false xor true)
   --> true
1>[142] match success #1
1<[142] (((x :: na) ((pid :: 0) (np :: 3))) (int i ;)) --> ((i :: na) ((x :: na) ((pid :: 0) (np :: 3))))
[142]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 0) (np :: 3))) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end)))
1>[143] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))), P:Pgm
       |-> (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }), 
      BP:BPgm |-> (i := 1 ;) }
1<[143] (((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))
     --> ((((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) (i := 1 ;)) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))
[143]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) (i := 1 ;)) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)))
1>[144] apply trial #1
-- rule: ctrans (S:Store (A:Var := E:Exp ;))
   => update(A,(S [ E ]),S) if in?(A,S)
    { A:Var |-> i, S:Store |-> ((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))), 
      E:Exp |-> 1 }
2>[144] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> i, S:Store |-> ((i :: na) ((x :: na) (pid :: 0))), Y:Var
       |-> np, I:Int |-> 3 }
2<[144] in?(i,((i :: na) ((x :: na) ((pid :: 0) (np :: 3))))) --> ((i == np) or in?(i,((i :: na) ((x :: na) (pid :: 0)))))
[144(cond)]: in?(i,((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))))
   --> ((i == np) or in?(i,((i :: na) ((x :: na) (pid :: 0)))))
2>[145] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> np }
2<[145] (i == np) --> false
[145(cond)]: ((i == np) or in?(i,((i :: na) ((x :: na) (pid :: 0)))))
   --> (false or in?(i,((i :: na) ((x :: na) (pid :: 0)))))
2>[146] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> i, S:Store |-> ((i :: na) (x :: na)), Y:Var |-> pid, I:Int
       |-> 0 }
2<[146] in?(i,((i :: na) ((x :: na) (pid :: 0)))) --> ((i == pid) or in?(i,((i :: na) (x :: na))))
[146(cond)]: (false or in?(i,((i :: na) ((x :: na) (pid :: 0)))))
   --> (false or ((i == pid) or in?(i,((i :: na) (x :: na)))))
2>[147] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> pid }
2<[147] (i == pid) --> false
[147(cond)]: (false or ((i == pid) or in?(i,((i :: na) (x :: na)))))
   --> (false or (false or in?(i,((i :: na) (x :: na)))))
2>[148] rule: eq in?(X:Var,((Y:Var :: I:Int) S:Store))
   = ((X == Y) or in?(X,S))
    { X:Var |-> i, S:Store |-> (i :: na), Y:Var |-> x, I:Int |-> na }
2<[148] in?(i,((i :: na) (x :: na))) --> ((i == x) or in?(i,(i :: na)))
[148(cond)]: (false or (false or in?(i,((i :: na) (x :: na)))))
   --> (false or (false or ((i == x) or in?(i,(i :: na)))))
2>[149] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> x }
2<[149] (i == x) --> false
[149(cond)]: (false or (false or ((i == x) or in?(i,(i :: na)))))
   --> (false or (false or (false or in?(i,(i :: na)))))
2>[150] rule: eq in?(X:Var,(Y:Var :: I:Int))
   = (X == Y)
    { Y:Var |-> i, X:Var |-> i, I:Int |-> na }
2<[150] in?(i,(i :: na)) --> (i == i)
[150(cond)]: (false or (false or (false or in?(i,(i :: na)))))
   --> (false or (false or (false or (i == i))))
2>[151] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> i, CYU |-> i }
2<[151] (i == i) --> true
[151(cond)]: (false or (false or (false or (i == i))))
   --> (false or (false or (false or true)))
2>[152] rule: eq (false or A:Bool) = A
    { A:Bool |-> true }
2<[152] (false or true) --> true
[152(cond)]: (false or (false or (false or true)))
   --> (false or (false or true))
2>[153] rule: eq (false or A:Bool) = A
    { A:Bool |-> true }
2<[153] (false or true) --> true
[153(cond)]: (false or (false or true))
   --> (false or true)
2>[154] rule: eq (false or A:Bool) = A
    { A:Bool |-> true }
2<[154] (false or true) --> true
[154(cond)]: (false or true)
   --> true
1>[155] match success #1
1<[155] (((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) (i := 1 ;))
     --> update(i,(((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) [ 1 ]),((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))))
[155]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) (i := 1 ;)) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((update(i,(((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) [ 1 ]),((i :: na) ((x :: na) ((pid :: 0) (np :: 3))))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)))
1>[156] rule: eq update(X:Var,I:Int,((X :: J:Int) S:Store))
   = ((X :: I) S)
    { X:Var |-> i, I:Int |-> (((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) [ 1 ]), 
      S:Store |-> ((x :: na) ((pid :: 0) (np :: 3))), J:Int |-> na }
1<[156] update(i,(((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) [ 1 ]),((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))))
     --> ((i :: (((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) [ 1 ])) ((x :: na) ((pid :: 0) (np :: 3))))
[156]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((update(i,(((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) [ 1 ]),((i :: na) ((x :: na) ((pid :: 0) (np :: 3))))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: (((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) [ 1 ])) ((x :: na) ((pid :: 0) (np :: 3)))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)))
1>[157] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))), I:Int
       |-> 1 }
1<[157] (((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) [ 1 ]) --> 1
[157]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: (((i :: na) ((x :: na) ((pid :: 0) (np :: 3)))) [ 1 ])) ((x :: na) ((pid :: 0) (np :: 3)))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)))
1>[158] apply trial #1
-- rule: ctrans (S:Store (while E:Exp { P:Pgm }))
   => (S (P (while E { P }))) if ((S [ E ]) =/= 0)
    { E:Exp |-> (np > i), S:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), 
      P:Pgm |-> ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }
2>[158] rule: eq (S:Store [ (E1:Exp > E2:Exp) ])
   = (if ((S [ E1 ]) > (S [ E2 ])) then 1 else 0 fi)
    { E1:Exp |-> np, S:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), 
      E2:Exp |-> i }
2<[158] (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ (np > i) ])
     --> (if ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ np ]) > (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ i ])) then 1 else 0 fi)
[158(cond)]: ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ (np > i) ]) =/= 0)
   --> ((if ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ np ]) > (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ i ])) then 1 else 0 fi) =/= 0)
2>[159] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), A:Var
       |-> np }
2<[159] (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ np ]) --> val(np,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))))
[159(cond)]: ((if ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ np ]) > (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ i ])) then 1 else 0 fi) =/= 0)
   --> ((if (val(np,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) > (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ i ])) then 1 else 0 fi) =/= 0)
2>[160] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> np, S:Store |-> ((i :: 1) ((x :: na) (pid :: 0))), I:Int
       |-> 3 }
2<[160] val(np,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) --> 3
[160(cond)]: ((if (val(np,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) > (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ i ])) then 1 else 0 fi) =/= 0)
   --> ((if (3 > (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ i ])) then 1 else 0 fi) =/= 0)
2>[161] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), A:Var
       |-> i }
2<[161] (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ i ]) --> val(i,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))))
[161(cond)]: ((if (3 > (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ i ])) then 1 else 0 fi) =/= 0)
   --> ((if (3 > val(i,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))))) then 1 else 0 fi) =/= 0)
2>[162] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> i, S:Store |-> ((x :: na) ((pid :: 0) (np :: 3))), I:Int
       |-> 1 }
2<[162] val(i,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) --> 1
[162(cond)]: ((if (3 > val(i,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))))) then 1 else 0 fi) =/= 0)
   --> ((if (3 > 1) then 1 else 0 fi) =/= 0)
2>[163] rule: eq [:BDEMOD] : (NN:NzNat > NM:NzNat)
   = #! (> nn nm)
    { NN:NzNat |-> 3, NM:NzNat |-> 1 }
2<[163] (3 > 1) --> true
[163(cond)]: ((if (3 > 1) then 1 else 0 fi) =/= 0)
   --> ((if true then 1 else 0 fi) =/= 0)
2>[164] rule: eq (if true then CXU else CYU fi)
   = CXU
    { CXU |-> 1, CYU |-> 0 }
2<[164] (if true then 1 else 0 fi) --> 1
[164(cond)]: ((if true then 1 else 0 fi) =/= 0)
   --> (1 =/= 0)
2>[165] rule: eq (CXU =/= CYU) = #!! (coerce-to-bool (not (term-equational-equal cxu cyu)))
    { CXU |-> 1, CYU |-> 0 }
2<[165] (1 =/= 0) --> true
[165(cond)]: (1 =/= 0)
   --> true
1>[166] match success #1
1<[166] (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))
     --> (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))
[166]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end)))
1>[167] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), P:Pgm
       |-> ((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))), 
      BP:BPgm |-> (recv ( x , any ) ;) }
1<[167] (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))
     --> ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (recv ( x , any ) ;)) ((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))))
[167]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (recv ( x , any ) ;)) ((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))) end)))
1>[168] rule: eq (((S:Store BP:BPgm) P1:Pgm) P2:Pgm)
   = ((S BP) (P1 P2))
    { P1:Pgm |-> ((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))), 
      BP:BPgm |-> (recv ( x , any ) ;), S:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), 
      P2:Pgm |-> end }
1<[168] (((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (recv ( x , any ) ;)) ((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))) end)
     --> ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (recv ( x , any ) ;)) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))
[168]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (recv ( x , any ) ;)) ((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })))) end)))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (recv ( x , any ) ;)) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
1>[169] apply trial #1
-- rule: ctrans (((S1:Store (send ( X1:Var , Dest:Exp ) ;)) P1:Pgm) | ((S2:Store (recv ( X2:Var , Source:Exp ) ;)) P2:Pgm))
   => ((S1 P1) | (update(X2,(S1 [ X1 ]),S2) P2)) if (((S1 [ Dest ]) == (S2 [ pid ])) and ((S1 [ pid ]) == (S2 [ Source ])))
    { S2:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), X2:Var
       |-> x, Source:Exp |-> any, P2:Pgm |-> (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end), 
      S1:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), X1:Var |-> pid, 
      Dest:Exp |-> 0, P1:Pgm |-> (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end) }
2>[169] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), I:Int |-> 0 }
2<[169] (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ]) --> 0
[169(cond)]: (((((x :: na) ((pid :: 1) (np :: 3))) [ 0 ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ pid ])) and ((((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
   --> ((0 == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ pid ])) and ((((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
2>[170] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), A:Var
       |-> pid }
2<[170] (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ pid ]) --> val(pid,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))))
[170(cond)]: ((0 == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ pid ])) and ((((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
   --> ((0 == val(pid,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))))) and ((((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
2>[171] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((i :: 1) ((x :: na) (np :: 3))), I:Int
       |-> 0 }
2<[171] val(pid,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) --> 0
[171(cond)]: ((0 == val(pid,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))))) and ((((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
   --> ((0 == 0) and ((((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
2>[172] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[172] (0 == 0) --> true
[172(cond)]: ((0 == 0) and ((((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
   --> (true and ((((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
2>[173] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), A:Var |-> pid }
2<[173] (((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) --> val(pid,((x :: na) ((pid :: 1) (np :: 3))))
[173(cond)]: (true and ((((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
   --> (true and (val(pid,((x :: na) ((pid :: 1) (np :: 3)))) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
2>[174] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((x :: na) (np :: 3)), I:Int |-> 1 }
2<[174] val(pid,((x :: na) ((pid :: 1) (np :: 3)))) --> 1
[174(cond)]: (true and (val(pid,((x :: na) ((pid :: 1) (np :: 3)))) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
   --> (true and (1 == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
2>[175] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 1, CYU |-> (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ]) }
2<[175] (1 == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ]))
     --> false
[175(cond)]: (true and (1 == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ any ])))
   --> (true and false)
2>[176] rule: eq (false and A:Bool)
   = false
    { A:Bool |-> true }
2<[176] (true and false) --> false
[176(cond)]: (true and false)
   --> false
1>[177] rewrite rule exhausted (#1)
1>[177] apply trial #1
-- rule: ctrans (((S1:Store (send ( X1:Var , Dest:Exp ) ;)) P1:Pgm) | ((S2:Store (recv ( X2:Var , any ) ;)) P2:Pgm))
   => ((S1 P1) | (update(X2,(S1 [ X1 ]),S2) P2)) if ((S1 [ Dest ]) == (S2 [ pid ]))
    { S2:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), X2:Var
       |-> x, P2:Pgm |-> (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end), 
      S1:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), X1:Var |-> pid, 
      Dest:Exp |-> 0, P1:Pgm |-> (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end) }
2>[177] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), I:Int |-> 0 }
2<[177] (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ]) --> 0
[177(cond)]: ((((x :: na) ((pid :: 1) (np :: 3))) [ 0 ]) == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ pid ]))
   --> (0 == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ pid ]))
2>[178] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))), A:Var
       |-> pid }
2<[178] (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ pid ]) --> val(pid,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))))
[178(cond)]: (0 == (((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) [ pid ]))
   --> (0 == val(pid,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))))
2>[179] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((i :: 1) ((x :: na) (np :: 3))), I:Int
       |-> 0 }
2<[179] val(pid,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) --> 0
[179(cond)]: (0 == val(pid,((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))))
   --> (0 == 0)
2>[180] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[180] (0 == 0) --> true
[180(cond)]: (0 == 0)
   --> true
1>[181] match success #1
1<[181] (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (recv ( x , any ) ;)) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end)))
     --> ((((x :: na) ((pid :: 1) (np :: 3))) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (update(x,(((x :: na) ((pid :: 1) (np :: 3))) [ pid ]),((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end)))
[181]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))) (recv ( x , any ) ;)) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((x :: na) ((pid :: 1) (np :: 3))) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (update(x,(((x :: na) ((pid :: 1) (np :: 3))) [ pid ]),((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
1>[182] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), P:Pgm |-> ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end), 
      BP:BPgm |-> (recv ( x , 0 ) ;) }
1<[182] (((x :: na) ((pid :: 1) (np :: 3))) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end))
     --> ((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end))
[182]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | ((((x :: na) ((pid :: 1) (np :: 3))) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (update(x,(((x :: na) ((pid :: 1) (np :: 3))) [ pid ]),((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | (update(x,(((x :: na) ((pid :: 1) (np :: 3))) [ pid ]),((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
1>[183] rule: eq update(X:Var,I:Int,((X :: J:Int) S:Store))
   = ((X :: I) S)
    { X:Var |-> x, I:Int |-> (((x :: na) ((pid :: 1) (np :: 3))) [ pid ]), 
      S:Store |-> ((i :: 1) ((pid :: 0) (np :: 3))), J:Int |-> na }
1<[183] update(x,(((x :: na) ((pid :: 1) (np :: 3))) [ pid ]),((i :: 1) ((x :: na) ((pid :: 0) (np :: 3)))))
     --> ((x :: (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) ((i :: 1) ((pid :: 0) (np :: 3))))
[183]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | (update(x,(((x :: na) ((pid :: 1) (np :: 3))) [ pid ]),((i :: 1) ((x :: na) ((pid :: 0) (np :: 3))))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | (((x :: (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) ((i :: 1) ((pid :: 0) (np :: 3)))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
1>[184] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), A:Var |-> pid }
1<[184] (((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) --> val(pid,((x :: na) ((pid :: 1) (np :: 3))))
[184]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | (((x :: (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) ((i :: 1) ((pid :: 0) (np :: 3)))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | (((x :: val(pid,((x :: na) ((pid :: 1) (np :: 3))))) ((i :: 1) ((pid :: 0) (np :: 3)))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
1>[185] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((x :: na) (np :: 3)), I:Int |-> 1 }
1<[185] val(pid,((x :: na) ((pid :: 1) (np :: 3)))) --> 1
[185]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | (((x :: val(pid,((x :: na) ((pid :: 1) (np :: 3))))) ((i :: 1) ((pid :: 0) (np :: 3)))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
1>[186] rule: trans (S:Store (BP:BPgm P:Pgm))
   => ((S BP) P)
    { S:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), P:Pgm |-> ((i := (i + 1) ;) ((while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }) end)), 
      BP:BPgm |-> (send ( x , (np - i) ) ;) }
1<[186] (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))
     --> ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) (send ( x , (np - i) ) ;)) ((i := (i + 1) ;) ((while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }) end)))
[186]: (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) (((send ( x , (np - i) ) ;) ((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) end))))
---> (((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) (send ( x , (np - i) ) ;)) ((i := (i + 1) ;) ((while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }) end)))))
1>[187] apply trial #1
-- rule: ctrans (((S1:Store (send ( X1:Var , Dest:Exp ) ;)) P1:Pgm) | ((S2:Store (recv ( X2:Var , Source:Exp ) ;)) P2:Pgm))
   => ((S1 P1) | (update(X2,(S1 [ X1 ]),S2) P2)) if (((S1 [ Dest ]) == (S2 [ pid ])) and ((S1 [ pid ]) == (S2 [ Source ])))
    { S2:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), X2:Var |-> x, Source:Exp
       |-> 0, P2:Pgm |-> ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end), 
      S1:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), X1:Var
       |-> x, Dest:Exp |-> (np - i), P1:Pgm |-> (((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end) }
2>[187] rule: eq (S:Store [ (E1:Exp - E2:Exp) ])
   = ((S [ E1 ]) - (S [ E2 ]))
    { E1:Exp |-> np, S:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), 
      E2:Exp |-> i }
2<[187] (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ (np - i) ])
     --> ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ np ]) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ]))
[187(cond)]: (((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ (np - i) ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ np ]) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[188] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), A:Var |-> np }
2<[188] (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ np ]) --> val(np,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))
[188(cond)]: ((((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ np ]) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((val(np,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[189] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> np, S:Store |-> ((x :: 1) ((i :: 1) (pid :: 0))), I:Int
       |-> 3 }
2<[189] val(np,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) --> 3
[189(cond)]: (((val(np,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[190] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), A:Var |-> i }
2<[190] (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ]) --> val(i,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))
[190(cond)]: (((3 - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 - val(i,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[191] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> i, S:Store |-> ((x :: 1) ((pid :: 0) (np :: 3))), I:Int
       |-> 1 }
2<[191] val(i,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) --> 1
[191(cond)]: (((3 - val(i,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 - 1) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[192] rule: eq [:BDEMOD] : (I:Int - J:Int)
   = (I + (- J))
    { I:Int |-> 3, J:Int |-> 1 }
2<[192] (3 - 1) --> (3 + (- 1))
[192(cond)]: (((3 - 1) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 + (- 1)) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[193] rule: eq [:BDEMOD] : (- I:Int)
   = #! (- i)
    { I:Int |-> 1 }
2<[193] (- 1) --> -1
[193(cond)]: (((3 + (- 1)) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 + -1) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[194] rule: eq [:BDEMOD] : (I:Int + J:Int)
   = #! (+ i j)
    { I:Int |-> -1, J:Int |-> 3 }
2<[194] (3 + -1) --> 2
[194(cond)]: (((3 + -1) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((2 == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[195] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), A:Var |-> pid }
2<[195] (((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) --> val(pid,((x :: na) ((pid :: 1) (np :: 3))))
[195(cond)]: ((2 == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((2 == val(pid,((x :: na) ((pid :: 1) (np :: 3))))) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[196] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((x :: na) (np :: 3)), I:Int |-> 1 }
2<[196] val(pid,((x :: na) ((pid :: 1) (np :: 3)))) --> 1
[196(cond)]: ((2 == val(pid,((x :: na) ((pid :: 1) (np :: 3))))) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((2 == 1) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[197] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 2, CYU |-> 1 }
2<[197] (2 == 1) --> false
[197(cond)]: ((2 == 1) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[198] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), A:Var |-> pid }
2<[198] (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) --> val(pid,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))
[198(cond)]: (false and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and (val(pid,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[199] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((x :: 1) ((i :: 1) (np :: 3))), I:Int
       |-> 0 }
2<[199] val(pid,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) --> 0
[199(cond)]: (false and (val(pid,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and (0 == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[200] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), I:Int |-> 0 }
2<[200] (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ]) --> 0
[200(cond)]: (false and (0 == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and (0 == 0))
2>[201] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[201] (0 == 0) --> true
[201(cond)]: (false and (0 == 0))
   --> (false and true)
2>[202] rule: eq (false and A:Bool)
   = false
    { A:Bool |-> true }
2<[202] (false and true) --> false
[202(cond)]: (false and true)
   --> false
1>[203] rewrite rule exhausted (#1)
1>[203] apply trial #1
-- rule: ctrans (AC:List | (((S1:Store (send ( X1:Var , Dest:Exp ) ;)) P1:Pgm) | ((S2:Store (recv ( X2:Var , Source:Exp ) ;)) P2:Pgm)))
   => (AC | ((S1 P1) | (update(X2,(S1 [ X1 ]),S2) P2))) if (((S1 [ Dest ]) == (S2 [ pid ])) and ((S1 [ pid ]) == (S2 [ Source ])))
    { AC:List |-> ((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)), 
      S1:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), X1:Var
       |-> x, Dest:Exp |-> (np - i), P1:Pgm |-> (((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end), 
      S2:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), X2:Var |-> x, Source:Exp
       |-> 0, P2:Pgm |-> ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end) }
2>[203] rule: eq (S:Store [ (E1:Exp - E2:Exp) ])
   = ((S [ E1 ]) - (S [ E2 ]))
    { E1:Exp |-> np, S:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), 
      E2:Exp |-> i }
2<[203] (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ (np - i) ])
     --> ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ np ]) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ]))
[203(cond)]: (((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ (np - i) ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ np ]) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[204] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), A:Var |-> np }
2<[204] (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ np ]) --> val(np,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))
[204(cond)]: ((((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ np ]) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((val(np,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[205] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> np, S:Store |-> ((x :: 1) ((i :: 1) (pid :: 0))), I:Int
       |-> 3 }
2<[205] val(np,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) --> 3
[205(cond)]: (((val(np,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[206] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), A:Var |-> i }
2<[206] (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ]) --> val(i,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))
[206(cond)]: (((3 - (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ i ])) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 - val(i,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[207] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> i, S:Store |-> ((x :: 1) ((pid :: 0) (np :: 3))), I:Int
       |-> 1 }
2<[207] val(i,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) --> 1
[207(cond)]: (((3 - val(i,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 - 1) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[208] rule: eq [:BDEMOD] : (I:Int - J:Int)
   = (I + (- J))
    { I:Int |-> 3, J:Int |-> 1 }
2<[208] (3 - 1) --> (3 + (- 1))
[208(cond)]: (((3 - 1) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 + (- 1)) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[209] rule: eq [:BDEMOD] : (- I:Int)
   = #! (- i)
    { I:Int |-> 1 }
2<[209] (- 1) --> -1
[209(cond)]: (((3 + (- 1)) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (((3 + -1) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[210] rule: eq [:BDEMOD] : (I:Int + J:Int)
   = #! (+ i j)
    { I:Int |-> -1, J:Int |-> 3 }
2<[210] (3 + -1) --> 2
[210(cond)]: (((3 + -1) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((2 == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[211] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), A:Var |-> pid }
2<[211] (((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) --> val(pid,((x :: na) ((pid :: 1) (np :: 3))))
[211(cond)]: ((2 == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((2 == val(pid,((x :: na) ((pid :: 1) (np :: 3))))) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[212] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((x :: na) (np :: 3)), I:Int |-> 1 }
2<[212] val(pid,((x :: na) ((pid :: 1) (np :: 3)))) --> 1
[212(cond)]: ((2 == val(pid,((x :: na) ((pid :: 1) (np :: 3))))) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((2 == 1) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[213] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 2, CYU |-> 1 }
2<[213] (2 == 1) --> false
[213(cond)]: ((2 == 1) and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[214] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))), A:Var |-> pid }
2<[214] (((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) --> val(pid,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))))
[214(cond)]: (false and ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and (val(pid,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[215] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((x :: 1) ((i :: 1) (np :: 3))), I:Int
       |-> 0 }
2<[215] val(pid,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) --> 0
[215(cond)]: (false and (val(pid,((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3))))) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and (0 == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[216] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), I:Int |-> 0 }
2<[216] (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ]) --> 0
[216(cond)]: (false and (0 == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and (0 == 0))
2>[217] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 0 }
2<[217] (0 == 0) --> true
[217(cond)]: (false and (0 == 0))
   --> (false and true)
2>[218] rule: eq (false and A:Bool)
   = false
    { A:Bool |-> true }
2<[218] (false and true) --> false
[218(cond)]: (false and true)
   --> false
1>[219] apply trial #1
-- rule: ctrans (AC:List | (((S1:Store (send ( X1:Var , Dest:Exp ) ;)) P1:Pgm) | ((S2:Store (recv ( X2:Var , Source:Exp ) ;)) P2:Pgm)))
   => (AC | ((S1 P1) | (update(X2,(S1 [ X1 ]),S2) P2))) if (((S1 [ Dest ]) == (S2 [ pid ])) and ((S1 [ pid ]) == (S2 [ Source ])))
    { AC:List |-> ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) (send ( x , (np - i) ) ;)) (((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)), 
      S1:Store |-> ((x :: na) ((pid :: 2) (np :: 3))), X1:Var |-> pid, 
      Dest:Exp |-> 0, P1:Pgm |-> (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end), 
      S2:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), X2:Var |-> x, Source:Exp
       |-> 0, P2:Pgm |-> ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end) }
2>[219] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((x :: na) ((pid :: 2) (np :: 3))), I:Int |-> 0 }
2<[219] (((x :: na) ((pid :: 2) (np :: 3))) [ 0 ]) --> 0
[219(cond)]: (((((x :: na) ((pid :: 2) (np :: 3))) [ 0 ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((0 == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[220] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), A:Var |-> pid }
2<[220] (((x :: na) ((pid :: 1) (np :: 3))) [ pid ]) --> val(pid,((x :: na) ((pid :: 1) (np :: 3))))
[220(cond)]: ((0 == (((x :: na) ((pid :: 1) (np :: 3))) [ pid ])) and ((((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((0 == val(pid,((x :: na) ((pid :: 1) (np :: 3))))) and ((((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[221] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((x :: na) (np :: 3)), I:Int |-> 1 }
2<[221] val(pid,((x :: na) ((pid :: 1) (np :: 3)))) --> 1
[221(cond)]: ((0 == val(pid,((x :: na) ((pid :: 1) (np :: 3))))) and ((((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> ((0 == 1) and ((((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[222] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 0, CYU |-> 1 }
2<[222] (0 == 1) --> false
[222(cond)]: ((0 == 1) and ((((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and ((((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[223] rule: eq (S:Store [ A:Var ])
   = val(A,S)
    { S:Store |-> ((x :: na) ((pid :: 2) (np :: 3))), A:Var |-> pid }
2<[223] (((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) --> val(pid,((x :: na) ((pid :: 2) (np :: 3))))
[223(cond)]: (false and ((((x :: na) ((pid :: 2) (np :: 3))) [ pid ]) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and (val(pid,((x :: na) ((pid :: 2) (np :: 3)))) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[224] rule: eq val(X:Var,((X :: I:Int) S:Store))
   = I
    { X:Var |-> pid, S:Store |-> ((x :: na) (np :: 3)), I:Int |-> 2 }
2<[224] val(pid,((x :: na) ((pid :: 2) (np :: 3)))) --> 2
[224(cond)]: (false and (val(pid,((x :: na) ((pid :: 2) (np :: 3)))) == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and (2 == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
2>[225] rule: eq (S:Store [ I:Int ])
   = I
    { S:Store |-> ((x :: na) ((pid :: 1) (np :: 3))), I:Int |-> 0 }
2<[225] (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ]) --> 0
[225(cond)]: (false and (2 == (((x :: na) ((pid :: 1) (np :: 3))) [ 0 ])))
   --> (false and (2 == 0))
2>[226] rule: eq (CXU == CYU) = #!! (coerce-to-bool (term-equational-equal cxu cyu))
    { CXU |-> 2, CYU |-> 0 }
2<[226] (2 == 0) --> false
[226(cond)]: (false and (2 == 0))
   --> (false and false)
2>[227] rule: eq (false and A:Bool)
   = false
    { A:Bool |-> false }
2<[227] (false and false) --> false
[227(cond)]: (false and false)
   --> false
1>[228] rewrite rule exhausted (#1)
(((((x :: na) ((pid :: 2) (np :: 3))) (send ( pid , 0 ) ;)) (((recv ( x , 0 ) ;) (if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) })) end)) | (((((x :: na) ((pid :: 1) (np :: 3))) (recv ( x , 0 ) ;)) ((if (pid = 0) { (((int x ;) (int i ;)) ((i := 1 ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) }))) }) end)) | ((((x :: 1) ((i :: 1) ((pid :: 0) (np :: 3)))) (send ( x , (np - i) ) ;)) (((i := (i + 1) ;) (while (np > i) { ((recv ( x , any ) ;) ((send ( x , (np - i) ) ;) (i := (i + 1) ;))) })) end)))):List
(0.000 sec for parse, 227 rewrites(1.670 sec), 783 matches)
SMPI> 
