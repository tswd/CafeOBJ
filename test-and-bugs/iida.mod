-- To: Razvan Diaconescu <diacon@jaist.ac.jp>
-- cc: goguen@cs.ucsd.edu, amori@cs.ucsd.edu, cerioli@disi.unige.it,
--         daia@stoilow.imar.ro, dlucanu@infoiasi.ro, grantm@comlab.ox.ac.uk,
--         grosu@cs.ucsd.edu, h-ishika@jaist.ac.jp, ishisone@sra.co.jp,
--         kokichi@jaist.ac.jp, mitihiro@jaist.ac.jp, n-ume@jaist.ac.jp,
--         nakagawa@sra.co.jp, nmihalac@stoilow.imar.ro, ogata@jaist.ac.jp,
--         sawada@sra.co.jp, vec@funinf.math.unibuc.ro, s_iida@jaist.ac.jp
-- Subject: Re: hidden vending machines with switch 
-- In-reply-to: Your message of "Sat, 27 Sep 1997 08:27:36 GMT."
--              <9709270827.AA09811@is27e0s07.jaist.ac.jp> 
-- Mime-Version: 1.0 (generated by tm-edit 7.106)
-- Date: Mon, 29 Sep 1997 11:52:24 JST
-- From: Shusaku Iida <s_iida@jaist.ac.jp>
-- Content-Type: text/plain; charset=US-ASCII
-- Content-Length: 5106

-- Dear all,

-- I have tried to speficy vending machines by using a parallel composition
-- of a cashier and a server. The cashier only deal with input and output of
-- coins and the server only deal with output of biscuits. The vending
-- machine is based on the last message by Prof. Goguen which accept $1 and
-- $2 coins and serve small or large biscuits (Tea and coffee example
-- should be more simple).

-- The followings are the data part of vending machines. We use sequence
-- for the output of vending machines.

-- ----------------------------------------------------
mod! SEQUENCE(X :: TRIV) {
  [ Seq ]

  op empty : -> Seq
  op __ : Elt Seq -> Seq { r-assoc id: empty }
}

mod! BISCUIT {
  [ Biscuit ]
  ops small large : -> Biscuit
}

mod! COIN {
  [ Coin ]
  ops $1 $2 : -> Coin
}
-- ----------------------------------------------------

-- The casher have two methods: put and take; and an atribute amount.
-- The result is an integer number, so we can lent from the cashier.

-- ----------------------------------------------------
mod* CASHIER {
  protecting(BISCUIT + COIN + INT)

  *[ Cashier ]*

  op init-cashier : -> Cashier
  bop put : Coin Cashier -> Cashier
  bop take : Coin Cashier -> Cashier
  bop amount : Cashier -> Int

  var C : Cashier

  eq amount(init-cashier) = 0 .
  eq amount(put($1, C)) = 1 + amount(C) .
  eq amount(put($2, C)) = 2 + amount(C) .
  eq amount(take($1, C)) = amount(C) - 1 .
  eq amount(take($2, C)) = amount(C) - 2 .
}
-- ----------------------------------------------------

-- The server have two methods: small and large; and an attribute out. 
-- The result of out is a sequence of biscuits.

-- ----------------------------------------------------
mod! BISCUIT-SEQUENCE {
  protecting(SEQUENCE(X <= view to BISCUIT { sort Elt -> Biscuit })
             *{ sort Seq -> Bseq })
}

mod* SERVER {
  protecting(BISCUIT-SEQUENCE + COIN) 

  *[ Server ]*

  op init-server : -> Server
  bop small : Server -> Server
  bop large : Server -> Server
  bop out : Server -> Bseq

  var S : Server

  eq out(init-server) = empty .
  eq out(small(S)) = small out(S) .
  eq out(large(S)) = large out(S) .
}
-- ----------------------------------------------------

-- We can obtain the vending machine by composing the cashier and the server.
-- Here, we introduce special operator called projection. A projection is
-- used for obtainning the composed object from the composing object(big one).
-- By using projection operators, we can describe how the mothods in the
-- composing object affect the state of composed objects. For example, in
-- this spec, I decided to ignore the action of pushing the button if there
-- is not enough coins (if you put just $1 and push the button for large
-- biscuit then the action is ignored). This is defined like:

--   bceq server(large(V)) = server(V)
--        if amount(cashier(V)) < 2 .

-- ----------------------------------------------------
mod* VM {
  protecting(CASHIER + SERVER)

  *[ Vm ]*

  op init-vm : -> Vm            -- initial state
  bop put : Coin Vm -> Vm       -- method
  bop small : Vm -> Vm          -- method
  bop large : Vm -> Vm          -- method
  bop change : Vm -> Vm         -- method
  bop out : Vm -> Bseq          -- attribute
  bop cashier : Vm -> Cashier   -- projection
  bop server : Vm -> Server     -- projection

  var V : Vm
  var C : Coin

  eq out(V) = out(server(V)) .

  beq cashier(init-vm) = init-cashier .
  beq cashier(put($1, V)) = put($1, cashier(V)) .
  beq cashier(put($2, V)) = put($2, cashier(V)) .
  bceq cashier(small(V)) = take($1, cashier(V))
       if amount(cashier(V)) >= 1 .
  bceq cashier(small(V)) = cashier(V)
       if amount(cashier(V)) < 1 .
  bceq cashier(large(V)) = take($2, cashier(V))
       if amount(cashier(V)) >= 2 .
  bceq cashier(small(V)) = cashier(V)
       if amount(cashier(V)) < 2 .
  beq cashier(change(V)) = init-cashier .

  beq server(init-vm) = init-server .
  beq server(put(C, V)) = server(V) .
  bceq server(small(V)) = small(server(V))
       if amount(cashier(V)) >= 1 .
  bceq server(small(V)) = server(V)
       if amount(cashier(V)) < 1 .
  bceq server(large(V)) = large(server(V))
       if amount(cashier(V)) >= 2 .
  bceq server(large(V)) = server(V)
       if amount(cashier(V)) < 2 .
  beq server(change(V)) = server(V) .
}
-- ----------------------------------------------------

-- We can play with this spec like:

-- VM> red out(small(large(put($2, put($2, init-vm))))) .
-- -- reduce in VM : out(small(large(put($2,put($2,init-vm)))))
-- small large : Bseq
-- (0.100 sec for parse, 97 rewrites(0.020 sec), 289 match attempts)

-- This means that putting two $2 coins and buy a small and a large biscuit.
-- Of cause, there should be $1 left in the vending machine and
-- it can be shown as:

-- VM> red amount(cashier(small(large(put($2, put($2, init-vm)))))) .
-- -- reduce in VM : amount(cashier(small(large(put($2,put($2,init-vm)
--     )))))
-- 1 : NzNat
-- (0.050 sec for parse, 142 rewrites(0.050 sec), 419 match attempts)

-- I am going to prove behavioural properies of this vending machine and
-- I will send them to you.
-- I hope you will enjoy this spec.

-- Best regards,
-- ----
-- Shusaku Iida (s_iida@jaist.ac.jp)
eof
