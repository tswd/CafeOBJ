Return-Path: masa@mri.co.jp 
Received: from srasva.sra.co.jp (root@srasva [133.137.12.2]) by sras75.sra.co.jp (8.6.13/3.4W-sra) with ESMTP id WAA21802; Tue, 14 Apr 1998 22:05:39 +0900
Received: from sranha.sra.co.jp (sranha [133.137.8.8])
	by srasva.sra.co.jp (8.8.7/3.6Wbeta7-srambox) with ESMTP id WAA29488;
	Tue, 14 Apr 1998 22:05:57 +0859 (JST)
Received: from sraigw.sra.co.jp (sraigw-hub [133.137.8.14])
	by sranha.sra.co.jp (8.8.7/3.6Wbeta7-sranha) with ESMTP id WAA20866;
	Tue, 14 Apr 1998 22:05:54 +0859 (JST)
Received: from amiskwia.mri.co.jp (amiskwia-1.mri.co.jp [133.148.48.10])
	by sraigw.sra.co.jp (8.8.7/3.6Wbeta7-sraigw) with ESMTP id WAA11986;
	Tue, 14 Apr 1998 22:05:42 +0900 (JST)
Received: from amiskwia.mri.co.jp (root@localhost [127.0.0.1]) by amiskwia.mri.co.jp (8.7.3/8.7.1) with SMTP id VAA26635; Tue, 14 Apr 1998 21:56:57 +0900
Message-Id: <199804141303.WAA11376@dolphine.mri.co.jp>
To: Akishi Seo <Akishi.Seo@unisys.co.jp>
cc: s_iida@jaist.ac.jp, sawada@sra.co.jp, ishisone@sra.co.jp,
        nakagawa@sra.co.jp, now@sra.co.jp, Tsutomu.Yamada@unisys.co.jp
Subject: Re: ICSE demo 
In-reply-to: Your message of "Tue, 14 Apr 1998 18:45:55 JST."
             <199804140945.SAA01008@medusa.as.unisys.co.jp> 
Mime-Version: 1.0 (generated by tm-edit 7.106)
Date: Tue, 14 Apr 1998 22:03:44 +0900
From: Masaki Ishiguro <masa@mri.co.jp>
Content-Type: text/plain; charset=ISO-2022-JP
Content-Length: 29270


>> From: Akishi Seo <Akishi.Seo@unisys.co.jp>
>> Subject: ICSE demo
>> Date: Tue, 14 Apr 1998 18:45:55 +0900

>> 以下のようなマシン構成で、澤田さんが memo 機能を加えてくれた
>> atm の例を brute を使って実行してみました。

この例に インタラクティブに実行できる部分をいくつか加えました． 

追加した内容は，Tutorial な意味合いを込め，behavioral equivalence と 
通常の equivalence の違いを簡約実行により示したり，CafeOBJの default
hidden congruence 生成とチェック機能を示すとともに，それが成功しない場
合については，manual で relation の定義，証明を行い，その後に特定の 
behavioral equation の証明を行ない， coindution の証明法を例示したりす
るなどです．
browsing するには，ファイルが大きいので，分割することで，ネットワーク文
書のアクセス方を示したり，その利点をアピールしたりできるかもしれません． 

文書による説明の方は，まだですが，現在，飯田さんも検討して下さっていま
す．

<html>
<head><title>ICSE98 DEMO</title></head>
<body>
<module name=ON-OFF>
-- -------------------------------------------------------------
-- Values of SWITCH
-- -------------------------------------------------------------
mod! ON-OFF {
  [ Value ]
  ops on off : -> Value
}
</module>

<module name=SWITCH>
-- -------------------------------------------------------------
-- SWITCH
-- -------------------------------------------------------------
mod* SWITCH {
  protecting(<modref context=#ON-OFF>ON-OFF</modref>)

  *[ Switch ]*

  op init-sw : -> Switch         -- initial state
  -- switch on
  bop on_ : Switch -> Switch     -- method
  -- switch off
  bop off_ : Switch -> Switch    -- method
  -- observe the state of the switch
  bop status_ : Switch -> Value   -- attribute

  var S : Switch

  eq status(init-sw) = off .
  eq status(on(S)) = on .
  eq status(off(S)) = off .
}
</module>

<module name=USER-ID>
-- -------------------------------------------------------------
-- User identification
-- -------------------------------------------------------------
mod! USER-ID {
  protecting(NAT)

  [ Nat < UId ]

  op unidentified-user : -> UId
}
</module>

<module name=COUNTER>
-- -------------------------------------------------------------
-- Counter
-- -------------------------------------------------------------
mod* COUNTER {
  protecting(<modref context=#USER-ID>USER-ID</modref> + INT)

  *[ Counter ]*

  -- initialize counter with user ID
  op init-counter : UId -> Counter   -- initial state
  -- add a value to the counter
  bop add : Int Counter -> Counter   -- method
  -- read the value of the counter
  bop read_ : Counter -> Int         -- attribute

  var I : Int
  var C : Counter
  var U : UId

  eq read(init-counter(U)) = 0 .
  eq read(add(I, C)) = I + read(C) .
}
</module>

<target name=COUNTER-TEST-RUNS>
-- Experimental runs
  op uid : -> UId .
  red read(add(20, add(80, init-counter(uid)))) .
  red read(add(80, add(20, init-counter(uid)))) .
-- Result of two commutative operations on a counter are not equivalant in a 
-- usual sense.
  ops n1 n2 : -> Int .
  red add(n1, add(n2, init-counter(uid))) == add(n2, add(n1, init-counter(uid))) .
</target>

<constraint context=#COUNTER
    solver=CafeOBJ
    target=#COUNTER-TEST-RUNS
    status=unsolved
    name=COUNTER-TEST-RUNS-CONSTR>
</constraint>

Prove some behavioral equation manually.

<module name=COUNTER-HCONGRUENCE>
mod! COUNTER-HCONGRUENCE {
  pr(<modref context=#COUNTER>COUNTER</modref>)
  op _R_ : Counter Counter -> Bool 
  vars C1 C2 : Counter 
  eq C1 R C2 = read(C1) == read(C2) . 
}
</module>

<target name=PROOF-COUNTER-HCONGRUENCE>
-- Prove correctness of hidden congruence R
  ops c1 c2 : -> Counter .
  eq read(c1) = read(c2) .
  op i : -> Int .
  red add(i, c1) R add(i, c2) .
</target>

<constraint
    context=#COUNTER-HCONGRUENCE
    solver=CafeOBJ
    target=#PROOF-COUNTER-HCONGRUENCE
    status=unsolved
    name=PROOF-COUNTER-HCONGRUENCE-CONSTR>
</constraint>

<target name=PROOF-COUNTER-BEQUIVALENCE>
-- Prove behavioral equavance of after twice 'add' operation commutatively
  ops n1 n2 : -> Int .
  op uid : -> UId .
  red add(n1, add(n2, init-counter(uid))) R add(n2, add(n1, init-counter(uid))) .
</target>

<constraint context=#COUNTER-HCONGRUENCE
    solver=CafeOBJ
    target=#PROOF-COUNTER-BEQUIVALENCE
    status=unsolved
    name=PROOF-COUNTER-BEQUIVALENCE-CONSTR>
</constraint>

CafeOBJ supports default hidden congruence and prove its correctness 
automatically in some cases.

<target name=PROOF-CAFE-BEQ-COUNTER-BEQUIVALENCE>
-- Prove by using CafeOBJ default hidden congruence "=*=".
  op uid : -> UId .
  ops n1 n2 : -> Int .
  red add(n1, add(n2, init-counter(uid))) =*= add(n2, add(n1, init-counter(uid))) .
</target>

<constraint context=#COUNTER-HCONGRUENCE
    solver=CafeOBJ
    target=#PROOF-CAFE-BEQ-COUNTER-BEQUIVALENCE
    status=unsolved
    name=PROOF-CAFE-BEQ-COUNTER-BEQUIVALENCE-CONSTR>
</constraint>

<module name=COUNTER*>
-- -------------------------------------------------------------
-- Counter with error
-- -------------------------------------------------------------
mod* COUNTER* {
  protecting(<modref context=#COUNTER>COUNTER</modref>)
  -- error value
  op counter-not-exist : -> Counter  -- error
}
</module>

<module name=ACCOUNT-SYSTEM>
-- -------------------------------------------------------------
-- Account sytem
-- -------------------------------------------------------------
mod* ACCOUNT-SYSTEM {
 protecting(<modref context=#COUNTER*>COUNTER*</modref>
	      *{ hsort Counter -> Account,
		 op init-counter -> init-account,
		 op counter-not-exist -> no-account })

  *[ AccountSys ]*

  op init-account-sys : -> AccountSys             -- initial state
  -- add a user account with user ID
  bop add : UId Nat AccountSys -> AccountSys       -- method
  -- delete a user account
  bop del : UId AccountSys -> AccountSys           -- method
  -- deposit operation
  bop deposit : UId Nat AccountSys -> AccountSys   -- method
  -- withdraw operation
  bop withdraw : UId Nat AccountSys -> AccountSys  -- method
  -- calculate the balance of an user account
  bop balance : UId AccountSys -> Nat              -- attribute
  -- get the state of a counter from the state of an account
  bop account : UId AccountSys -> Account {memo}         -- projection

  vars U U' : UId
  var A : AccountSys
  var N : Nat

  eq account(U, init-account-sys) = no-account .
  ceq account(U, add(U', N, A)) = add(N, init-account(U))
       if U == U' .
  ceq account(U, add(U', N, A)) = account(U, A)
       if U =/= U' .
  ceq account(U, del(U', A)) = no-account
       if U == U' .
  ceq account(U, del(U', A)) = account(U, A)
       if U =/= U' .
  ceq account(U, deposit(U', N, A)) = add(N, account(U, A))
       if U == U' .
  ceq account(U, deposit(U', N, A)) = account(U, A)
       if U =/= U' .
  ceq account(U, withdraw(U', N, A)) = add(-(N), account(U, A))
       if U == U' .
  ceq account(U, withdraw(U', N, A)) = account(U, A)
       if U =/= U' .

  eq balance(U, A) = read(account(U, A)) .
}
</module>

<target name=TEST-RUNS-ACCOUNT-SYSTEM>
-- Experimental runs
  ops uid1 uid2 : -> UId .
  red balance(uid1, deposit(uid1, 50, add(uid1, 100, init-account-sys))) .

-- Result of two different commutative deposit operation on a account system
-- are not behaviorally equivalent.
  ops n1 n2 : -> Nat .
  op as : -> AccountSys .
  red deposit(uid1, n1, deposit(uid1, n2, add(uid1, 0, as)))
      == deposit(uid1, n2, deposit(uid1, n1, add(uid1, 0, as))) .

-- CafeOBJ fails to prove default congruence relation.
  red deposit(uid1, n1, deposit(uid1, n2, add(uid1, 0, as)))
      =*= deposit(uid1, n2, deposit(uid1, n1, add(uid1, 0, as))) .
</target>

<constraint context=#ACCOUNT-SYSTEM
    solver=CafeOBJ
    target=#TEST-RUNS-ACCOUNT-SYSTEM
    status=unsolved
    name=TEST-RUNS-ACCOUNT-SYSTEM-CONSTR>
</constraint>

<module name=ACCOUNT-SYSTEM-HCONGRUENCE>
mod! ACCOUNT-SYSTEM-HCONGRUENCE {
  pr(<modref context=#ACCOUNT-SYSTEM>ACCOUNT-SYSTEM</modref>)

  op _R_ : AccountSys AccountSys -> Bool  -- hidden congruence for AccountSys
  vars AS1 AS2 : AccountSys 
  op uid : -> UId 
  eq AS1 R AS2 = (balance(uid, AS1) == balance(uid, AS2)) .
}
</module>

<target name=PROOF-ACCOUNT-SYSTEM-HCONGRUENCE>
-- Prove correctness of the hidden congruence R 
  ops as1 as2 : -> AccountSys .
  var UID : UId 
-- precondition
  eq balance(UID, as1) = balance(UID, as2) .
  eq read(account(UID, as1)) = read(account(UID, as2)) . -- derived from the above

  op uid' : -> UId .
  op n : -> Nat .
-- Actualy needs case analysis 1)  uid = uid 2) 'uid =/= uid'
  red add(uid', n, as1) R add(uid', n, as2) .           **> should be true 
  red del(uid', as1) R del(uid', as2) .                 **> should be true 
  red deposit(uid', n, as1) R deposit(uid', n, as2) .   **> should be true 
  red withdraw(uid', n, as1) R withdraw(uid', n, as2) . **> should be true 
</target>

<constraint context=#ACCOUNT-SYSTEM-HCONGRUENCE
    solver=CafeOBJ
    target=#PROOF-ACCOUNT-SYSTEM-HCONGRUENCE
    status=unsolved
    name=PROOF-ACCOUNT-SYSTEM-HCONGRUENCE-CONSTR>
</constraint>

<target name=PROOF-ACCOUNT-SYSTEM-BEQUIVALENCE>
  op as : -> AccountSys .
  ops n1 n2 : -> Nat .
  red deposit(uid, n1, deposit(uid, n2, add(uid, 0, as)))
      R deposit(uid, n2, deposit(uid, n1, add(uid, 0, as))) .
</target>

<constraint context=#ACCOUNT-SYSTEM-HCONGRUENCE
    solver=CafeOBJ
    target=#PROOF-ACCOUNT-SYSTEM-BEQUIVALENCE
    status=unsolved
    name=PROOF-ACCOUNT-SYSTEM-BEQUIVALENCE-CONSTR>
</constraint>


<module name=TRIV+>
-- -------------------------------------------------------------
-- Trivial module with an element (undefined)
-- -------------------------------------------------------------
mod* TRIV+ {
  [ Elt ]

  op undefined : -> Elt
}
</module>

<module name=CELL>
-- -------------------------------------------------------------
-- Cell
-- -------------------------------------------------------------
mod* CELL(X :: <modref context=#TRIV+>TRIV+</modref>) {
  *[ Cell ]*

  op init-cell : -> Cell      -- initial state
  -- put the element to the cell
  bop put : Elt Cell -> Cell  -- method
  -- get the element from the cell
  bop get : Cell -> Elt       -- attribute

  var E : Elt
  var C : Cell

  eq get(init-cell) = undefined .
  eq get(put(E, C)) = E .
}
</module>

<module name=ATM-ID>
-- -------------------------------------------------------------
-- ATM identifier
-- -------------------------------------------------------------
mod! ATM-ID {
  [ AId ]
--  protecting(NAT *{ sort Nat -> AId })
}
</module>

<module name=BUTTON>
-- -------------------------------------------------------------
--  Button
-- -------------------------------------------------------------
mod* BUTTON {
  protecting(<modref context=#SWITCH>SWITCH</modref>
               *{ hsort Switch -> Button,
                  sort Value -> Operation,
                  op init-sw -> init-button,
                  op on -> deposit,
                  op off -> withdraw })
}
</module>

<module name=CARD>
-- -------------------------------------------------------------
--  Cell for card information
-- -------------------------------------------------------------
mod* CARD {
  protecting(<modref context=#CELL>CELL</modref>
   (X <= view to <modref context=#USER-ID>USER-ID</modref>
                 { sort Elt -> UId,
                   op undefined -> unidentified-user })
                 *{ hsort Cell -> Card,
                    op init-cell -> init-card })
}
</module>

<module name=INPUT>
-- -------------------------------------------------------------
--  Cell for input
-- -------------------------------------------------------------
mod* INPUT {
  protecting(<modref context=#CELL>CELL</modref>(X <= view to NAT
                 { sort Elt -> Nat,
                   op undefined -> 0 })
                 *{ hsort Cell -> Input,
                    op init-cell -> init-input })
}
</module>

<module name=OUTPUT>
-- -------------------------------------------------------------
--  Cell for ouput
-- -------------------------------------------------------------
mod* OUTPUT {
  protecting(<modref context=#CELL>CELL</modref>
    (X <= view to NAT
		     { sort Elt -> Nat,
		       op undefined -> 0 })
	     *{ hsort Cell -> Output,
		op init-cell -> init-output })
}
</module>

<module name=REQUEST>
-- -------------------------------------------------------------
--  Cell for request
-- -------------------------------------------------------------
mod* REQUEST {
  protecting(<modref context=#CELL>CELL</modref>(X <= view to NAT
                  { sort Elt -> Nat,
                    op undefined -> 0 })
                  *{ hsort Cell -> Request,
                     op init-cell -> init-request })
}
</module>

<module name=ATM-CLIENT>
-- -------------------------------------------------------------
--  ATM client
-- -------------------------------------------------------------
mod* ATM-CLIENT {
-- importing data and the composing objects
  protecting(<modref context=#ATM-ID>ATM-ID</modref> + 
             <modref context=#BUTTON>BUTTON</modref> + 
             <modref context=#CARD>CARD</modref> + 
             <modref context=#INPUT>INPUT</modref> + 
             <modref context=#OUTPUT>OUTPUT</modref> + 
             <modref context=#REQUEST>REQUEST</modref>)

  *[ Atm ]*

  op init-atm : AId -> Atm              -- initial state
  op no-atm : -> Atm                    -- error
  op invalid-operation : -> Atm         -- error
  -- push the deposit button
  bop deposit : Atm -> Atm              -- method
  -- push the withdraw button
  bop withdraw : Atm -> Atm             -- method
  -- input the request for withdraw
  bop request : Nat Atm -> Atm          -- method
  -- put money
  bop put-money : Nat Atm -> Atm        -- method
  -- take money
  bop take-money : Atm -> Atm           -- mothod
  -- set money for output (system operation)
  bop set-money : Nat Atm -> Atm        -- method
  -- put the bank card
  bop put-card : UId Atm -> Atm         -- method
  -- clear all the informations kept in the atm
  bop clear : Atm -> Atm                -- method
  -- get the user ID
  bop user-id : Atm -> UId              -- attribute
  -- get the money that user input
  bop get-input : Atm -> Nat            -- attribute
  -- get the outputed money
  bop get-output : Atm -> Nat           -- attribute
  -- get the request
  bop get-request : Atm -> Nat          -- attribute
  -- get the state of the button
  bop button-status : Atm -> Operation  -- attribute

  bop button : Atm -> Button {memo}           -- projection
  bop card : Atm -> Card  {memo}              -- projection
  bop request : Atm -> Request {memo}         -- projection
  bop input : Atm -> Input  {memo}            -- projection
  bop output : Atm -> Output {memo}           -- projection

  var ATM : Atm
  var N : Nat
  var U : UId
  var A : AId

  eq button(init-atm(A)) = init-button .
  eq button(invalid-operation) = init-button .
  eq button(deposit(ATM)) = on(button(ATM)) .
  eq button(withdraw(ATM)) = off(button(ATM)) .
  eq button(request(N, ATM)) = button(ATM) .
  eq button(put-money(N, ATM)) = button(ATM) .
  eq button(take-money(ATM)) = button(ATM) .
  eq button(set-money(N, ATM)) = button(ATM) .
  eq button(put-card(U, ATM)) = button(ATM) .
  eq button(clear(ATM)) = init-button .

  eq card(init-atm(A)) = init-card .
  eq card(invalid-operation) = init-card .
  eq card(deposit(ATM)) = card(ATM) .
  eq card(withdraw(ATM)) = card(ATM) .
  eq card(request(N, ATM)) = card(ATM) .
  eq card(put-money(N, ATM)) = card(ATM) .
  eq card(take-money(ATM)) = card(ATM) .
  eq card(set-money(N, ATM)) = card(ATM) .
  eq card(put-card(U, ATM)) = put(U, card(ATM)) .
  eq card(clear(ATM)) = init-card .

  eq request(init-atm(A)) = init-request .
  eq request(invalid-operation) = init-request .
  eq request(deposit(ATM)) = request(ATM) .
  eq request(withdraw(ATM)) = request(ATM) .
  eq request(request(N, ATM)) = put(N, request(ATM)) .
  eq request(put-money(N, ATM)) = request(ATM) .
  eq request(take-money(ATM)) = request(ATM) .
  eq request(set-money(N, ATM)) = request(ATM) .
  eq request(put-card(U, ATM)) = request(ATM) .
  eq request(clear(ATM)) = init-request .

  eq input(init-atm(A)) = init-input .
  eq input(invalid-operation) = init-input .
  eq input(deposit(ATM)) = input(ATM) .
  eq input(withdraw(ATM)) = input(ATM) .
  eq input(request(N, ATM)) = input(ATM) .
  eq input(put-money(N, ATM)) = put(N, input(ATM)) .
  eq input(take-money(ATM)) = input(ATM) .
  eq input(set-money(N, ATM)) = input(ATM) .
  eq input(put-card(U, ATM)) = input(ATM) .
  eq input(clear(ATM)) = init-input .

  eq output(init-atm(A)) = init-output .
  eq output(invalid-operation) = init-output .
  eq output(deposit(ATM)) = output(ATM) .
  eq output(withdraw(ATM)) = output(ATM) .
  eq output(request(N, ATM)) = output(ATM) .
  eq output(put-money(N, ATM)) = output(ATM) .
  eq output(take-money(ATM)) = init-output .
  eq output(set-money(N, ATM)) = put(N, output(ATM)) .
  eq output(put-card(U, ATM)) = output(ATM) .
  eq output(clear(ATM)) = output(ATM) .

  eq user-id(ATM) = get(card(ATM)) .
  eq get-input(ATM) = get(input(ATM)) .
  eq get-output(ATM) = get(output(ATM)) .
  eq get-request(ATM) = get(request(ATM)) .
  eq button-status(ATM) = status(button(ATM)) .
}
</module>

<module name=ATM-SYSTEM>
mod* ATM-SYSTEM {
-- -------------------------------------------------------------
-- ATM system
-- -------------------------------------------------------------
  protecting(<modref context=#ACCOUNT-SYSTEM>ACCOUNT-SYSTEM</modref> + 
             <modref context=#ATM-CLIENT>ATM-CLIENT</modref>)

  *[ System ]*

  op init-sys : -> System                   -- initial state
  -- add an atm to the system
  bop add-atm : AId System -> System        -- method
  -- delete an atm from the system
  bop del-atm : AId System -> System        -- method
  -- add an user account
  bop add-user : UId Nat System -> System   -- method
  -- delete an user account
  bop del-user : UId System -> System       -- method
  -- put the bank card
  bop put-card : AId UId System -> System   -- method
  -- request for withdraw
  bop request : AId Nat System -> System    -- method
  -- put money
  bop put-money : AId Nat System -> System  -- method
  -- take money
  bop take-money : AId System -> System     -- method
  -- deposit operation
  bop deposit : AId System -> System        -- method
  -- withdraw operation
  bop withdraw : AId System -> System       -- method
  -- push the ok button on atm to complete the operation
  bop ok : AId System -> System             -- method
  -- cancel the operation of ATM
  bop cancel : AId System -> System         -- method
  -- get the balance of specified user
  bop balance : UId System -> Nat           -- attribute
  -- projection operator for AccountSys
  bop account-sys : System -> AccountSys { memo }   -- projection
  -- projection operator for Atm
  bop atm : AId System -> Atm { memo }              -- projection

  var S : System
  vars A A' : AId
  var U : UId
  var N : Nat

  eq balance(U, S) = balance(U, account-sys(S)) .

  eq account-sys(init-sys) = init-account-sys .
  eq account-sys(add-atm(A, S)) = account-sys(S) .
  eq account-sys(del-atm(A, S)) = account-sys(S) .
  eq account-sys(add-user(U, N, S)) = add(U, N, account-sys(S)) .
  eq account-sys(del-user(U, S)) = del(U, account-sys(S)) .
  eq account-sys(put-card(A, U, S)) = account-sys(S) .
  eq account-sys(request(A, N, S)) = account-sys(S) .
  eq account-sys(put-money(A, N, S)) = account-sys(S) .
  eq account-sys(take-money(A, S)) = account-sys(S) .
  eq account-sys(deposit(A, S)) = account-sys(S) .
  eq account-sys(withdraw(A, S)) = account-sys(S) .
  ceq account-sys(ok(A, S)) = 
       deposit(user-id(atm(A, S)), get-input(atm(A, S)), account-sys(S))
       if button-status(atm(A, S)) == deposit and-also
          user-id(atm(A, S)) =/= unidentified-user and-also
          get-input(atm(A, S)) =/= 0 .
  ceq account-sys(ok(A, S)) = 
       withdraw(user-id(atm(A, S)), get-request(atm(A, S)), account-sys(S))
       if button-status(atm(A, S)) == withdraw and-also
          user-id(atm(A, S)) =/= unidentified-user and-also
          get-request(atm(A, S)) =/= 0 and-also
          get-request(atm(A, S)) <=
                 balance(user-id(atm(A, S)), account-sys(S)) .
  ceq account-sys(ok(A, S)) = account-sys(S)
       if user-id(atm(A, S)) == unidentified-user or-else
          (button-status(atm(A, S)) == deposit and-also
              get-input(atm(A, S)) == 0) or-else
          (button-status(atm(A, S)) == withdraw and-also
              (get-request(atm(A, S)) == 0 or-else
              get-request(atm(A, S)) >
                       balance(user-id(atm(A, S)), account-sys(S)))) .
  eq account-sys(cancel(A, S)) = account-sys(S) .

  eq atm(A, init-sys) = no-atm .
  ceq atm(A, add-atm(A', S)) = init-atm(A)
       if A == A' .
  ceq atm(A, add-atm(A', S)) = atm(A, S)
       if A =/= A' .
  ceq atm(A, del-atm(A', S)) = no-atm
       if A == A .
  ceq atm(A, del-atm(A', S)) = atm(A, S)
       if A =/= A .
  eq atm(A, add-user(U, N, S)) = atm(A, S) .
  eq atm(A, del-user(U, S)) = atm(A, S) .
  ceq atm(A, put-card(A', U, S)) = put-card(U, atm(A, S))
       if A == A' .
  ceq atm(A, put-card(A', U, S)) = atm(A, S)
       if A =/= A' .
  ceq atm(A, request(A', N, S)) = request(N, atm(A, S))
       if A == A' .
  ceq atm(A, request(A', N, S)) = atm(A, S)
       if A =/= A' .
  ceq atm(A, put-money(A', N, S)) = put-money(N, atm(A, S))
       if A == A' .
  ceq atm(A, put-money(A', N, S)) = atm(A, S)
       if A =/= A' .
  ceq atm(A, take-money(A', S)) = take-money(atm(A, S))
       if A == A' .
  ceq atm(A, take-money(A', S)) = atm(A, S)
       if A =/= A' .
  ceq atm(A, deposit(A', S)) = deposit(atm(A, S))
       if A == A' .
  ceq atm(A, deposit(A', S)) = atm(A, S)
       if A =/= A' .
  ceq atm(A, withdraw(A', S)) = withdraw(atm(A, S))
       if A == A' .
  ceq atm(A, withdraw(A', S)) = atm(A, S)
       if A =/= A' .
  ceq atm(A, ok(A', S)) = clear(atm(A, S))
       if A == A' and-also
          user-id(atm(A, S)) =/= unidentified-user and-also
          button-status(atm(A, S)) == deposit .
  ceq atm(A, ok(A', S)) = set-money(get-request(atm(A, S)), clear(atm(A, S)))
       if A == A' and-also
          user-id(atm(A, S)) =/= unidentified-user and-also
          button-status(atm(A, S)) ==  withdraw and-also
          get-request(atm(A, S)) <=
                    balance(user-id(atm(A, S)), account-sys(S)) .
  ceq atm(A, ok(A', S)) = invalid-operation
       if A == A' and-also
          (user-id(atm(A, S)) == unidentified-user or-else
          (button-status(atm(A, S)) ==  withdraw and-also
              (get-request(atm(A, S)) >
                   balance(user-id(atm(A, S)), account-sys(S))))) .
  ceq atm(A, ok(A', S)) = atm(A, S)
       if A =/= A' .
  ceq atm(A, cancel(A', S)) = init-atm(A)
       if A == A' .
  ceq atm(A, cancel(A', S)) = atm(A, S)
       if A =/= A' .
}
</module>

<module name=ATM-SYSTEM-TOPLEVEL>
-- -------------------------------------------------------------
-- The toplevel of ATM system
-- -------------------------------------------------------------
mod* ATM-SYSTEM-TOPLEVEL {
  protecting(<modref context=#ATM-SYSTEM>ATM-SYSTEM</modref>)

  *[ TopLevel ]*

  op init-tl : -> TopLevel                         -- initial state
  -- add a new atm
  bop add-atm : AId TopLevel -> TopLevel           -- method
  -- delete an atm
  bop del-atm : AId TopLevel -> TopLevel           -- method
  -- create an user account with initial balance
  bop add-user : UId Nat TopLevel -> TopLevel      -- method
  -- delete an user account
  bop del-user : UId TopLevel -> TopLevel          -- method
  -- user "UId" goes to an ATM "AId" and deposit "Nat"
  bop deposit : UId AId Nat TopLevel -> TopLevel   -- method
  -- user "UId" goes to an ATM "AId" and withdraw "Nat"
  bop withdraw : UId AId Nat TopLevel -> TopLevel  -- method
  -- get a balance for the user
  bop balance : UId TopLevel -> Nat                -- attribute
  -- projection operator for System
  bop system : TopLevel -> System { memo }         -- projection

  var U : UId
  var A : AId
  var N : Nat
  var TL : TopLevel

  eq balance(U, TL) = balance(U, account-sys(system(TL))) .

  eq system(init-tl) = init-sys .
  eq system(add-atm(A, TL)) = add-atm(A, system(TL)) .
  eq system(del-atm(A, TL)) = del-atm(A, system(TL)) .
  eq system(add-user(U, N, TL)) = add-user(U, N, system(TL)) .
  eq system(del-user(U, TL)) = del-user(U, system(TL)) .
  eq system(deposit(U, A, N, TL)) =
     ok(A, put-money(A, N, deposit(A, put-card(A, U, system(TL))))) .
  eq system(withdraw(U, A, N, TL)) =
     take-money(A, ok(A, request(A, N, withdraw(A,
                put-card(A, U, system(TL)))))) .
}
</module>

<target name=TEST-RUN>
-- -------------------------------------------------------------
-- test for ATM-SYSTEM-TOPLEVEL
-- -------------------------------------------------------------
  op tl : -> TopLevel .
  ops u1 u2 : -> UId .
  ops ai1 ai2 : -> AId .

red balance(u1, deposit(u1, ai2, 20, add-user(u1, 100, tl))) .
red balance(u1, withdraw(u1, ai1, 20, withdraw(u2, ai2, 30,
            add-user(u1, 100, add-user(u2, 100, tl))))) .
</target>

<constraint context=#ATM-SYSTEM-TOPLEVEL
            solver=CafeOBJ
            target=#TEST-RUN
            status=unsolved
            name=CONSTR-TEST-RUN>
</constraint>

<module name=COINDUCTION-REL>
-- -------------------------------------------------------------
-- module for behavioural equivalences
-- -------------------------------------------------------------
mod COINDUCTION-REL {
  protecting(<modref context=#ATM-SYSTEM-TOPLEVEL>ATM-SYSTEM-TOPLEVEL</modref>)

-- behavioural equivalence for AccountSys
  op _R[_]_ : AccountSys UId AccountSys -> Bool {coherent}

  vars AS1 AS2 : AccountSys
  var U : UId 

  eq AS1 R[U] AS2 = account(U, AS1) =*= account(U, AS2) . 

-- behavioural equivalence for Atm
  op _R_ : Atm Atm -> Bool {coherent}

  vars A1 A2 : Atm

  eq A1 R A2 = button(A1) =*= button(A2) and-also
               card(A1) =*= card(A2) and-also
               request(A1) =*= request(A2) and-also
               input(A1) =*= input(A2) and-also
               output(A1) =*= output(A2) .

-- behavioural equivalence for System
  op _R[_,_]_ : System UId AId System -> Bool {coherent}

  vars S1 S2 : System
  var A : AId 

  eq S1 R[U, A] S2 = account-sys(S1) R[U] account-sys(S2) and-also
    atm(A, S1) R atm(A, S2) . 

-- behavioural equivalence for TopLevel
  op _R[_,_]_ : TopLevel UId AId TopLevel -> Bool {coherent}

  vars T1 T2 : TopLevel

  eq T1 R[U, A] T2 = system(T1) R[U, A] system(T2) .
}
</module>

<module name=PROOF>
mod PROOF {
  protecting(<modref context=#COINDUCTION-REL>COINDUCTION-REL</modref>)
  ops a a1 a2 : -> AId
  op tl : -> TopLevel
  ops u u1 u2 : -> UId
  ops n1 n2 n01 n02 m1 m1' m2 m2' m : -> Nat
  op state-of-system : Nat Nat -> TopLevel 
  ops w1w2 w2w1 : AId AId Nat Nat Nat Nat -> TopLevel 
  op TERM : UId AId AId AId Nat Nat Nat Nat -> Bool
  op TERM1 : UId AId AId AId Nat Nat -> Bool 
  op TERM2 : UId AId AId AId -> Bool 
  op TERM' : AId AId AId -> Bool 
  op RESULT :  -> Bool 

  vars A A1 A2 : AId
  var U : UId 
  vars N1 N2 M1 M2 : Nat 

  eq state-of-system(M1, M2) = add-user(u, m,
                               add-user(u1, M1,
	                       add-user(u2, M2,
                               add-atm(a,
                               add-atm(a1,
                               add-atm(a2, tl)))))) .
	                           
  eq w1w2(A1, A2, N1, N2, M1, M2) =
             withdraw(u1, A1, N1,
             withdraw(u2, A2, N2, state-of-system(M1, M2))) .

  eq w2w1(A1, A2, N1, N2, M1, M2) =
             withdraw(u2, A2, N2,
             withdraw(u1, A1, N1, state-of-system(M1, M2))) .

  eq TERM(U, A, A1, A2, N1, N2, M1, M2) =
       w1w2(A1,A2,N1,N2,M1,M2) R[U, A] w2w1(A1,A2,N1,N2,M1,M2) .

  eq TERM1(U, A, A1, A2, N2, M2) =
         TERM(U, A, A1, A2, n1, N2, m1, M2) and-also
	 TERM(U, A, A1, A2, n1, N2, m1', M2) and-also
	 TERM(U, A, A1, A2, n01, N2, m1, M2) .

  eq TERM2 (U, A, A1, A2) =
         TERM1(U, A, A1, A2, n2, m2) and-also
	 TERM1(U, A, A1, A2, n2, m2') and-also
	 TERM1(U, A, A1, A2, n02, m2) .
  
  eq TERM'(A, A1, A2) = TERM2(u,  A, A1, A2) and-also
                        TERM2(u1, A, A1, A2) and-also
			TERM2(u2, A, A1, A2) .

  eq RESULT = TERM'(a,  a1, a2) and-also
              TERM'(a,  a1, a1) and-also
              TERM'(a,  a,  a) and-also
              TERM'(a1, a1, a2) .
}
</module>

<target name=TRANS-CONSIST-GOAL>
-- set tram path brute
-- Case analysis conditions
  eq n1 =/= 0 = true .
  eq n2 =/= 0 = true .
  eq n01 == 0 = true .
  eq n02 == 0 = true .
  eq n1 <= m1 = true .
  eq n01 <= m1 = true .
  eq n1 > m1' = true .
  eq n2 <= m2 = true .
  eq n02 <= m2 = true .
  eq n2 > m2' = true .
-- reduce by Interpreter
-- reduce RESULT .
-- reduce by Brute
tram red RESULT .
</target>

<constraint context=#PROOF
            solver=CafeOBJ
            target=#TRANS-CONSIST-GOAL
            status=unsolved 
            name=TRANS-CONSIST-CONSTR>
</constraint>

</body>
</html>

