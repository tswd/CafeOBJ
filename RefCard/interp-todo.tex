% -*- Mode: LaTeX -*-
%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode
\documentclass[a4paper,oneside,twocolumn]{memoir}
\usepackage[hscale=0.8,vscale=0.8]{geometry}
\geometry{landscape}
\usepackage{multicol}

% \<...> - surrounds a variable name in a code example
\def\<#1>{\textit{#1\/}}
% kbd - argument is characters typed literally.  Like the Texinfo command.
\def\kbd#1{\texttt{#1}\null}        %\null so not an abbrev even if period follows
\def\cafeobj{{CafeOBJ}\null}

\begin{document}
\midsloppy
%%%%%%
\mainmatter

%\title{\centerline{\bcafeobj\ Commands}}
%\title{\centerline{Quick Reference}}

%\centerline{(for interpreter version 1.4.8)}

\section{Notation}

Keywords apper in \kbd{type setter face},
when presented in the form like `x(yz)' it means the keyword `xyz'
can be abbreviated to `x'.
`[something]' means `something' is optional.
\kbd{|} is used for listing alternatives.
Slanted face, e.g., \<variety> is used when it varies (a
meta-variable) or is an expression of some language. For example,
\<modexp> is for module expressions and \<term> is for terms (you
should know what these are); others should easily be understood by
their \<name>s and/or from the context. 
%%%%% starting cafeobj
\section{Starting \cafeobj\ interpreter}

To enter \cafeobj, just type its name: \kbd{cafeobj}

`\kbd{cafeobj -help}' will show you a summary of command options. 

%%%%% leaving cafeobj
\section{Leaving \cafeobj}

\kbd{q(uit)} exits \cafeobj.

%%%%% getting little help
\section{Getting Little Help}

Typing \kbd{?} at the top-level prompt will print out a list of whole
top-level commands.

%%%%% escape
\section{Escape}

There would be a situation that you hit \kbd{return} expecting some feedback from the interpreter, but it does not respond. 
This occurs when the interpreter expects some more inputs from you thinking
preceding input is not yet syntactically complete. If you encounter this situation, 
and you don't know what the interpreter expects, 
simply type in \kbd{esc}(escape key) and \kbd{return}, then it will
immediately be back to you discarding preceding input
and makes a fresh start. Alternatively, you can type in several \kbd{return} keys. This acts exactly the same as typing \kbd{esc} and \kbd{return}. 

%%%%% rescue
\section{Rescue}

Occasionally you may meet a strange prompt \kbd{CHAOS>>} after some
error messages. This happens when the interpreter caused some internal
errors and could not recover from it. Try typing \kbd{:q}, this may
resume the session if you are lucky. 

Sending interrupt signal (typing \kbd{C-c} from keyboard, or if you
are in Emacs, some key sequence specific to the \<mode> you are in)
forces the interpreter to break into underlying Lisp, and you will see
the same prompt as the above. 
This might be useful when you feel the interpreter get confused.
\kbd{:q} also works for returning to \cafeobj\ interpreter from Lisp.

%%%%%% setting switches
\section{Setting Switches}

Switches are for controlling the interpreter's behaviour in several manner.
The general form of setting top-level switch is:

\ \ \kbd{set} {\textit{switch value\/} }

In the following, the default value of a switch is shown
underlined.

%% \paralign to \hsize{#\tabskip=8pt plus 1 fil&#\tabskip=0pt&#\cr
\begin{multicols}{3}
\textbf{switch}}{\textbf{ value}}{\textbf{ what?}}
***
{-- switches for rewriting}
\threecol{trace whole}{on|\ul{off}}{trace top-level rewrite step}
\threecol{trace}{on|\ul{off}}{trace every rewrite step}
\threecol{step}{on|\ul{off}}{stepwise rewriting process}
\threecol{memo}{\ul{on}|off}{enable term memoization}
\threecol{clean memo}{on|\ul{off}}{clean up term memo table}
\threecol{}{}{before normalization}
\threecol{stats}{\ul{on}|off}{show statistics data after reduction}
\threecol{rwt limit} {{\<number>}}{maximum number of rewriting}
\threecol{stop pattern}{[{\<term>}] .}{stop rewriting when meets}
\threecol{mel sort}{on|\ul{off}}{compute result sort with}
\threecol{}{}{sort membership predicates}
\threecol{reduce conditions}{on|\ul{off}}{reduce conditional part in}
\threecol{}{}{apply command}
\threecol{verbose}{on|\ul{off}}{set verbose mode}
\threecol{exec trace}{on|\ul{off}}{trace concurrent execution}
\threecol{exec limit}{{\<number>}}{limit maximum number of}
\threecol{}{}{concurrent execution}
\threecol{exec normalize}{\ul{on}|off}{reduce term before and after}
\threecol{}{}{each transition}
\threecol{exec all}{\ul{on}|off}{find all solutions of \kbd{=(*)=>}}
***
\threecol{}{}{-- switches for system's behaviour}
\threecol{include BOOL}{\ul{on}|off}{import BOOL implicitly}
\threecol{incude RWL}{\ul{on}|off}{import RWL implicitly}
\threecol{include FOPL-CLAUSE}{\ul{on}|off}{import FOPL-CLAUSE
  implicitly}
\threecol{auto context}{on|\ul{off}}{change current context in
  automatic}
\threecol{auto reconstruct}{on|\ul{off}}{perform automatic reconstruction}
\threecol{}{}{of modules if it is inconsistent}
\threecol{reg signature}{on|\ul{off}}{regularize module signature}
\threecol{}{}{in automatic}
\threecol{check regularity}{on|\ul{off}}{perform regularity check of}
\threecol{}{}{signature in automatic}
\threecol{check compatibility}{on|\ul{off}}{perform compatibility check}
\threecol{}{}{of TRS in automatic}
\threecol{check builtin}{\ul{on}|off}{perform operator overloading}
\threecol{}{}{check with built-in sorts}
\threecol{select term}{on|\ul{off}}{system selects a term from}
\threecol{}{}{ambiguously parsed terms}
\threecol{quiet}{on|\ul{off}}{system mostly says nothing}
%%
\threecol{}{}{-- show/display options}
\threecol{all axioms}{on|\ul{off}}{print all axioms in}
\threecol{}{}{"\kbd{sh(ow) \<modexp>}" command} 
\threecol{show mode}{\ul{:cafeobj}}{set syntax of printed
  modules}
\threecol{}{|:chaos}{or views}
\threecol{show var sorts}{on|\ul{off}}{print variables with sorts}
\threecol{print mode}{\ul{:normal}}{set term priting form}
\threecol{}{|:fancy}{}
\threecol{}{|:tree} {}
\threecol{}{|:s-expr}{}
***
\threecol{}{}{-- miscellaneous settings}
\threecol{libpath}{\<pathname>}{set file search path}
\threecol{print depth}{{\<number>}}{maximum depth of terms}
\threecol{}{}{ to be  printed}
\threecol{accept \kbd{=*=} proof}{on|\ul{off}}{accept system's  automatic}
\threecol{}{}{ proof of congruency of \kbd{=*=}}
%%%%%
}

The default value of \<pathname> of \kbd{set libpath} command is
`\$cafeobjhome/lib, \$cafeobjhome/exs',
where `\$cafeobjhome' varies depending on the installation options
of your interpreter. Normally, it is \kbd{/usr/local/lib/cafeobj1.4}.

The default value of \<number> in `set rwt limit' command is 0 meaning
no limit counter of rewriting is specified.

Omitting \<term> in \kbd{set stop pattern} sets the stop pattern to
empty, i.e., no term will match to the pattern.

%%%% getting values of switches
\section{Examining Values of Switches}

%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{show switch}{{\rm print list of available switches}}
\twocol{}{{\rm with their values}}
\twocol{show switch \textit{switch}}{{\rm print out the value of the}}
\twocol{}{{\rm specified} \textit{switch}}
}
%%% setting context
\section{Setting Context}

\kbd{select} {\<modexp>}

This sets the context of the interpreter (\textbf{ current module})
to the module specified by \<modexp>.
It must be written in single line. 
When you type in \<modexp>, the `\kbd{;}$<$newline$>$' treated as a
line continuation (that is, it is effectively ignored), so that you
can type in multiple lines for long module expressions. Note that one
or more blank characters are required before \kbd{;}.

%%%% inspecting modules
\section{Inspecting Module}

\kbd{sh(ow)} and \kbd{desc(ribe)} commands print information on a module. 
In the sequel, we use a meta-variable \<show> which stands for
either \kbd{sh(ow)} or \kbd{desc(ribe)}. Most of the cases, 
giving \kbd{desc(ribe)} for \<show> gives you more detailed
information. 

%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{\<show> \<modexp>}{prints a module \<modexp>. giving `\kbd{.}''}
\twocol{}{as \<modexp> shows the current module}
\twocol{\<show> sorts [\<modexp>]}{prints sorts of \<modexp>}
\twocol{\<show> ops [\<modexp>]}{prints operators of \<modexp>}
\twocol{\<show> vars [\<modexp>]}{prints variables of \<modexp>}
\twocol{\<show> params [\<modexp>]}{prints parameters of \<modexp>}
\twocol{\<show> subs [\<modexp>]}{prints direct submodules of \<modexp>}
\twocol{\<show> sign [\<modexp>]}{prints \kbd{sorts} and \kbd{ops} combined}
}

\<modexp> must be given in an one line. 
The same convention for long module expressions is used as that of
\kbd{select} command (see \textbf{ Setting Context} above.)
If the optional [\<modexp>] is omitted, it defaults to the current
module. 
Optionally supplying \kbd{all} before \kbd{sorts}, \kbd{ops},  
\kbd{axioms}, and \kbd{sign}, i.e., \kbd{desc all ops} for an instance)
makes printed out information also include imported sorts, operators, etc.
otherwise it only prints own constructs of the \<modexp>.

The following \<show> commands assume the current
module is set to some module.
%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{\<show> sort \<sort>}{prints information on sort \<sort>}
\twocol{\<show> op \<operator>}{prints information on operator
  \<operaotr>}
}

For inspecting submodules or parameters, the following \<show>
commands are useful:
%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{\<show> param \<argname>}{prints information on the parameter}
\twocol{\<show> sub \<n>}{prints information on the \<n>th direct}
\twocol{}{submodule}
}
\<argname> can be given by position, not by name. 

You can see the hierarchy of a module or a sort by the follwing
\kbd{sh(ow)} commands:
%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{sh(ow) module tree \<modexp>}{prints pictorial hierarchy of
  module.}
\twocol{}{specifying \kbd{.} as \<modexp> shows the}
\twocol{}{hierarcy of the current module}
\twocol{sh(ow) sort tree \<sort>}{prints hierarchy of sort pictorially}  
}

%%% Evaluating terms
\section{Evaluating Terms}

\kbd{red(uce)} [\kbd{in} \<modexp> \kbd{:}] \<term> \kbd{.}

\kbd{exec(ute)} [\kbd{in} \<modexp> \kbd{:}] \<term> \kbd{.}

\kbd{reduce} reduces a given term \<term> in the term rewriting system
derived from \<modexp>.
\kbd{execute} is similar to \kbd{reduce}, but it also considers axioms 
given by \textbf{ transition} declarations.
In both cases, omitted `\kbd{in} \<modexp> \kbd{:}' defaults to the current module.

The result term of \kbd{reduce} and \kbd{execute} is bould to 
special variables \kbd{\$\$term} and \kbd{\$\$subterm} (see the next
section). 

%%% Let variables and special variables
\section{Let Variables and Special Variables}

\kbd{let} \<let-variable> \kbd{=} \<term> \kbd{.}

\<let-variable> is an indentifier. Assuming the current module is set, 
\kbd{let} binds \<let-variable> to the given term \<term>.
Once set, \<let-variable> can be used wherever \<term> can apper.

You can see the list of let bidings by:

\kbd{sh(ow) let}

There are two built-in special variables in the system:
%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{\$\$term}{bound to the result term of \kbd{reduce}, \kbd{execute},}
\twocol{}{\kbd{parse}, or \kbd{start} commands.}
\twocol{\$\$subterm}{bound to the result of \kbd{choose} command}
}

Let variales and special variables belongs to a context, i.e., each
context has its own let variables and special variables.

%%%% \newcolumn
%%%% Inspecting terms
\section{Inspecting Terms}
\kbd{parse} [\kbd{in} \<modexp> \kbd{:}] \<term> \kbd{.}

\kbd{parse} parses given term \<term> in the module \<modexp> (if
omitted, parses in the current module) and prints the result.
The result is bound to special variables \kbd{\$\$term} and
\kbd{\$\$subterm}. 

The following \kbd{sh(ow)} command assumes the current module, and
prints the term.

\kbd{sh(ow) term} [\<let-variable>] [\kbd{tree}]

\<let-variable> can be a name of \<let-variable>, \kbd{\$\$term} or
\kbd{\$\$subterm}, if omitted the term bound to \kbd{\$\$term} is
printed.  If optional \kbd{tree} is supplied, it prints the term tree 
structure. 

%%% open/closing module
\section{Opening/Closing Module}

%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{open \<modexp>}{opens module \<modexp>}
\twocol{close}{close the currently opening module}
}
Opening module can be modified, i.e., you can declare new sorts,
operators, axioms. You can open only one module at a time.

%%%% applying rewrite rules
\section{Applying Rewrite Rules}

\paragraph{Start}
The initial target (entire term) is set by \kbd{start} command.

\kbd{start} \<term> .

This binds two special variables \kbd{\$\$term} and
\kbd{\$\$subterm} to \<term>. 

\paragraph{Apply}
\kbd{apply} command applies actions to (subterm of) \kbd{\$\$term}.

\kbd{apply} \<action> \<range> \<selection>

You specify an action by \<action>, and it will be applied to the
target (sub)term specified by \<selection>. 

\<range> is either \kbd{within} or \kbd{at}: \kbd{within} means at or
inside the  (sub)term specified by the \<selection>, and \kbd{at}
means exactly at the \<selection>.

\paragraph{Action}
\<action> can be the followings:
%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{red(uction)}{reduce the selected term}
\twocol{exec}{execute the selected term}
\twocol{print}{print the selected term}
\twocol{\<rule-spec>}{apply specified rule to the selected term}
}

\paragraph{Rule-Spec}
\<rule-spec> specifies the rule with possibly substitutions being
applied, and given by 

[\kbd{+ | -}][\<modexp>].\<rule-name> [\<substitutions>]

The first optional `\kbd{+ | -}' specifies the direction of the rule; 
left to right(if \kbd{+} or omitted) or right to left (if \kbd{-}).

A rule itself is specified by `[\<modexp>].\<rule-name>]'. This means
the rule with name \<rule-name> of the module \<modexp> (if omitted, the
current module). \<rule-name> is either a label of a rule or a number 
which shown by \kbd{sh(ow) rules} command (see \textbf{ Showing Available
  Rules below}.) 

\<substitution> binds variables that apper in the selected rule before 
applying it. This has the form

\kbd{with} \<variable> \kbd{=} \<term> \kbd{,} ...

\paragraph{Showing Available Rules}
To see the list of the rewrite rules, use

\kbd{sh(ow)} [\kbd{all}] \kbd{rules}

The list of the (all, i.e., includes imported rules if the optional
\kbd{all} is supplied) available rules are printed with each of which
being numbered.  The number can be used for \<rule-name> (see above).

\paragraph{Selection}
\<selection> is a sequence of \<selector> separated by keyword
\kbd{of} specifying (sub)term of \kbd{\$\$term}:

\<selector> $\{$ \kbd{of} \<selector> $\}$ $\cdots$ 
%%% \paralign to \hsize{#\tabskip=4pt plus 1 fil&#\cr
\twocol{\textbf{ selector}}{\textbf{ description}}
\twocol{term}{the entire term (\kbd{\$\$term})}
\twocol{top}{ditto}
\twocol{subterm}{selects \kbd{\$\$subterm}}
\twocol{(\<number> $\cdots$ )}{selects by position}
\twocol{\kbd{[} \<number> \kbd{..} \<number> \kbd{]}}{by range
  in flattened term structure}
\twocol{\kbd{\{} \<number> \kbd{,} $\cdots$ \kbd{\}}}{subset
  in flattened term structure}
}

\paragraph{Step by Step Subterm Selection}
\kbd{choose} command selects a subterm of \kbd{\$\$subterm} and reset
the \kbd{\$\$subterm} to the selected one.

\kbd{choose} \<selector>

\paragraph{Matching Terms}

\kbd{match} \<term\_spec> \kbd{to} \<pattern>

\<term\_spec> specifies the term to be matched with \<pattern>:
%%% \paralign to \hsize{#\tabskip=4pt plus 1 fil&#\cr
\twocol{\textbf{ term\_spec}}{\textbf{ description}}
\twocol{\kbd{term}}{\kbd{\$\$term}}
\twocol{\kbd{top}}{ditto}
\twocol{\kbd{subterm}}{\kbd{\$\$term}}
\twocol{\kbd{it}}{ditto}
\twocol{\<term>}{ordinal term}
}

%%% \paralign to \hsize{#\tabskip=4pt plus 1 fil&#\cr
\twocol{\textbf{ pattern}}{\textbf{ description}}
\twocol{\kbd{[ all ][+ | -] rules}}{match with available rewrite
  rules}
\twocol{\<term>}{match with specified term}
}
%%% stepper
\section{Stepper}
If the switch \kbd{step} is set to \kbd{on}, invoking \kbd{reduce} or 
\kbd{execute} command runs into the term rewriting stepper.
The stepper has its own command interpreter loop, where the following
stepper commands are avilable:

%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{?}{print out available commands.}
\twocol{n(ext)}{go one step}
\twocol{g(o) \<number>}{go \<number> step}
\twocol{c(ontinue)}{continue rewriting without stepping}
\twocol{q(uit)}{leave stepper continuing rewrite}
\twocol{a(bort)}{abort rewriting}
\twocol{r(rule)}{prints current rewrite rule}
\twocol{s(ubst)}{prints substitution}
\twocol{l(imit)}{prints rewrite limit counter}
\twocol{p(attern)}{prints stop pattern}
\twocol{stop [\<term>]}{set (unset) stop pattern}
\twocol{rwt [\<number>]}{set (unset) rwrite limit counter}
}
You can also use families of \kbd{sh(ow)}(\kbd{desc(ribe)})
and \kbd{set} commands in stepper.

\section{Reading In Files}

%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{input \<file>}{read in \cafeobj\ program from \<file>}
\twocol{provide \<feature>}{provide the \<feature>}
\twocol{require \<feature> [\<file>]}{require \<feature>}
}
%%% save and restore
\section{Save and Restore}

%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{save \<file>}{save definitions of modules and views to \<file>}
\twocol{restore \<file>}{restore definitions of modules and views}
\twocol{reset}{recover definitions of built-in modules}
\twocol{full-reset}{reset system to initial status}
\twocol{save-system \<file>}{save image of the interpreter to \<file>}
}

%%% protecting your modules
\section{Protecting Your Modules}
%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{protect \<modexp>}{prevent the module from redefinition}
\twocol{unprotect \<modexp>}{allow moudle to be redefined}
}

%%% little semantic tools
\newcolumn
\section{Little Semantic Tools}
%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{check reg(ularity) [\<modexp>]}{reports the result of
  regularity}
\twocol{}{check of module}
\twocol{check comat(ibility) [\<modexp>}{reports the result of
  compatibility}
\twocol{}{check of the module}
}
For both commands, omitted \<modexp> will perform the
check in the current module.

The following \kbd{check} command assumes the current module:

\kbd{check laziness} [\<operator>]

This checks strictness of \<operator>. If \<operator> is omitted 
all of the operators declared in the current modules are checked.

\section{TRAM Compiler Interface}
\kbd{tram compile} [\<modexp>]

This compiles module \<modexp> to Term Rewriting Abstract Machine.
If \<modexp> is omitted, it defaults to the current module.
\<modexp> must be given in an line. You can supply multiple lines
by using `\kbd{;}$<$new-line$>$'. 

To evaluate term in compiled module, use the following:

\kbd{tram exec} [\kbd{in} \<modexp> :] \<term>

Omitting `\kbd{in} \<modexp> :' means the evaluation is performed in
the current module. If the module \<modexp> is not yet compiled,
this compiles it implicitly, then perform the evaluation.


\section{Miscellany}
%%% \paralign to \hsize{#\tabskip=10pt plus 1 fil&#\cr
\twocol{ls \<pathname>}{list contents of directories}
\twocol{cd \<pathname>}{change working directory of the interpreter}
\twocol{pwd}{prints working directory}
\twocol{! \<command>}{fork shell \<command>}
\twocol{ev \<lisp>}{evaluate lisp expression \<lisp> printing the
  result}
\twocol{evq \<lisp>}{evaluate lisp expression \<lisp>}
}
\newcolumn

\end{document}

% Local variables:
% compile-command: "xetex interp"
% TeX-master: t
% End:
